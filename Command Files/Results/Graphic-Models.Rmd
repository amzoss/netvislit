---
title: "Models for Combined NetVisLit Data"
author: "Angela Zoss"
date: "January 17, 2018"
output: github_document
---

Notes:

These command files should contain commands that open up your analysis data files, and then use those data to generate the output upon which your results are based.

Every command that generates any of your results should be preceded by a comyt that states which result the command generates.  A few Hypothetical examples illustrate what these comments might look like:

* The following command generates the first column of Table 6.

The command files for your analysis phase should not contain any commands that generate new variables or process your data in any way.  All the procedures required to prepare your data for analysis should be executed by the command files you wrote for the processing phase.

It is often convenient to write all the commands for the analysis phase in a single command file. However, if the nature of your project or the structure of your data are such that you think it would make sense to divide the code that generates the results into two or more command files, you should feel free to do so.  No matter how you organize your analysis command files, your Read Me file will include an explanation of how to use them to reproduce your results.

Save the command files you write for the analysis phase in the Command Files folder.

```{r setup}
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
```


## Detach previous packages

```{r}

detachAllPackages <- function() {

  basic.packages <- c("package:stats","package:graphics","package:grDevices","package:utils","package:datasets","package:methods","package:base")

  package.list <- search()[ifelse(unlist(gregexpr("package:",search()))==1,TRUE,FALSE)]

  package.list <- setdiff(package.list,basic.packages)

  if (length(package.list)>0)  for (package in package.list) detach(package, character.only=TRUE)

}

detachAllPackages()

```

## Load packages

```{r, message=FALSE}

require(tidyverse)
library(stringr)
#require(igraph)
library(ggraph)
library(tidygraph)

# mixed modeling

library(nlme)
library(lme4)
#library(car)
library(lmerTest)
#library(lsmeans)
library(emmeans)
library(multcompView)
library(r2glmm)
library(splines)

require(lattice)
source(system.file("utils", "allFit.R", package="lme4"))

# negative binomial

require(foreign)
require(MASS)

# beta regression
require(mgcv)
require(glmmTMB)
require(lmtest)
library(betareg)
library(car)
library(gamlss)
library(gamlss.dist)
library(RODBC)
library(rcompanion)
library(broom)
#library(BSagri)
#library(gamboostLSS)
library(brms)
library(tidybayes)
library(magrittr)



# mixed effects logistic

require(GGally)
require(reshape2)
require(compiler)
require(parallel)
require(boot)

# output

#library(officer)
#library(rvg)
#library(devEMF)

```

## Environmental Variables

```{r}

originalDataDir <- "../../Original Data"
analysisDataDir <- "../../Analysis Data"

generatedDataDir <- file.path(originalDataDir, "Generated data")

figureDir <- "../../Documents/"

```

## Loading analysis data files

TO DO : in previous scripts, save data with saveRDS

```{r, message=FALSE}

orig.graphics <- read_csv(file.path(analysisDataDir, "Graphics.csv"))

layoutfac <- read_csv(file.path(analysisDataDir, "LayoutFac.csv"))

```


## Slight processing for analysis

```{r}

graphics <- set_tidy_names(orig.graphics, syntactic=TRUE)

graphics$ClustConf <- factor(graphics$ClustConf,
                             levels = c("Very confident (76-100%)", 
                                        "Somewhat confident (51-75%)", 
                                        "Somewhat doubtful (26-50%)", 
                                        "Very doubtful (0-25%)"),
                             ordered = TRUE)

graphics$Dataset <- factor(graphics$Dataset, ordered = TRUE)

#Make control the reference group
#TO DO: decide on reference group for task??

graphics <- graphics %>% mutate(ConditionPhrasing = case_when(
  Condition == "Ctrl" ~ "1-Technical",
  Condition == "Phr" ~ "2-Informal",
  Condition == "Col" ~ "1-Technical",
  Condition == "Siz" ~ "1-Technical"
)
)

graphics <- graphics %>% mutate(ConditionGraphics = case_when(
  Condition == "Ctrl" ~ "1-Default",
  Condition == "Phr" ~ "1-Default",
  Condition == "Col" ~ "2-Color",
  Condition == "Siz" ~ "3-Size"
)
)

graphics <- graphics %>% mutate(ConditionColor = case_when(
  Condition == "Col" ~ "1-Color",
  Condition == "Phr" ~ "2-Other",
  Condition == "Ctrl" ~ "2-Other",
  Condition == "Siz" ~ "2-Other"
)
)


graphics <- graphics %>% mutate(Condition1 = factor(
  case_when(
  Condition == "Ctrl" ~ 0,
  Condition == "Phr" ~ 1,
  Condition == "Col" ~ 2,
  Condition == "Siz" ~ 3)
  )
)

graphics$Condition <- factor(graphics$Condition)

graphics$Condition <- relevel(graphics$Condition, ref = "Ctrl")

graphics <- graphics %>% mutate(Ctrl_dummy = 
                                  case_when(
                                    Condition == "Ctrl" ~ 1,
                                    Condition != "Ctrl" ~ 2)
                                )

graphics$ClustConf <- factor(graphics$ClustConf, levels=c("Very doubtful (0-25%)","Somewhat doubtful (26-50%)","Somewhat confident (51-75%)","Very confident (76-100%)"))

graphics$Demo.lang <- factor(graphics$Demo.lang)

graphics$Demo.educ <- factor(graphics$Demo.educ, 
                             levels = c("High School diploma",
                                        "Bachelor’s degree",
                                        "Master’s degree",
                                        "Professional degree",
                                        "Doctorate degree",
                                        "Other"),
                             ordered = TRUE)

freq4 <- c("None", "A little", "Some", "A lot", "Skipped")

graphics$Demo.expdataanal <- factor(graphics$Demo.expdataanal,
                                    levels = c(freq4),
                                    ordered = TRUE)

graphics$Demo.expdatavis <- factor(graphics$Demo.expdatavis,
                                    levels = c(freq4),
                                    ordered = TRUE)

graphics$Demo.expreadnetvis <- factor(graphics$Demo.expreadnetvis,
                                    levels = c(freq4),
                                    ordered = TRUE)

graphics <- graphics %>% mutate(Demo.expreadnetvis.alot = ifelse(Demo.expreadnetvis == "A lot",1,0))

graphics$Demo.expreadnetvis.alot <- factor(graphics$Demo.expreadnetvis.alot)

graphics <- graphics %>% mutate(Demo.expreadnetvis.none = ifelse(Demo.expreadnetvis == "None",1,0))

graphics$Demo.expreadnetvis.none <- factor(graphics$Demo.expreadnetvis.none)

graphics <- graphics %>% mutate(Demo.expreadnetvis.three = case_when(
  Demo.expreadnetvis == "None" ~ "None",
  Demo.expreadnetvis == "A little" ~ "A little",
  TRUE ~ "Other"
))

graphics$Demo.expreadnetvis.three <- factor(graphics$Demo.expreadnetvis.three)

graphics$Demo.expcreatenetvis <- factor(graphics$Demo.expcreatenetvis,
                                    levels = c(freq4),
                                    ordered = TRUE)

graphics <- graphics %>% mutate(Demo.expcreatenetvis.alot = ifelse(Demo.expcreatenetvis == "A lot",1,0))

graphics$Demo.expcreatenetvis.alot <- factor(graphics$Demo.expcreatenetvis.alot)


graphics <- graphics %>% mutate(Stats.OperatingSystemCombined = case_when(
  str_detect(Stats.OperatingSystem, "Android") ~ "Android",
  str_detect(Stats.OperatingSystem, "Windows") ~ "Windows",
  str_detect(Stats.OperatingSystem, "CrOS") ~ "CrOS",
  str_detect(Stats.OperatingSystem, "Linux") | str_detect(Stats.OperatingSystem, "Ubuntu") ~ "Linux/Ubuntu",
  TRUE ~ Stats.OperatingSystem)
)

graphics <- graphics %>% mutate(Stats.OperatingSystemCombined2 = case_when(
  str_detect(Stats.OperatingSystemCombined, "Android") | str_detect(Stats.OperatingSystemCombined, "iPhone") ~ "Android/iPhone",
  TRUE ~ Stats.OperatingSystemCombined)
)

graphics <- graphics %>% mutate(Stats.OperatingSystemCombined3 = case_when(
  str_detect(Stats.OperatingSystemCombined2, "Macintosh") | str_detect(Stats.OperatingSystemCombined2, "Windows") ~ Stats.OperatingSystemCombined2,
  TRUE ~ "Other")
)

graphics <- graphics %>% mutate(Stats.OperatingSystemCombined4 = case_when(
  str_detect(Stats.OperatingSystem, "Macintosh") | str_detect(Stats.OperatingSystem, "Windows") ~ "Mac/Windows",
  TRUE ~ "Other")
)

graphics <- graphics %>% mutate(Stats.OperatingSystemCombined5 = case_when(
  str_detect(Stats.OperatingSystem, "Macintosh") | str_detect(Stats.OperatingSystem, "Windows") | str_detect(Stats.OperatingSystem, "CrOS") ~ "Mac/Windows/CrOS",
  TRUE ~ "Other")
)

graphics <- graphics %>% mutate(Stats.OperatingSystemWindows = case_when(
  str_detect(Stats.OperatingSystem, "Windows") ~ "Windows",
  TRUE ~ "Other")
)

graphics <- graphics %>% mutate(Stats.OperatingSystemMacintosh = case_when(
  str_detect(Stats.OperatingSystem, "Windows") ~ "Macintosh",
  TRUE ~ "Other")
)

graphics <- graphics %>% mutate(Stats.OperatingSystemAndroid = case_when(
  str_detect(Stats.OperatingSystem, "Windows") ~ "Android",
  TRUE ~ "Other")
)

graphics <- graphics %>% mutate(Stats.OperatingSystemiPhone = case_when(
  str_detect(Stats.OperatingSystem, "Windows") ~ "iPhone",
  TRUE ~ "Other")
)

graphics <- graphics %>%  mutate(Stats.OperatingSystemNumClust = case_when(
  str_detect(Stats.OperatingSystem, "Android 6.0.1") ~ "1-HighSig", 
  str_detect(Stats.OperatingSystem, "CrOS x86_64 9592.96.0") ~ "1-HighSig", 
  str_detect(Stats.OperatingSystem, "Linux x86_64") ~ "1-HighSig", 
  str_detect(Stats.OperatingSystem, "Ubuntu") ~ "1-HighSig", 
  str_detect(Stats.OperatingSystem, "Windows NT 10.0") ~ "1-HighSig",
  str_detect(Stats.OperatingSystem, "Windows NT 5.1") ~ "1-HighSig", 
  str_detect(Stats.OperatingSystem, "Windows NT 6.0") ~ "1-HighSig", 
  str_detect(Stats.OperatingSystem, "Windows NT 6.1") ~ "1-HighSig",
  TRUE ~ "Other"))

graphics <- graphics %>% mutate(Demo.acfieldGrouped = case_when(
  Demo.acfield %in% c("Anthropology","Arts","Classics","History","Languages","Literature","Philosophy","Religion") ~ "Humanities",
  Demo.acfield %in% c("Archaeology","Communication studies","Cultural and ethnic studies","Economics","Geography","Information science","Linguistics","Political science","Psychology","Sociology") ~ "Social sciences",
  Demo.acfield %in% c("Biology","Chemistry","Earth sciences","Physics","Space sciences") ~ "Life sciences",
  Demo.acfield %in% c("Mathematics","Computer sciences","Logic","Statistics","Systems science") ~ "Formal sciences",
  Demo.acfield %in% c("Architecture and design","Business","Divinity","Education","Engineering","Human physical performance and recreation","Journalism, media studies and communication","Law","Library and museum studies","Medicine","Military sciences","Public administration") ~ "Professional",
  TRUE ~ Demo.acfield
))

graphics <- graphics %>% mutate(Demo.acfieldGrouped2 = case_when(
  Demo.acfield %in% c("Architecture and design", "Arts", "Business","Earth sciences","Information science","Languages","Library and museum studies","Other","Political science","Psychology") ~ "SignificantGroup",
  TRUE ~ "ZZ-Etc."
))

graphics <- graphics %>% mutate(Demo.acfieldGrouped3 = case_when(
  Demo.acfield %in% c("Business", "Arts", "Computer sciences", "Economics", "Information science", "Law", "Linguistics", "Medicine", "Other", "Political science", "Skipped", "Sociology") ~ "SignificantGroup",
  TRUE ~ "ZZ-Etc."
))

graphics <- graphics %>% mutate(Overestimated = case_when(
  Underestimated == "over" ~ "1-Overestimated",
  Underestimated %in% c("correct","under") ~ "2-CorrectOrUnder"
))

graphics <- graphics %>% mutate(UnderestDummy = case_when(
  Underestimated == "under" ~ "1-Underestimated",
  Underestimated %in% c("correct","over") ~ "2-CorrectOrOver"
))


```


```{r}

# separate datasets for each Task

graphics_avgdeg <- graphics %>% filter(Task == "AvgDeg")

graphics_bc <- graphics %>% filter(Task == "BC")

graphics_clickhighdeg <- graphics %>% filter(Task == "ClickHighDeg")

graphics_lgclust <- graphics %>% filter(Task == "LargeClust1")

graphics_numclust <- graphics %>% filter(Task == "NumClust")

graphics_numhighdeg <- graphics %>% filter(Task == "NumHighDegree")

graphics_numlinks <- graphics %>% filter(Task == "NumLinks")

graphics_numnodes <- graphics %>% filter(Task == "NumNodes")


```

```{r}

# Setting up colors, etc., for lsmeans plots

sig.level.names <- c("p < .0001","p < .001","p < .01","p < .05","NS")
sig.colors <- c("gray20", "gray35", "gray50", "gray65", "white")
names(sig.colors) <- sig.level.names
star.colors <- c("gray20","white")
names(star.colors) <- c(TRUE, FALSE)

```

## Mixed Models

```{r}

graphics %>% filter(Task %in% c("AvgDeg","NumClust","NumHighDegree","NumLinks","NumNodes")) %>% 
  ggplot(aes(Task, LogError)) + geom_boxplot() + #scale_y_log10() +
  labs(title="Distribution of LogError for Numerical Response Tasks,\ngraphics conditions")

graphics %>% filter(Task %in% c("AvgDeg","NumClust","NumHighDegree","NumLinks","NumNodes")) %>% 
  ggplot(aes(Dataset, Percentage)) + geom_boxplot() + #scale_y_log10() +
  labs(title="Distribution of Percentage for Numerical Response Tasks,\ngraphics conditions") +
  facet_wrap(~Task) + scale_y_log10()

graphics %>% filter(Task %in% c("AvgDeg","NumClust","NumHighDegree","NumLinks","NumNodes")) %>% 
  ggplot(aes(Dataset, abs(Response - CorrectAnswer)/CorrectAnswer)) + geom_violin() + #scale_y_log10() +
  labs(title="Error as Percentage of Correct Answer for Numerical Response Tasks,\ngraphics conditions") +
  facet_wrap(~Task) + scale_y_log10(breaks=c(.1,10,1000),labels=c("10%","1,000%","100,000%")) +
  geom_hline(yintercept = 1)

graphics %>% filter(Task %in% c("AvgDeg","NumClust","NumHighDegree","NumLinks","NumNodes")) %>%
ggplot() + geom_violin(aes(Dataset,Response)) + geom_point(data=graphics %>% filter(Task %in% c("AvgDeg","NumClust","NumHighDegree","NumLinks","NumNodes")) %>% group_by(Task, Dataset) %>% summarise(Correct=mean(CorrectAnswer)), aes(Dataset,Correct)) +
facet_grid(.~Task) + scale_y_log10()

graphics %>% filter(Task %in% c("AvgDeg","NumClust","NumHighDegree","NumLinks","NumNodes")) %>%
    ggplot() + geom_boxplot(aes(Dataset,LogError)) +
    facet_grid(.~Task) + labs(title="LogError distributions by Task and Dataset, graphics conditions")

ggplot(graphics_bc) +
  geom_bar(aes(NodeRank)) +
  #coord_flip() +
  labs(title="Rank of Selected Node for Betweenness Centrality Task by Dataset",
       x="Rank of selected node", y="Number of times selected") +
  facet_wrap(~Dataset, scales="free_x")

```


### Average Degree

#### nlme

```{r, cache=TRUE}

# https://iucat.iu.edu/catalog/14518998, chapters 3 and 5
# data at http://www-personal.umich.edu/~bwest/almmussp.html

# testing models, no nesting/grouping

# Repeated measures, tasks and datasets (crossed)

# starting with older package (nlme), with function lme()

# R by default treats the lowest category (alphabetically or numerically) of a
# categorical fixed factor as the reference category in a model

# We don't really have reference categories for the repeated measures factors, 
# though, so I guess it doesn't matter?  Maybe want to exclude training dataset

# Note about syntax; can use either ":" or "*" for interaction, but using "*" automatically adds
# the main effects of each factor into the model, too, instead of just the interaction

graph.avgdeg.lme <- lme(LogError ~ Dataset, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg)

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)


# Dataset is not significant for AvgDeg; try Condition

graph.avgdeg.lme <- lme(LogError ~ Condition, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg)

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# Condition is not significant; try ConditionPhrasing

graph.avgdeg.lme <- lme(LogError ~ ConditionPhrasing, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg)

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# ConditionPhrasing is not significant; try ConditionGraphics

graph.avgdeg.lme <- lme(LogError ~ ConditionGraphics, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg)

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# ConditionGraphics is not significant; try TaskOrder

graph.avgdeg.lme <- lme(LogError ~ TaskOrder, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg)

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# TaskOrder is not significant; try DatasetOrder

graph.avgdeg.lme <- lme(LogError ~ DatasetOrder, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg)

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# DatasetOrder is not significant; try DatasetDuration

graph.avgdeg.lme <- lme(LogError ~ DatasetDuration, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg %>% filter(!(is.na(DatasetDuration))))

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# DatasetDuration is not significant; try Stats.Q_TotalDuration

graph.avgdeg.lme <- lme(LogError ~ Stats.Q_TotalDuration, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg)

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# Stats.Q_TotalDuration is not significant; try Stats.OperatingSystem

graph.avgdeg.lme <- lme(LogError ~ Stats.OperatingSystem, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg)

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# Stats.OperatingSystem is not significant; try StatsNumPixels

graph.avgdeg.lme <- lme(LogError ~ StatsNumPixels, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg)

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# StatsNumPixels is not significant; try Demo.age

graph.avgdeg.lme <- lme(LogError ~ Demo.age, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg %>% filter(!(is.na(Demo.age))))

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# Demo.age is not significant; try Demo.gender

graph.avgdeg.lme <- lme(LogError ~ Demo.gender, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg %>% filter(!(is.na(Demo.gender))))

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# Demo.gender is not significant; try Demo.lang

graph.avgdeg.lme <- lme(LogError ~ Demo.lang, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg %>% filter(!(is.na(Demo.lang))))

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# Demo.lang is not significant; try Demo.educ

graph.avgdeg.lme <- lme(LogError ~ Demo.educ, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg %>% filter(!(is.na(Demo.educ))))

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# Demo.educ is not significant; try Demo.acfield

graph.avgdeg.lme <- lme(LogError ~ Demo.acfield, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg %>% filter(!(is.na(Demo.acfield))))

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# Demo.acfield is not significant; try Demo.dailytech_Computer

graph.avgdeg.lme <- lme(LogError ~ Demo.dailytech_Computer, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg %>% filter(!(is.na(Demo.dailytech_Computer))))

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# Demo.dailytech_Computer is not significant; try Demo.dailytech_Tablet

graph.avgdeg.lme <- lme(LogError ~ Demo.dailytech_Tablet, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg %>% filter(!(is.na(Demo.dailytech_Tablet))))

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# Demo.dailytech_Tablet is not significant; try Demo.dailytech_SmartPhone

graph.avgdeg.lme.SP <- lme(LogError ~ Demo.dailytech_SmartPhone, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg %>% filter(!(is.na(Demo.dailytech_SmartPhone))))

# TO DO : figure out if SmartPhone should be a factor

summary(graph.avgdeg.lme.SP)

anova(graph.avgdeg.lme.SP)

## Demo.dailytech_SmartPhone *is* significant

ggplot(graphics_avgdeg) +
  geom_point(aes(Demo.dailytech_SmartPhone, LogError)) +
  geom_smooth(aes(Demo.dailytech_SmartPhone, LogError), method="lm")

# try Demo.weeklygaming

graph.avgdeg.lme <- lme(LogError ~ Demo.weeklygaming, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg %>% filter(!(is.na(Demo.weeklygaming))))

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# Demo.weeklygaming not significant; try Demo.expdataanal

graph.avgdeg.lme <- lme(LogError ~ Demo.expdataanal, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg %>% filter(!(is.na(Demo.expdataanal))))

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# Demo.expdataanal not significant; try Demo.expdatavis

graph.avgdeg.lme <- lme(LogError ~ Demo.expdatavis, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg %>% filter(!(is.na(Demo.expdatavis))))

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# Demo.expdatavis not significant; try Demo.expreadnetvis

graph.avgdeg.lme.RNV <- lme(LogError ~ Demo.expreadnetvis, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg %>% filter(!(is.na(Demo.expreadnetvis))))

summary(graph.avgdeg.lme.RNV)

anova(graph.avgdeg.lme.RNV)

# Demo.expreadnetvis barely significant (p=0.0494); try just the experts (only 1, actually)

graph.avgdeg.lme.RNVAL <- lme(LogError ~ Demo.expreadnetvis.alot, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg %>% filter(!(is.na(Demo.expreadnetvis.alot))))

summary(graph.avgdeg.lme.RNVAL)

anova(graph.avgdeg.lme.RNVAL)

# better, but still barely significant; p = 0.0106

# try Demo.expcreatenetvis

graph.avgdeg.lme <- lme(LogError ~ Demo.expcreatenetvis, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg %>% filter(!(is.na(Demo.expcreatenetvis))))

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# Demo.expcreatenetvis not significant; try AvgDeg

graph.avgdeg.lme <- lme(LogError ~ AvgDeg, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg)

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# AvgDeg not significant; try Density

graph.avgdeg.lme <- lme(LogError ~ Density, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg)

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# Density not significant; try LargeClust1

graph.avgdeg.lme <- lme(LogError ~ LargeClust1, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg)

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# LargeClust1 not significant; try Modularity

graph.avgdeg.lme <- lme(LogError ~ Modularity, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg)

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# Modularity not significant; try NumClust

graph.avgdeg.lme <- lme(LogError ~ NumClust, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg)

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# NumClust not significant; try NumHighDegree

graph.avgdeg.lme <- lme(LogError ~ NumHighDegree, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg)

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# NumHighDegree not significant; try NumLinks

graph.avgdeg.lme <- lme(LogError ~ NumLinks, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg)

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# NumLinks not significant; try NumNodes

graph.avgdeg.lme <- lme(LogError ~ NumNodes, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg)

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# NumNodes not significant; try NumNodesClust1

graph.avgdeg.lme <- lme(LogError ~ NumNodesClust1, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg)

summary(graph.avgdeg.lme)

anova(graph.avgdeg.lme)

# Final; try both significant factors

graph.avgdeg.lme.SP.RNVAL <- lme(LogError ~ Demo.dailytech_SmartPhone + Demo.expreadnetvis.alot, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg %>% filter(!(is.na(Demo.dailytech_SmartPhone))) %>% filter(!(is.na(Demo.expreadnetvis.alot))))

summary(graph.avgdeg.lme.SP.RNVAL)

anova(graph.avgdeg.lme.SP.RNVAL)

# Better than just one predictor?

anova(graph.avgdeg.lme.SP.RNVAL, graph.avgdeg.lme.SP)

# no significant difference

graph.avgdeg.lme.RNVAL <- lme(LogError ~ Demo.expreadnetvis.alot, random = ~ 1 | Demo.ResponseID, method="REML", data=graphics_avgdeg %>% filter(!(is.na(Demo.dailytech_SmartPhone))) %>% filter(!(is.na(Demo.expreadnetvis.alot))))

anova(graph.avgdeg.lme.SP.RNVAL, graph.avgdeg.lme.RNVAL)

# no significant difference; guess we can use both predictors? or maybe should just use stronger
# predictor, SmartPhone?


random.effects(graph.avgdeg.lme.SP)

# do we really need random effects?  test model without random effects using gls

graph.avgdeg.gls <- gls(LogError ~ Demo.dailytech_SmartPhone, data=graphics_avgdeg %>% filter(!(is.na(Demo.dailytech_SmartPhone))))

anova(graph.avgdeg.lme.SP, graph.avgdeg.gls)

# result of anova is significant (p=0.0019), indicating that there is a significant difference when
# you remove random effects, so should leave them in

```

```{r, eval=FALSE}

# NOTE: nesting is not appropriate, but syntax for tests might be useful in future

# model with nesting; takes *forever* but does finish
# can nest when I recode Condition as 0, 1, 2, 3 (Condition1), 
# but if I just list Ctrl as the ref (Condition), won't converge

model.lme.update.nest <- update(model.lme, random = ~ Condition1 | Demo.ResponseID)

summary(model.lme.update.nest)

anova(model.lme.update.nest)

# might want to check whether nesting makes a difference, but can't run anova because 
# "the test statistic has a null distribution that is a mixture of X12 and X22 distributions
# with equal weights of 0.5, so the anova() function cannot be used for the p-value." (p.220)

# Check summary of each model for -2 REML log-likelihood values 

# "logLik" value for unnested: -14415.3
# "logLik" value for nested: -14441
# -2 REML logLik is just -2 * the logLik value

# test statistics = unnested - nested
test.stat <- abs((-2*-14415.3) - (-2*-14441)) # ~51.4

# note: when test.stat was negative, p-value was not significant, but highly significant when
# positive
p.val <- 0.5*(1-pchisq(test.stat,1)) + 0.5*(1-pchisq(test.stat,2))

# p-value is < 0.001, so nesting is significantly different


```

```{r, cache=TRUE}

# adding weights to have a separate residual variance for each treatment group
# TO DO: are these the only weights I need to consider???  check that these weights make sense

graph.avgdeg.weight <- lme(LogError ~ Demo.dailytech_SmartPhone, 
                 random = ~ 1 | Demo.ResponseID, 
                 method="REML", 
                 data=graphics_avgdeg %>% filter(!(is.na(Demo.dailytech_SmartPhone))),
                 weights = varIdent(form = ~1 | Condition))

summary(graph.avgdeg.weight)

# Parameter estimates are:
#    Ctrl      Siz      Phr      Col 
#1.000000 1.486356 1.409153 1.436532 

anova(graph.avgdeg.lme.SP, graph.avgdeg.weight)

# result is significant (p<.0001), which suggests that we should retain the second model with the 
# weights,  otherwise known as the "heterogeneous variances model" (p. 94)


```

```{r, cache=TRUE}

graph.avgdeg.weight.pooled <- lme(LogError ~ Demo.dailytech_SmartPhone, 
                 random = ~ 1 | Demo.ResponseID, 
                 method="REML", 
                 data=graphics_avgdeg %>% filter(!(is.na(Demo.dailytech_SmartPhone))),
                 weights = varIdent(form = ~1 | Ctrl_dummy))

anova(graph.avgdeg.weight, graph.avgdeg.weight.pooled)

# test is not significant, so should not keep the weights pooled? p. 95 not clear, since in 
# example difference is not significant but pooled model is retained anyway

summary(graph.avgdeg.weight)
anova(graph.avgdeg.weight)

```

```{r, cache=TRUE}

# TO DO: need to conduct Type I F-test (section 5.7)? to try to remove nonsignficant fixed effects?
# note p. 223 explains that large F-statistics can indicate significance, even when you don't compute
# p-values

# another way to test if each additional item is significant:
# create two models, one with and one without the fixed effect
# use ML estimation (REML = F for lmer()) for each
# use anova() to compare the models (see 4.4.3.2)

# On p. 238, talks about needing to be careful about interpretation because an interaction is
# also significant; can investigate "estimated marginal means" of the combinations of levels in the
# interaction (needs to be pairwise for the interaction?)

# On p. 133, "Post-hoc comparisons can also be computed in R with 
# some additional programming (Faraway, 2005)"

# From Faraway, 2015, p. 20:
# https://search.library.duke.edu/search?id=DUKE008022150

# "We can extract the regression quantities we need from the model object. Commonly used are residuals(),
# fitted(), df.residual() which gives the degrees of freedon, deviance() which gives the RSS and
# coef() which gives the ^Beta."

modsum <- summary(graph.avgdeg.weight)
names(modsum)
modsum$logLik * -2

modsum$sigma # 0.711... what is sigma, exactly?

```


```{r, cache=TRUE}

# Residuals plot
plot(graph.avgdeg.weight)

# Residuals vs. SmartPhone, scatterplot
plot(graph.avgdeg.weight, Demo.dailytech_SmartPhone ~ resid(.))

# Predicted vs. SmartPhone
plot(graph.avgdeg.weight, Demo.dailytech_SmartPhone ~ fitted(.))


# Predicted vs. Actual LogError
plot(graph.avgdeg.weight, LogError ~ fitted(.), abline = c(0,1))

qqnorm(graph.avgdeg.weight, abline = c(0,1))

qqnorm(graph.avgdeg.weight, ~ resid(., type = "p") | Demo.dailytech_SmartPhone, abline = c(0,1))

qqnorm(graph.avgdeg.weight, ~ resid(., type = "p") | Condition, abline = c(0,1))

qqnorm(graph.avgdeg.weight, ~ranef(.))


```

#### lme4

```{r, eval=FALSE}

# Trying dataset first

graph.avgdeg.lmer <- lmer(LogError ~ Dataset + (1|Demo.ResponseID), data = graphics_avgdeg, REML = T)

lmsum <- summary(graph.avgdeg.lmer)
lmsum
#names(lmsum)

anova(graph.avgdeg.lmer)

# Dataset not significant; trying SmortPhone

graph.avgdeg.lmer.SP <- lmer(LogError ~ Demo.dailytech_SmartPhone + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!(is.na(Demo.dailytech_SmartPhone))), REML = T)

summary(graph.avgdeg.lmer.SP)

anova(graph.avgdeg.lmer.SP)

# Smartphone is significant; trying readnetvisalot

graph.avgdeg.lmer.RNVAL <- lmer(LogError ~ Demo.expreadnetvis.alot + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!(is.na(Demo.expreadnetvis.alot))), REML = T)

summary(graph.avgdeg.lmer.RNVAL)

anova(graph.avgdeg.lmer.RNVAL)

# slightly significant; trying both

graph.avgdeg.lmer.SP.RNVAL <- lmer(LogError ~ Demo.dailytech_SmartPhone + Demo.expreadnetvis.alot + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!(is.na(Demo.dailytech_SmartPhone))) %>% filter(!(is.na(Demo.expreadnetvis.alot))), REML = T)

summary(graph.avgdeg.lmer.SP.RNVAL)

anova(graph.avgdeg.lmer.SP.RNVAL)

```

```{r, cache=TRUE}

# Condition

graph.avgdeg.lmer <- lmer(LogError ~ Condition + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Condition is not significant; trying Ctrl_dummy

graph.avgdeg.lmer <- lmer(LogError ~ Ctrl_dummy + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Ctrl_dummy is not significant; trying ConditionPhrasing

graph.avgdeg.lmer <- lmer(LogError ~ ConditionPhrasing + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# ConditionPhrasing is not significant

graph.avgdeg.lmer <- lmer(LogError ~ ConditionGraphics + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# ConditionGraphics is not significant

graph.avgdeg.lmer <- lmer(LogError ~ ConditionColor + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# ConditionColor is not significant

# trying Dataset

graph.avgdeg.lmer <- lmer(LogError ~ Dataset + (1|Demo.ResponseID), data = graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Dataset is not significant

#graph.avgdeg.lmer <- lmer(LogError ~ QuestionOrder + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

graphics_avgdeg.CS <- graphics_avgdeg %>% mutate(QuestionOrder=scale(QuestionOrder))

graph.avgdeg.lmer <- lmer(LogError ~ QuestionOrder + (1|Demo.ResponseID), data=graphics_avgdeg.CS, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# QuestionOrder is not significant

graph.avgdeg.lmer <- lmer(LogError ~ DatasetOrder + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# DatasetOrder is not significant

graph.avgdeg.lmer <- lmer(LogError ~ DatasetDuration + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# DatasetDuration is not significant

graph.avgdeg.lmer <- lmer(LogError ~ DatasetStartTime + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# DatasetStartTime is not significant; trying TaskOrder

graph.avgdeg.lmer <- lmer(LogError ~ TaskOrder + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# TaskOrder is not significant; trying CorrectAnswer

graph.avgdeg.lmer <- lmer(LogError ~ CorrectAnswer + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# CorrectAnswer is not significant

graph.avgdeg.lmer.underest <- lmer(LogError ~ Underestimated + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer.underest)

anova(graph.avgdeg.lmer.underest)

# Underestimated is highly significant (p < 2.2e-16)

graph.avgdeg.lmer <- lmer(LogError ~ Stats.Q_TotalDuration + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Stats.Q_TotalDuration is not significant; trying Stats.dataset_count

graph.avgdeg.lmer <- lmer(LogError ~ Stats.dataset_count + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Stats.dataset_count is not significant; trying Stats.OperatingSystem

graph.avgdeg.lmer <- lmer(LogError ~ Stats.OperatingSystem + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Stats.OperatingSystem is not significant

graph.avgdeg.lmer <- lmer(LogError ~ Stats.OperatingSystemCombined + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Stats.OperatingSystemCombined is not significant

graph.avgdeg.lmer <- lmer(LogError ~ Stats.OperatingSystemiPhone + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Stats.OperatingSystemiPhone is not significant

graphics_avgdeg.CS <- graphics_avgdeg %>% mutate(StatsNumPixels=scale(StatsNumPixels))

graph.avgdeg.lmer <- lmer(LogError ~ StatsNumPixels + (1|Demo.ResponseID), data=graphics_avgdeg.CS, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# StatsNumPixels is not significant; trying Demo.age

graph.avgdeg.lmer <- lmer(LogError ~ Demo.age + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!(is.na(Demo.age))), REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Demo.age is not significant; trying Demo.gender

graph.avgdeg.lmer <- lmer(LogError ~ Demo.gender + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!(is.na(Demo.gender))), REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Demo.gender is not signficant; trying Demo.lang

graph.avgdeg.lmer <- lmer(LogError ~ Demo.lang + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!(is.na(Demo.lang))), REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Demo.lang is not signficant; trying Demo.educ

graph.avgdeg.lmer <- lmer(LogError ~ Demo.educ + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!(is.na(Demo.educ))), REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Demo.educ is not signficant; trying Demo.acfield

graph.avgdeg.lmer <- lmer(LogError ~ Demo.acfield + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!(is.na(Demo.acfield))), REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Demo.acfield is not signficant overall; trying Demo.acfieldGrouped

graph.avgdeg.lmer <- lmer(LogError ~ Demo.acfieldGrouped + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!(is.na(Demo.acfieldGrouped))), REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Demo.acfieldGrouped is not significant

graph.avgdeg.lmer <- lmer(LogError ~ Demo.acfieldGrouped2 + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!(is.na(Demo.acfieldGrouped2))), REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Demo.acfieldGrouped2 is not significant

graph.avgdeg.lmer <- lmer(LogError ~ Demo.acfieldGrouped3 + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!(is.na(Demo.acfieldGrouped3))), REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Demo.acfieldGrouped3 is not signficant

graph.avgdeg.lmer <- lmer(LogError ~ Demo.dailytech_Computer + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!(is.na(Demo.dailytech_Computer))), REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Demo.dailytech_Computer is not significant; trying Demo.dailytech_Tablet

graph.avgdeg.lmer <- lmer(LogError ~ Demo.dailytech_Tablet + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!(is.na(Demo.dailytech_Tablet))), REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Demo.dailytech_Computer is not significant

graph.avgdeg.lmer.SP <- lmer(LogError ~ Demo.dailytech_SmartPhone + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!(is.na(Demo.dailytech_SmartPhone))), REML = T)

summary(graph.avgdeg.lmer.SP)

anova(graph.avgdeg.lmer.SP)

# Demo.dailytech_SmartPhone is significant

graph.avgdeg.lmer <- lmer(LogError ~ Demo.weeklygaming + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!(is.na(Demo.weeklygaming))), REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Demo.weeklygaming is not significant; trying Demo.expdataanal

graph.avgdeg.lmer <- lmer(LogError ~ Demo.expdataanal + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!(is.na(Demo.expdataanal))), REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Demo.expdataanal is not significant; trying Demo.expdatavis

graph.avgdeg.lmer <- lmer(LogError ~ Demo.expdatavis + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!(is.na(Demo.expdatavis))), REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Demo.expdatavis is not significant; trying Demo.expreadnetvis

graph.avgdeg.lmer.ERNV <- lmer(LogError ~ Demo.expreadnetvis + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!(is.na(Demo.expreadnetvis))), REML = T)

summary(graph.avgdeg.lmer.ERNV)

anova(graph.avgdeg.lmer.ERNV)

# Demo.expreadnetvis is somewhat significant (p=0.04943), but very small numbers in some categories

graph.avgdeg.lmer <- lmer(LogError ~ Demo.expreadnetvis.none + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!(is.na(Demo.expreadnetvis.none))), REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Demo.expreadnetvis.none is not significant

graph.avgdeg.lmer <- lmer(LogError ~ Demo.expreadnetvis.three + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!(is.na(Demo.expreadnetvis.three))), REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Demo.expreadnetvis.three is not significant; 

graph.avgdeg.lmer <- lmer(LogError ~ Demo.expcreatenetvis + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!(is.na(Demo.expcreatenetvis))), REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Demo.expcreatenetvis is not significant; trying Demo.expcreatenetvis.alot

graph.avgdeg.lmer <- lmer(LogError ~ Demo.expcreatenetvis.alot + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!(is.na(Demo.expcreatenetvis.alot))), REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Demo.expcreatenetvis.alot is not significant; trying AvgDeg

graph.avgdeg.lmer <- lmer(LogError ~ AvgDeg + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# AvgDeg is not significant

graph.avgdeg.lmer <- lmer(LogError ~ Density + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Density is not significant

graph.avgdeg.lmer <- lmer(LogError ~ LargeClust1 + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# LargeClust1 is note significant

graph.avgdeg.lmer <- lmer(LogError ~ Modularity + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# Modularity is not significant

graph.avgdeg.lmer <- lmer(LogError ~ NumClust + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# NumClust is not significant

graph.avgdeg.lmer <- lmer(LogError ~ NumHighDegree + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# NumHighDegree is not significant

graph.avgdeg.lmer <- lmer(LogError ~ NumLinks + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# NumLinks is not significant

graph.avgdeg.lmer <- lmer(LogError ~ NumNodes + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# NumNodes is not significant

graph.avgdeg.lmer <- lmer(LogError ~ NumNodesClust1 + (1|Demo.ResponseID), data=graphics_avgdeg, REML = T)

summary(graph.avgdeg.lmer)

anova(graph.avgdeg.lmer)

# NumNodesClust1 is not significant


```


```{r}

temp <- graphics_avgdeg %>% dplyr::select(Demo.ResponseID, LogError, Underestimated, Demo.dailytech_SmartPhone) %>% drop_na()

graph.avgdeg.lmer.SP <- lmer(LogError ~ Demo.dailytech_SmartPhone + (1|Demo.ResponseID), data=temp, REML = T)

graph.avgdeg.lmer.underest <- lmer(LogError ~ Underestimated + (1|Demo.ResponseID), data=temp, REML = T)

graph.avgdeg.lmer.full <- lmer(LogError ~ Underestimated + Demo.dailytech_SmartPhone + (1|Demo.ResponseID), data=temp, REML = T)

summary(graph.avgdeg.lmer.full)

anova(graph.avgdeg.lmer.full)

anova(graph.avgdeg.lmer.full, graph.avgdeg.lmer.SP)
anova(graph.avgdeg.lmer.full, graph.avgdeg.lmer.underest)
# keep full

graph.avgdeg.lmer.int <- lmer(LogError ~ Underestimated + Demo.dailytech_SmartPhone + Underestimated:Demo.dailytech_SmartPhone + (1|Demo.ResponseID), data=temp, REML = T)

summary(graph.avgdeg.lmer.int)

anova(graph.avgdeg.lmer.int)

anova(graph.avgdeg.lmer.full, graph.avgdeg.lmer.int)
# interaction not significantly better; keep full

```

```{r}

#SAVE THE RESULTS
save(graph.avgdeg.lmer.full, file = file.path(analysisDataDir,"fits/graph_avgdeg_lmer_full.RData"))

```

```{r, cache=TRUE}

rand(graph.avgdeg.lmer.full)

# result shows that random effects of participant are not significant (p=0.07), but going to keep anyway(?)

anova(graph.avgdeg.lmer.full)

#ranef(graph.avgdeg.lmer.full)

# displays the random effects; not that useful

# unlike lme(), lmer() doesn't allow for heterogeneous error variance structures (the "weights")

ggplot(graphics_avgdeg) + geom_histogram(aes(LogError), binwidth=.005) + labs(title="Distribution of LogError values for Average Degree task,\ngraphics conditions")

(r2nsj = r2beta(graph.avgdeg.lmer.full, method = 'nsj', partial = TRUE))
(r2nsj = r2beta(graph.avgdeg.lmer.full, method = 'nsj', partial = TRUE))[1,'Rsq']

```

```{r, eval=FALSE}

# From Faraway (2015), p. 156 - use step() to start with a complex model and 
# systematically remove each effects

graph.avgdeg.full.lmer <- lmer(LogError ~ Dataset + Condition + 
                           QuestionOrder + (1|Demo.ResponseID), 
                         data = graphics_avgdeg, REML = T)

step(graph.avgdeg.full.lmer)

# not sure this is useful

```

```{r, eval=FALSE}

# Clustered Longitudinal Data (Chapter 7)
# Data are not clustered, so can skip

#model7.1.fit <- lme(gcf ~ time + 
#                   base_gcf + cda + 
#                   age + 
#                   time:base_gcf + time:cda + 
#                   time:age, 
#                   random = list(patient = ~time, tooth = ~1), 
#                   data = veneer, 
#                   method = "REML")

clust.model.fit <- lme(LogError ~ Task + TaskOrder +
                         Dataset + DatasetOrder +
                         Task:TaskOrder + 
                         Task:Dataset + Task:DatasetOrder,
                       random = list(`Demo.ResponseID` = ~Condition),
                       data = graphics_avgdeg,
                       method = "REML")

summary(clust.model.fit)

intervals(clust.model.fit, which="fixed")

random.effects(clust.model.fit)

```

```{r}

plot(graph.avgdeg.lmer.full)

plot(graph.avgdeg.lmer.full, resid(., scaled=TRUE) ~ fitted(.), abline = 0)

plot(graph.avgdeg.lmer.full, resid(.) ~ fitted(.) | Underestimated, abline = 0)

plot(graph.avgdeg.lmer.full, resid(., scaled=TRUE) ~ fitted(.) | Underestimated, abline = 0)

plot(graph.avgdeg.lmer.full, LogError ~ fitted(.), abline = c(0,1))



```

```{r}

graph.avgdeg.lmer.full.f <- fortify(graph.avgdeg.lmer.full)

ggplot(graph.avgdeg.lmer.full.f) +
  geom_density(aes(.fitted))

ggplot(graph.avgdeg.lmer.full.f, aes(.fitted,.resid)) + 
  geom_point() +
  #facet_grid(.~Sex) + 
  geom_hline(yintercept=0)

ggplot(graph.avgdeg.lmer.full.f, aes(LogError,.fitted)) + 
  geom_point() +
  geom_abline(aes(slope = 1, intercept = 0)) +
  scale_y_continuous(limits=c(0,0.3)) +
  labs(title="Real vs. Predicted LogError values for Average Degree task,\ngraphics conditions")


```

```{r, eval=FALSE}

# TO DO: check out interpretation for these plots??

library(lattice)

prof <-  profile(graph.avgdeg.lmer.full, optimizer="Nelder_Mead", which="beta_")

prof.CI <- confint(prof)

#CI2 <- confint(graph.avgdeg.lmer.SP, maxpts = 8)

xyplot(prof)

xyplot(prof, absVal = TRUE)

xyplot(prof, conf = c(0.95, 0.99), main = "95% and 99% profile() intervals")

# can also apply logProf() and varianceProf() to profile object

densityplot(prof)

splom(prof)

```


#### Logistic regression for over/underestimation with mixed effects (lme4, glmer)

```{r, eval=FALSE}

# https://stats.idre.ucla.edu/r/dae/mixed-effects-logistic-regression/

#ggpairs(graphics_avgdeg %>% dplyr::select(Response, DatasetDuration, CorrectAnswer, AbsDifference, Stats.Q_TotalDuration, StatsNumPixels, Demo.age, Demo.dailytech_Computer, Demo.dailytech_Tablet, Demo.dailytech_SmartPhone, Demo.weeklygaming, AvgDeg, Density, LargeClust1, Modularity, NumClust, NumHighDegree, NumLinks, NumNodes, NumNodes))

```

```{r, eval=FALSE}

graphics_avgdeg_incorrect <- graphics_avgdeg %>% filter(Underestimated != "correct")

graphics_avgdeg_incorrect$Underestimated <- factor(graphics_avgdeg_incorrect$Underestimated)

graph.avgdeg.logit <- glmer(Underestimated ~ Dataset + Condition +
    (1 | Demo.ResponseID), data = graphics_avgdeg_incorrect, family = binomial, control = glmerControl(optimizer = "bobyqa"),
    nAGQ = 10)

print(graph.avgdeg.logit, corr = FALSE)

se <- sqrt(diag(vcov(graph.avgdeg.logit)))

# table of estimates with 95% CI using coefficients
(tab <- cbind(Est = fixef(graph.avgdeg.logit), LL = fixef(graph.avgdeg.logit) - 1.96 * se, UL = fixef(graph.avgdeg.logit) + 1.96 * se))

# odds ratios instead of coefficients
exp(tab)

```

```{r, eval=FALSE}

# bootstrapping, but sampling function isn't working

sampler <- function(dat, clustervar, replace = TRUE, reps = 1) {
    cid <- unique(dat[, clustervar[1]])
    ncid <- length(cid)
    recid <- sample(cid, size = ncid * reps, replace = TRUE)
    if (replace) {
        rid <- lapply(seq_along(recid), function(i) {
            cbind(NewID = i, RowID = sample(which(dat[, clustervar] == recid[i]),
                size = length(which(dat[, clustervar] == recid[i])), replace = TRUE))
        })
    } else {
        rid <- lapply(seq_along(recid), function(i) {
            cbind(NewID = i, RowID = which(dat[, clustervar] == recid[i]))
        })
    }
    dat <- as.data.frame(do.call(rbind, rid))
    dat$Replicate <- factor(cut(dat$NewID, breaks = c(1, ncid * 1:reps), include.lowest = TRUE,
        labels = FALSE))
    dat$NewID <- factor(dat$NewID)
    return(dat)
}

set.seed(20)
tmp <- sampler(graphics_avgdeg_incorrect, "Demo.ResponseID", reps = 1000)
bigdata <- cbind(tmp, graphics_avgdeg_incorrect[tmp$RowID, ])

# sampler throws an error:
# "Error in Ops.data.frame(dat[, clustervar], recid[i]) : ‘==’ only defined for equally-sized data frames"

f <- fixef(graph.avgdeg.logit)
r <- getME(graph.avgdeg.logit, "theta")

cl <- makeCluster(4)
clusterExport(cl, c("bigdata", "f", "r"))
clusterEvalQ(cl, require(lme4))

myboot <- function(i) {
    object <- try(glmer(remission ~ IL6 + CRP + CancerStage + LengthofStay +
        Experience + (1 | NewID), data = bigdata, subset = Replicate == i, family = binomial,
        nAGQ = 1, start = list(fixef = f, theta = r)), silent = TRUE)
    if (class(object) == "try-error")
        return(object)
    c(fixef(object), getME(object, "theta"))
}

start <- proc.time()
res <- parLapplyLB(cl, X = levels(bigdata$Replicate), fun = myboot)
end <- proc.time()

# shut down the cluster
stopCluster(cl)

# calculate proportion of models that successfully converged
success <- sapply(res, is.numeric)
mean(success)

# combine successful results
bigres <- do.call(cbind, res[success])

# calculate 2.5th and 97.5th percentiles for 95% CI
(ci <- t(apply(bigres, 1, quantile, probs = c(0.025, 0.975))))

# All results
finaltable <- cbind(Est = c(f, r), SE = c(se, NA), BootMean = rowMeans(bigres),
    ci)
# round and print
round(finaltable, 3)

```

```{r, eval=FALSE}

# temporary data
tmpdat <- graphics_avgdeg_incorrect %>% filter(!is.na(DatasetDuration))

jvalues <- with(graphics_avgdeg_incorrect, seq(from = min(DatasetDuration), to = max(DatasetDuration), length.out = 100))

# calculate predicted probabilities and store in a list
pp <- lapply(jvalues, function(j) {
    tmpdat$LengthofStay <- j
    predict(m, newdata = tmpdat, type = "response")
})


```

```{r, eval=FALSE}

# OLD CODE, NOT MIXED EFFECTS

graphics.est <- graphics_avgdeg %>% mutate(underest = ifelse(RawDifference<0,1,0)) 

graphics.est$underest <- factor(graphics.est$underest, levels=c(1,0), labels = c("underestimated","overestimated"))

graphics.est$Task <- factor(graphics.est$Task)

xtabs(~underest + Task, data = graphics.est)

# difference between family="binomial" and family=binomial(link='logit') ?

#log.model <- glm(underest ~ Task, family=binomial(link='logit'), data=graphics.est)

log.model <- glm(underest ~ Task, family="binomial", data=graphics.est)

summary(log.model)
# Interpretation of Estimate: compared to reference task (AvgDegree), each task changes
# the log odds of underestimation by the estimate shown; negative estimates reduce
# log odds of underestimation compared to AvgDegree

## CIs using profiled log-likelihood
confint(log.model)

## CIs using standard errors
confint.default(log.model)

## Wald test for effect of Task, which is terms 2:8 in the model
wald.test(b = coef(log.model), Sigma = vcov(log.model), Terms = 2:8)

## test two specific tasks against each other (NumHighDegree and NumNodes)
l <- cbind(0,0,0,0,0,1,0,-1)
wald.test(b = coef(log.model), Sigma = vcov(log.model), L = l)
# p = 0.015, so only marginally significant

## odds ratios only
exp(coef(log.model))

## odds ratios and 95% CI
exp(cbind(OR = coef(log.model), confint(log.model)))

# https://stats.idre.ucla.edu/other/mult-pkg/faq/general/faq-how-do-i-interpret-odds-ratios-in-logistic-regression/ 

## testing fit

# likelihood ratio test
with(log.model, pchisq(null.deviance - deviance, df.null - df.residual, lower.tail = FALSE))
# p-value is 0, so model with predictor definitely fits better than the null model

# testing the quality of the variable, is this the best model we can get?

# is this a good fitting model?  check % accuracy; split data into training test, check accuracy on test

anova(log.model, test="Chisq")

pR2(log.model)

# don't know how to interpret; should be looking at McFadden as a sort of pseudo R^2?

# https://stats.idre.ucla.edu/other/mult-pkg/faq/general/faq-what-are-pseudo-r-squareds/
# "If comparing two models on the same data, McFadden’s would be higher for the model with the greater likelihood."

```

#### Negative binomial model for responses

Responses are basically count data, so using a negative binomial distribution to model. Negative binomial is especially useful for over-dispersed data - data where the conditional variances exceed conditional means. 

```{r, eval=FALSE}

# https://stats.idre.ucla.edu/r/dae/negative-binomial-regression/ for non-mixed version

# Test for overdispersion

with(graphics_avgdeg, tapply(Response, Condition, function(x) {
    sprintf("M (SD) = %1.2f (%1.2f)", mean(x), sd(x))
}))

# variances in each condition are much larger than means in the conditions

```

```{r, cache=TRUE, eval=FALSE}



graph.avgdeg.nb.null <- glmer.nb(Response ~ (1|Demo.ResponseID), data=graphics_avgdeg, verbose=TRUE)



graph.avgdeg.nb <- glmer.nb(Response ~ Condition + (1|Demo.ResponseID), data=graphics_avgdeg, verbose=TRUE)

summary(graph.avgdeg.nb)

anova(graph.avgdeg.nb, graph.avgdeg.nb.null)

# model is not significantly different from null model (p=0.4081), so Condition isn't a
# significant predictor

graph.avgdeg.nb.dataset <- glmer.nb(Response ~ Dataset + (1|Demo.ResponseID), data=graphics_avgdeg, verbose=TRUE)

summary(graph.avgdeg.nb.dataset)

anova(graph.avgdeg.nb.dataset, graph.avgdeg.nb.null)

# model is significantly different from null model (p < 2.2e-16), so Dataset is a
# significant predictor

graph.avgdeg.nb <- glmer.nb(Response ~ DatasetOrder + (1|Demo.ResponseID), data=graphics_avgdeg, verbose=TRUE)

summary(graph.avgdeg.nb)

anova(graph.avgdeg.nb, graph.avgdeg.nb.null)

# model is not significantly different from null model (p = 0.2556), so DatasetOrder is not a
# significant predictor

#graph.avgdeg.nb <- glmer.nb(Response ~ DatasetDuration + (1|Demo.ResponseID), data=graphics_avgdeg, verbose=TRUE)

#summary(graph.avgdeg.nb)

#anova(graph.avgdeg.nb, graph.avgdeg.nb.null)

# error trying to run model: 
#"Error in pwrssUpdate(pp, resp, tol = tolPwrss, GQmat = GQmat, compDev = compDev, : pwrssUpdate did not converge in (maxit) iterations"

graph.avgdeg.nb.taskorder <- glmer.nb(Response ~ TaskOrder + (1|Demo.ResponseID), data=graphics_avgdeg, verbose=TRUE)

summary(graph.avgdeg.nb.taskorder)

anova(graph.avgdeg.nb.taskorder, graph.avgdeg.nb.null)

# model is significantly different from null model (p = 0.01659), so TaskOrder is a
# significant predictor

#graph.avgdeg.nb <- glmer.nb(Response ~ QuestionOrder + (1|Demo.ResponseID), data=graphics_avgdeg, verbose=TRUE)

#summary(graph.avgdeg.nb)

#anova(graph.avgdeg.nb, graph.avgdeg.nb.null)

# error trying to run model:
#"Error in pwrssUpdate(pp, resp, tol = tolPwrss, GQmat = GQmat, compDev = compDev, : (maxstephalfit) PIRLS step-halvings failed to reduce deviance in pwrssUpdate"

graph.avgdeg.nb.correct <- glmer.nb(Response ~ CorrectAnswer + (1|Demo.ResponseID), data=graphics_avgdeg, verbose=TRUE)

summary(graph.avgdeg.nb.correct)

anova(graph.avgdeg.nb.correct, graph.avgdeg.nb.null)

# model is significantly different from null model (p < 2.2e-16), so CorrectAnswer is a
# significant predictor

#graph.avgdeg.nb <- glmer.nb(Response ~ Stats.Q_TotalDuration + (1|Demo.ResponseID), data=graphics_avgdeg, verbose=TRUE)

#summary(graph.avgdeg.nb)

#anova(graph.avgdeg.nb, graph.avgdeg.nb.null)

# error trying to run model:
#"Error in pwrssUpdate(pp, resp, tol = tolPwrss, GQmat = GQmat, compDev = compDev, : pwrssUpdate did not converge in (maxit) iterations"

graph.avgdeg.nb <- glmer.nb(Response ~ Stats.OperatingSystem + (1|Demo.ResponseID), data=graphics_avgdeg, verbose=TRUE)

summary(graph.avgdeg.nb)

anova(graph.avgdeg.nb, graph.avgdeg.nb.null)

# model is not significantly different from null model (p = 0.5602), so Stats.OperatingSystems is not a
# significant predictor

#graph.avgdeg.nb <- glmer.nb(Response ~ StatsNumPixels + (1|Demo.ResponseID), data=graphics_avgdeg, verbose=TRUE)

#summary(graph.avgdeg.nb)

#anova(graph.avgdeg.nb, graph.avgdeg.nb.null)

# error trying to run model:
#"Error in pwrssUpdate(pp, resp, tol = tolPwrss, GQmat = GQmat, compDev = compDev, : Downdated VtV is not positive definite"

# TO DO: try to fix errors? try different negative binomial model syntax?

graph.avgdeg.nb <- glmer.nb(Response ~ Demo.age + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!is.na(Demo.age)), verbose=TRUE)

summary(graph.avgdeg.nb)

graph.avgdeg.nb.null.2 <- update(graph.avgdeg.nb, . ~ . - Demo.age)

summary(graph.avgdeg.nb.null.2)

anova(graph.avgdeg.nb, graph.avgdeg.nb.null.2)

# model is not significantly different from null model (p = 0.07795), so Demo.age is not a
# significant predictor
# also, model summary says "Model failed to converge with max|grad| = 0.00119421 (tol = 0.001, component 1)"

# TO DO : keep going with predictors, try combinations of the significant ones? do some prediction to check how good model is?

graph.avgdeg.nb <- glmer.nb(Response ~ Demo.gender + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!is.na(Demo.gender)), verbose=TRUE)

summary(graph.avgdeg.nb)

graph.avgdeg.nb.null.2 <- update(graph.avgdeg.nb, . ~ . - Demo.gender)

summary(graph.avgdeg.nb.null.2)

anova(graph.avgdeg.nb, graph.avgdeg.nb.null.2)

# model is not significantly different from null model (p = 0.7306), so Demo.gender is not a
# significant predictor

graph.avgdeg.nb <- glmer.nb(Response ~ Demo.lang + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!is.na(Demo.lang)), verbose=TRUE)

summary(graph.avgdeg.nb)

graph.avgdeg.nb.null.2 <- update(graph.avgdeg.nb, . ~ . - Demo.lang)

summary(graph.avgdeg.nb.null.2)

anova(graph.avgdeg.nb, graph.avgdeg.nb.null.2)

# null model failed to converge
# "Model failed to converge with max|grad| = 0.0291884 (tol = 0.001, component 1)"

# model is not significantly different from null model (p = 0.1938), so Demo.lang is not a
# significant predictor

graph.avgdeg.nb <- glmer.nb(Response ~ Demo.educ + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!is.na(Demo.educ)), verbose=TRUE)

summary(graph.avgdeg.nb)

graph.avgdeg.nb.null.2 <- update(graph.avgdeg.nb, . ~ . - Demo.educ)

summary(graph.avgdeg.nb.null.2)

anova(graph.avgdeg.nb, graph.avgdeg.nb.null.2)

# null model failed to converge

# model is not significantly different from null model (p = 0.7197), so Demo.educ is not a
# significant predictor

# takes forever, not significant
#graph.avgdeg.nb <- glmer.nb(Response ~ Demo.acfield + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!is.na(Demo.acfield)), verbose=TRUE)

#summary(graph.avgdeg.nb)

# no categories significant

#graph.avgdeg.nb.null.2 <- update(graph.avgdeg.nb, . ~ . - Demo.acfield)

#summary(graph.avgdeg.nb.null.2)

# model failed to converge

#anova(graph.avgdeg.nb, graph.avgdeg.nb.null.2)

# not significant

# TO DO : test acfield group

graph.avgdeg.nb <- glmer.nb(Response ~ Demo.dailytech_Computer + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!is.na(Demo.dailytech_Computer)), verbose=TRUE)

summary(graph.avgdeg.nb)

# not significant

graph.avgdeg.nb.null.2 <- update(graph.avgdeg.nb, . ~ . - Demo.dailytech_Computer)

summary(graph.avgdeg.nb.null.2)

# model failed to converge

anova(graph.avgdeg.nb, graph.avgdeg.nb.null.2)

# not significant

graph.avgdeg.nb <- glmer.nb(Response ~ Demo.dailytech_Tablet + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!is.na(Demo.dailytech_Tablet)), verbose=TRUE)

summary(graph.avgdeg.nb)

# not significant

graph.avgdeg.nb.null.2 <- update(graph.avgdeg.nb, . ~ . - Demo.dailytech_Tablet)

summary(graph.avgdeg.nb.null.2)

anova(graph.avgdeg.nb, graph.avgdeg.nb.null.2)

# not significant

graph.avgdeg.nb.sp <- glmer.nb(Response ~ Demo.dailytech_SmartPhone + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!is.na(Demo.dailytech_SmartPhone)), verbose=TRUE)

summary(graph.avgdeg.nb.sp)

# significant (p = 0.00253)

graph.avgdeg.nb.null.sp <- update(graph.avgdeg.nb.sp, . ~ . - Demo.dailytech_SmartPhone)

summary(graph.avgdeg.nb.null.sp)

# model failed to converge

anova(graph.avgdeg.nb.sp, graph.avgdeg.nb.null.sp)

# significant (p = 0.002548)

graph.avgdeg.nb <- glmer.nb(Response ~ Demo.weeklygaming + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!is.na(Demo.weeklygaming)), verbose=TRUE)

summary(graph.avgdeg.nb)

# not significant

graph.avgdeg.nb.null.2 <- update(graph.avgdeg.nb, . ~ . - Demo.weeklygaming)

summary(graph.avgdeg.nb.null.2)

# model failed to converge

anova(graph.avgdeg.nb, graph.avgdeg.nb.null.2)

# not significant

graph.avgdeg.nb <- glmer.nb(Response ~ Demo.expdataanal + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!is.na(Demo.expdataanal)), verbose=TRUE)

summary(graph.avgdeg.nb)

# not significant

graph.avgdeg.nb.null.2 <- update(graph.avgdeg.nb, . ~ . - Demo.expdataanal)

summary(graph.avgdeg.nb.null.2)

# model failed to converge

anova(graph.avgdeg.nb, graph.avgdeg.nb.null.2)

# not significant

graph.avgdeg.nb <- glmer.nb(Response ~ Demo.expdatavis + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!is.na(Demo.expdatavis)), verbose=TRUE)

summary(graph.avgdeg.nb)

# not significant

graph.avgdeg.nb.null.2 <- update(graph.avgdeg.nb, . ~ . - Demo.expdatavis)

summary(graph.avgdeg.nb.null.2)

# model failed to converge

anova(graph.avgdeg.nb, graph.avgdeg.nb.null.2)

# not significant

graph.avgdeg.nb <- glmer.nb(Response ~ Demo.expreadnetvis + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!is.na(Demo.expreadnetvis)), verbose=TRUE)

summary(graph.avgdeg.nb)

# some categories significant; not sure what the reference category is though!
# TO DO : set reference level to None?

graph.avgdeg.nb.null.2 <- update(graph.avgdeg.nb, . ~ . - Demo.expreadnetvis)

summary(graph.avgdeg.nb.null.2)

# model failed to converge

anova(graph.avgdeg.nb, graph.avgdeg.nb.null.2)

# just over significance (p = 0.06055)

# TO DO : figure out which categories are significant and make some groups to increase
# significance?


graph.avgdeg.nb <- glmer.nb(Response ~ Demo.expcreatenetvis + (1|Demo.ResponseID), data=graphics_avgdeg %>% filter(!is.na(Demo.expcreatenetvis)), verbose=TRUE)

summary(graph.avgdeg.nb)

# one categories significant; not sure what the reference category is though!
# TO DO : set reference level to None?

graph.avgdeg.nb.null.2 <- update(graph.avgdeg.nb, . ~ . - Demo.expcreatenetvis)

summary(graph.avgdeg.nb.null.2)

# model failed to converge

anova(graph.avgdeg.nb, graph.avgdeg.nb.null.2)

# just over significance (p = 0.05901)

# TO DO : figure out which categories are significant and make some groups to increase
# significance?

graph.avgdeg.nb.avgdeg <- glmer.nb(Response ~ AvgDeg + (1|Demo.ResponseID), data=graphics_avgdeg, verbose=TRUE)

summary(graph.avgdeg.nb.avgdeg)

anova(graph.avgdeg.nb.avgdeg, graph.avgdeg.nb.null)

# model is significantly different from null model (p < 2.2e-16), so AvgDeg is a
# significant predictor

graph.avgdeg.nb.density <- glmer.nb(Response ~ Density + (1|Demo.ResponseID), data=graphics_avgdeg, verbose=TRUE)

summary(graph.avgdeg.nb.density)

anova(graph.avgdeg.nb.density, graph.avgdeg.nb.null)

# model is significantly different from null model (p < 2.2e-16), so Density is a
# significant predictor

graph.avgdeg.nb.largeclust <- glmer.nb(Response ~ LargeClust1 + (1|Demo.ResponseID), data=graphics_avgdeg, verbose=TRUE)

summary(graph.avgdeg.nb.largeclust)

anova(graph.avgdeg.nb.largeclust, graph.avgdeg.nb.null)

# model is significantly different from null model (p < 2.2e-16), so LargeClust1 is a
# significant predictor

graph.avgdeg.nb.mod <- glmer.nb(Response ~ Modularity + (1|Demo.ResponseID), data=graphics_avgdeg, verbose=TRUE)

summary(graph.avgdeg.nb.mod)

anova(graph.avgdeg.nb.mod, graph.avgdeg.nb.null)

# model is significantly different from null model (p < 2.2e-16), so Modularity is a
# significant predictor

graph.avgdeg.nb.numclust <- glmer.nb(Response ~ NumClust + (1|Demo.ResponseID), data=graphics_avgdeg, verbose=TRUE)

summary(graph.avgdeg.nb.numclust)

anova(graph.avgdeg.nb.numclust, graph.avgdeg.nb.null)

# model is significantly different from null model (p = 1.174e-12), so NumClust is a
# significant predictor

graph.avgdeg.nb <- glmer.nb(Response ~ NumHighDegree + (1|Demo.ResponseID), data=graphics_avgdeg, verbose=TRUE)

summary(graph.avgdeg.nb)

anova(graph.avgdeg.nb, graph.avgdeg.nb.null)

# model is not significantly different from null model (p = 0.2065), so NumHighDegree is not
# a significant predictor

graph.avgdeg.nb.numlinks <- glmer.nb(Response ~ NumLinks + (1|Demo.ResponseID), data=graphics_avgdeg, verbose=TRUE)

summary(graph.avgdeg.nb.numlinks)

# Error:
# Model failed to converge with max|grad| = 0.0063552 (tol = 0.001, component 1)
# Model is nearly unidentifiable: very large eigenvalue
# - Rescale variables?
# Model is nearly unidentifiable: large eigenvalue ratio
# - Rescale variables?

anova(graph.avgdeg.nb.numlinks, graph.avgdeg.nb.null)

# model is not significantly different from null model (p = 1.875e-06), so NumLinks is 
# a significant predictor

graph.avgdeg.nb.numnodes <- glmer.nb(Response ~ NumNodes + (1|Demo.ResponseID), data=graphics_avgdeg, verbose=TRUE)

summary(graph.avgdeg.nb.numnodes)

# Error:
#  failed to converge with max|grad| = 0.00178473 (tol = 0.001, component 1)
# Model is nearly unidentifiable: very large eigenvalue
#  - Rescale variables?

anova(graph.avgdeg.nb.numnodes, graph.avgdeg.nb.null)

# model is not significantly different from null model (p = 0.0004385), so NumNodes is 
# a significant predictor

graph.avgdeg.nb <- glmer.nb(Response ~ NumNodesClust1 + (1|Demo.ResponseID), data=graphics_avgdeg, verbose=TRUE)

summary(graph.avgdeg.nb)

# Error:
#Model failed to converge with max|grad| = 0.00187437 (tol = 0.001, component 1)
# Model is nearly unidentifiable: very large eigenvalue
# - Rescale variables?

anova(graph.avgdeg.nb, graph.avgdeg.nb.null)

# model is not significantly different from null model (p = 0.4105), so NumNodesClust1 is 
# not a significant predictor

#---------------------------------
# Multiple predictors
#---------------------------------

temp <- graphics_avgdeg %>% drop_na(Response, Dataset, TaskOrder, CorrectAnswer, Demo.dailytech_SmartPhone, AvgDeg, Density, LargeClust1, Modularity, NumClust, NumLinks, NumNodes)

graph.avgdeg.nb.full <- glmer.nb(Response ~ Dataset + TaskOrder + Demo.dailytech_SmartPhone + (1|Demo.ResponseID), 
                            data=temp, verbose=TRUE)

summary(graph.avgdeg.nb.full)
# still significant - Dataset, TaskOrder, SmartPhone

graph.avgdeg.nb.full.2 <- glmer.nb(Response ~ TaskOrder + CorrectAnswer + Demo.dailytech_SmartPhone + LargeClust1 + Modularity + NumNodes + (1|Demo.ResponseID), 
                            data=temp, verbose=TRUE)

summary(graph.avgdeg.nb.full.2)
# still significant: TaskOrder, CorrectAnswer, SmartPhone, LargeClust1, Modularity, NumNodes

# Error:
# Model failed to converge with max|grad| = 0.00841304 (tol = 0.001, component 1)
# Model is nearly unidentifiable: very large eigenvalue
#  - Rescale variables?
# Model is nearly unidentifiable: large eigenvalue ratio
#  - Rescale variables?

anova(graph.avgdeg.nb.full, graph.avgdeg.nb.full.2)
# two models not significantly different

graph.avgdeg.nb.full.3 <- glmer.nb(Response ~ TaskOrder + CorrectAnswer + Demo.dailytech_SmartPhone + LargeClust1 + (1|Demo.ResponseID), 
                            data=temp, verbose=TRUE)

summary(graph.avgdeg.nb.full.3)
# still significant: TaskOrder, CorrectAnswer, SmartPhone, LargeClust1

# Model is nearly unidentifiable: very large eigenvalue
#  - Rescale variables?

anova(graph.avgdeg.nb.full, graph.avgdeg.nb.full.3)

# model is not significantly different from original full model, so probably just keep graph.avgdeg.nb.full

#---------------------------------
# Interactions
#---------------------------------

graph.avgdeg.nb.full.int <- glmer.nb(Response ~ Dataset + 
                                       TaskOrder + Demo.dailytech_SmartPhone + 
                                       Dataset:TaskOrder + 
                                       TaskOrder:Demo.dailytech_SmartPhone + 
                                       Dataset:Demo.dailytech_SmartPhone +
                                       (1|Demo.ResponseID), 
                            data=temp, verbose=TRUE)

summary(graph.avgdeg.nb.full.int)

anova(graph.avgdeg.nb.full, graph.avgdeg.nb.full.int)
# yes, interaction is significantly different from just main effects

# TO DO : check lmer results again after factoring


```

```{r, eval=FALSE}

graph.avgdeg.nb.full.f <- fortify(graph.avgdeg.nb.full)

ggplot(graph.avgdeg.nb.full.f, aes(.fitted,.resid)) + 
  geom_point() +
  geom_hline(yintercept=0)

ggplot(graph.avgdeg.nb.full.f, aes(.fitted,Response)) + 
  geom_point() +
  geom_hline(yintercept=0) +
  scale_y_log10()

ggplot(graph.avgdeg.nb.full.f, aes(.fitted,Response, color=Dataset)) + 
  geom_point() +
  geom_hline(yintercept=0) +
  scale_y_log10()

ggplot(graph.avgdeg.nb.full.f, aes(.fitted,Response)) + 
  geom_point() +
  geom_hline(yintercept=0) +
  scale_y_log10() +
  facet_wrap(~Dataset)

graph.avgdeg.nb.full.int.f <- fortify(graph.avgdeg.nb.full.int)

ggplot(graph.avgdeg.nb.full.int.f, aes(.fitted,.resid)) + 
  geom_point() +
  geom_hline(yintercept=0)

ggplot(graph.avgdeg.nb.full.int.f, aes(.fitted,Response)) + 
  geom_point() +
  geom_hline(yintercept=0) +
  scale_y_log10()


```



```{r, eval=FALSE}

# is negative binomial different from poisson?  if so, indicates over-dispersion is true
# and negative binomial is necessary

graph.avgdeg.pois <- glmer(Response ~ Dataset + 
                                       TaskOrder + Demo.dailytech_SmartPhone + 
                                       Dataset:TaskOrder + 
                                       TaskOrder:Demo.dailytech_SmartPhone + 
                                       Dataset:Demo.dailytech_SmartPhone +
                                       (1|Demo.ResponseID), data=temp, family="poisson")

pchisq(2 * (logLik(graph.avgdeg.nb.full.int) - logLik(graph.avgdeg.pois)), df=1, lower.tail = FALSE)

# value = 0, so keep the negative binomial

```

```{r, eval = FALSE}

# To fit a negative binomial model with known overdispersion parameter (e.g. as part of a model
#comparison exercise), use glmer with the negative.binomial family from the MASS package, e.g.
#glmer(...,family=MASS::negative.binomial(theta=1.75)).

graph.avgdeg.nb2 <- glmer(Response ~ Condition + (1|Demo.ResponseID), data=graphics_avgdeg, family=MASS::negative.binomial(theta=1.75))

graph.avgdeg.nb3 <- glmer(Response ~ Condition + (1|Demo.ResponseID), data=graphics_avgdeg, family=negative.binomial(2))


#graph.avgdeg.nb

summary(graph.avgdeg.nb2)
summary(graph.avgdeg.nb3)

```

```{r, eval=FALSE}
# run without mixed effects to validate

m.glm <- glm.nb(Response ~ Dataset + TaskOrder + Demo.dailytech_SmartPhone + 
                                       Dataset:TaskOrder + 
                                       TaskOrder:Demo.dailytech_SmartPhone + 
                                       Dataset:Demo.dailytech_SmartPhone, data=temp, trace=TRUE)
summary(m.glm)

## The neg.binomial theta parameter:
getME(graph.avgdeg.nb.full.int, "glmer.nb.theta")

#1.567446

## mixed model has 1 additional parameter (RE variance)
stopifnot(attr(logLik(graph.avgdeg.nb.full.int),"df")==attr(logLik(m.glm),"df")+1) # not sure what this does

anova(graph.avgdeg.nb.full.int,m.glm) # can I use anova to compare mixed and fixed effects?
# p < 2.2e-16, so definitely random effects

plot(graph.avgdeg.nb.full.int, resid(.) ~ Response)# works, as long as data 'dd' is found


# TO DO : check if this is all right

```

```{r, eval=FALSE}

par(mfrow=c(2,2))
qqnorm(resid(graph.avgdeg.nb.full.int), main="normal qq-plot, residuals")
qqline(resid(graph.avgdeg.nb.full.int))

qqnorm(ranef(graph.avgdeg.nb.full.int)$Demo.ResponseID[,1])
qqline(ranef(graph.avgdeg.nb.full.int)$Demo.ResponseID[,1])


plot(fitted(graph.avgdeg.nb.full.int), resid(graph.avgdeg.nb.full.int)) #residuals vs fitted
abline(h=0)

#graph.avgdeg.nb2.f <- fortify(graph.avgdeg.nb2)

#ggplot(graph.avgdeg.nb2.f, aes(.fitted,.resid)) + 
#  geom_point() +
#  geom_hline(yintercept=0)

#temp <- graphics_avgdeg

temp$fitted <- fitted(graph.avgdeg.nb.full.int) 
plot(temp$fitted, jitter(temp$Response,0.1)) #fitted vs observed
abline(0,1)

#ggplot(graph.avgdeg.nb2.f, aes(.fitted,Response)) + 
#  geom_point() +
#  geom_abline(aes(slope = 1, intercept = 0))


```

```{r, cache=TRUE, eval=FALSE}

# Confidence Intervals, using coefficients

(est <- cbind(Estimate = coef(graph.avgdeg.nb.full.int), confint(graph.avgdeg.nb.full.int)))

# exponentiate model to look at incident rate ratios instead of coefficients

exp(est)

```

```{r, eval=FALSE}

# predictions

# model: Response ~ Dataset + TaskOrder + Demo.dailytech_SmartPhone + Dataset:TaskOrder + TaskOrder:Demo.dailytech_SmartPhone + Dataset:Demo.dailytech_SmartPhone + (1 | Demo.ResponseID)

newdata1 <- data.frame(Demo.dailytech_SmartPhone = rep(mean(temp$Demo.dailytech_SmartPhone),54), 
                       Dataset = factor(rep(c(1,3,5,7,8,9),9), levels = levels(temp$Dataset),ordered = TRUE),
                       TaskOrder = rep(1:9,6),
                       Demo.ResponseID = sample(temp$Demo.ResponseID,54))
newdata1$phat <- predict(graph.avgdeg.nb.full.int, newdata1, type = "response")
#newdata1

newdata2 <- data.frame(
  Demo.dailytech_SmartPhone = rep(seq(from = min(temp$Demo.dailytech_SmartPhone), to = max(temp$Demo.dailytech_SmartPhone), length.out = 100), 6),
  Dataset = factor(rep(c(1,3,5,7,8,9), each = 100), levels = levels(temp$Dataset),ordered = TRUE),
  TaskOrder = rep(1:9,len=600),
  Demo.ResponseID = sample(temp$Demo.ResponseID,600)
  )

#predict(graph.avgdeg.nb.full.int, newdata2, type = "link", se.fit=TRUE)
newdata2 <- cbind(newdata2, predict(graph.avgdeg.nb.full.int, newdata2, type = "link", se.fit=TRUE))

# not sure about this; asking for "fit", but that's not recognized. should the new column be called "fit"? what about se.fit?

#newdata2 <- within(newdata2, {
#  Response <- exp(fit)
#  LL <- exp(fit - 1.96 * se.fit)
#  UL <- exp(fit + 1.96 * se.fit)
#})

#ggplot(newdata2, aes(math, DaysAbsent)) +
#  geom_ribbon(aes(ymin = LL, ymax = UL, fill = prog), alpha = .25) +
#  geom_line(aes(colour = prog), size = 2) +
#  labs(x = "Math Score", y = "Predicted Days Absent")

# note on negative binomial:

# TO DO : If the data generating process does not allow for any 0s (such as the number of days spent in the hospital), then a zero-truncated model may be more appropriate.

# TO DO : Count data often have an exposure variable, which indicates the number of times the event could have happened (i.e. a max). This variable should be incorporated into your negative binomial regression model with the use of the offset option. See the glm documentation for details.  (so, that would make sense for click data???)

# other info:
# Cameron, A. C. and Trivedi, P. K. 1998. Regression Analysis of Count Data. New York: Cambridge Press.
# Dupont, W. D. 2002. Statistical Modeling for Biomedical Researchers: A Simple Introduction to the Analysis of Complex Data. New York: Cambridge Press.

```

#### brms/tidybayes

```{r, eval=FALSE}

# graph.avgdeg.lmer.full <- lmer(LogError ~ Underestimated + Demo.dailytech_SmartPhone + (1|Demo.ResponseID), data=temp, REML = T)

#library(rstan)

theme_set(theme_grey())

#avgd.fit <- brm(LogError~Underestimated + Demo.dailytech_SmartPhone + (1|Demo.ResponseID), data = temp, REML=T)
avgd.fit <- brm(LogError~Underestimated + Demo.dailytech_SmartPhone + (1|Demo.ResponseID), data = temp)

summary(avgd.fit, waic = TRUE) 

#plot(avgd.fit)

avgd.fit$formula

#avgd.fit %<>% recover_types(temp)

#tidybayes::parameters(avgd.fit)


```

```{r}

#plot(fit, ask=FALSE) 
#plot(marginal_effects(fit, probs = c(0.05, 0.95)),points=TRUE, ask=FALSE)
#plot(marginal_effects(fit, probs = c(0.05, 0.95)),ask=FALSE)
plot(marginal_effects(avgd.fit, effects="Underestimated", probs = c(0.05, 0.95)),ask=FALSE)

```


```{r}

# all pairs

avgd.hyp <- c("Underestimatedunder = 0")

(avgd.hyp.res <- hypothesis(avgd.fit, avgd.hyp))

#plot(avgd.hyp.res, chars = NULL, ask=FALSE)

avgd.hyp.res.df <- avgd.hyp.res$hypothesis

avgd.hyp.res.df$contrast <- c("under-over")

avgd.hyp.res.df$contrast <- factor(avgd.hyp.res.df$contrast,
                                    levels=avgd.hyp.res.df %>% arrange(desc(Estimate)) %>%
                                      dplyr::select(contrast) %>% unlist())

ggplot(avgd.hyp.res.df, aes(contrast,Estimate)) + 
  geom_errorbar(aes(ymin=`l-95% CI`,ymax=`u-95% CI`)) +
  geom_point(aes(fill=Star=="*"), size=7, shape=21) +
  #geom_hline(yintercept = 0) +
  scale_fill_manual(values=star.colors,name="Outside 95% CI") +
  coord_flip()

```

```{r}

hyp.pairs.2.res.df <- hyp.pairs.2.res.df %>% separate(contrast, c("From", "To"), sep="[-]", remove=FALSE)

copy <- hyp.pairs.2.res.df %>% rename(From=To,To=From) %>% 
  mutate(Estimate=-Estimate,
         `l-95% CI`=-`l-95% CI`,
         `u-95% CI`=-`u-95% CI`)

pairs.compl <- bind_rows(hyp.pairs.2.res.df, copy)


#cond.lev <- c("Ctrl","Phr","Col","Siz")

#graph.numnodes.emm.conddata.pairs.compl$From <- factor(graph.numnodes.emm.conddata.pairs.compl$From, levels=cond.lev)
#graph.numnodes.emm.conddata.pairs.compl$To <- factor(graph.numnodes.emm.conddata.pairs.compl$To, levels=cond.lev)

pairs.compl$From <- factor(pairs.compl$From, levels=c(9,8,7,5,3,1))
pairs.compl$To <- factor(pairs.compl$To, levels=c(1,3,5,7,8,9))

#graph.numlinks.emm.conddata.pairs.compl %>% arrange(desc(estimate))
pairs.compl %>% arrange(Estimate)

# can't get color to go the right direction
ggplot(pairs.compl %>% filter(Estimate >= 0)) +
  geom_tile(aes(x=To,y=From,fill=Estimate), color="black") +
  scale_fill_distiller(palette="Greys", direction=1) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(Estimate),fill=Star=="*"),shape=21, color="black") +
  scale_fill_manual(values=star.colors, name="Outside 95% CI") +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=Estimate)) +
  scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(Estimate),fill=Estimate, color=Star=="*"), shape=21,stroke=1) +
  scale_fill_distiller(type="div", palette=4, limits=c(-max(abs(pairs.compl$Estimate)),max(abs(pairs.compl$Estimate)))) +
  scale_color_manual(values=c("grey90","black"), name="Outside 95% CI") +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

hyp.pairs.2.res.df$From <- factor(hyp.pairs.2.res.df$From, levels=c(9,8,7,5,3,1))
hyp.pairs.2.res.df$To <- factor(hyp.pairs.2.res.df$To, levels=c(1,3,5,7,8,9))


ggplot(hyp.pairs.2.res.df) +
  geom_count(aes(x=To,y=From,size=abs(Estimate),fill=Estimate, color=Star=="*"), shape=21,stroke=1) +
  scale_fill_distiller(type="div", palette=4, limits=c(-max(abs(pairs.compl$Estimate)),max(abs(pairs.compl$Estimate)))) +
  scale_color_manual(values=c("grey90","black"), name="Outside 95% CI") +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")




```


#### Least Squares Means-numlinks

Do for each categorical predictor. 
Final model: LogError ~ Underestimated + Demo.dailytech_SmartPhone + (1 | Demo.ResponseID)

##### Underestimated

###### emmeans

```{r}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numhighdeg, table(Dataset,Overestimated))
# ref_grid(graph.numhd.lmer.full.int.4) @ grid; .wgt. is number of observations

graph.avgdeg.emm.under <- emmeans(graph.avgdeg.lmer.full, "Underestimated", nesting = NULL)
#graph.numhd.emm.condition <- emmeans(graph.numhd.lmer.full.int.4, "Condition", lmer.df = "satterthwaite")

graph.avgdeg.emm.under

graph.avgdeg.emm.under.df <- dplyr::as_data_frame(graph.avgdeg.emm.under)

graph.avgdeg.emm.under.df


# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numhd.emm.condition)

graph.avgdeg.emm.under.cld <- cld(graph.avgdeg.emm.under,
                details=TRUE,
                #alpha=0.01,
                #by="Dataset",
                #Letters="|||||||||||||||||||",
                sort=TRUE
)

graph.avgdeg.emm.under.cld.df <- graph.avgdeg.emm.under.cld$emmeans

graph.avgdeg.emm.under.cld.df %>% dplyr::select(Underestimated,.group)

graph.avgdeg.emm.under.cld.df

graph.avgdeg.emm.under.cld.df$Underestimated <- factor(graph.avgdeg.emm.under.cld.df$Underestimated, levels=graph.avgdeg.emm.under.cld.df %>% arrange(desc(emmean)) %>% dplyr::select(Underestimated) %>% unlist())


#emmip(graph.numlinks.lmer.full.int, ~Condition, CIs = TRUE)
emmip(graph.avgdeg.emm.under, ~Underestimated, CIs = TRUE)
plot(graph.avgdeg.emm.under)
#plot(graph.numlinks.emm.cond, comparisons = TRUE)

graph.avgdeg.emm.under.cld.df %>% arrange(desc(emmean))

ggplot(graph.avgdeg.emm.under.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Underestimated,ymax=upper.CL,ymin=lower.CL), width=.2) +
  geom_point(aes(x=Underestimated,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()


#plot(ref_grid(graph.numnodes.lmer.int.3), by="Condition") 
# try to figure this out? maybe only works on the interaction?
```

```{r}

graph.avgdeg.emm.under.pairs <- dplyr::as_data_frame(pairs(graph.avgdeg.emm.under)) 
graph.avgdeg.emm.under.pairs
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

pairs.CI <- confint(pairs(graph.avgdeg.emm.under))

graph.avgdeg.emm.under.pairs <- full_join(graph.avgdeg.emm.under.pairs, pairs.CI)

#graph.numhd.diffemm.condition <- emmeans(graph.numhd.lmer.full.int.4, pairwise ~ Condition)
#graph.numhd.diffemm.condition$contrasts
#contrast(graph.numhd.emm.condition)
#confint(graph.numhd.emm.condition)
#pairs(graph.numhd.emm.condition, details=TRUE)
#confint(contrast(graph.numhd.emm.condition))
#confint(pairs(graph.numhd.emm.condition))
#coef(pairs(graph.numhd.emm.condition))


plot(pairs(graph.avgdeg.emm.under))
plot(pairs(graph.avgdeg.emm.under), comparisons = TRUE)

graph.avgdeg.emm.under.pairs$sig.levels <- 
  case_when(graph.avgdeg.emm.under.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.avgdeg.emm.under.pairs$p.value < .001 ~ sig.level.names[2],
            graph.avgdeg.emm.under.pairs$p.value < .01 ~ sig.level.names[3],
            graph.avgdeg.emm.under.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.avgdeg.emm.under.pairs$sig.levels <- factor(graph.avgdeg.emm.under.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)


graph.avgdeg.emm.under.pairs$contrast <- factor(graph.avgdeg.emm.under.pairs$contrast, levels=graph.avgdeg.emm.under.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())

graph.avgdeg.emm.under.pairs <- graph.avgdeg.emm.under.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.avgdeg.emm.under.pairs %>% arrange(estimate)

ggplot(graph.avgdeg.emm.under.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.avgdeg.emm.under.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

```

```{r}

copy <- graph.avgdeg.emm.under.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         t.ratio=-t.ratio,
         lower.CL=-lower.CL,
         upper.CL=-upper.CL)

graph.avgdeg.emm.under.pairs.compl <- bind_rows(graph.avgdeg.emm.under.pairs, copy)

#cond.lev <- c("Ctrl","Phr","Col","Siz")

graph.avgdeg.emm.under.pairs.compl$From <- factor(graph.avgdeg.emm.under.pairs.compl$From, levels=rev(unique(graph.avgdeg.emm.under.pairs.compl$From)))
#graph.avgdeg.emm.under.pairs.compl$To <- factor(graph.avgdeg.emm.under.pairs.compl$To, levels=cond.lev)

#graph.numlinks.emm.cond.pairs.compl %>% arrange(desc(estimate))
graph.avgdeg.emm.under.pairs.compl %>% arrange(estimate)

ggplot(graph.avgdeg.emm.under.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.avgdeg.emm.under.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.avgdeg.emm.under.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
    scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.avgdeg.emm.under.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")


```

###### networks

```{r, eval=FALSE}

# try a network of the pairwise significance values?  bleh...
# using igraph

graph <- graph_from_data_frame(graph.avgdeg.emm.under.pairs %>% dplyr::select(-contrast), directed=TRUE)

E(graph)$width <- abs(E(graph)$estimate)*50
E(graph)$edge.color <- sig.colors[E(graph)$sig.levels]

graph

plot(graph, 
     edge.arrow.size=.5,
     vertex.frame.color="#555555")

```

```{r, eval=FALSE}

# using ggraph and tidygraph

graph <- graph_from_data_frame(graph.avgdeg.emm.under.pairs %>% dplyr::select(-contrast), directed=TRUE)

# plot using ggraph
ggraph(graph, layout = 'kk') +
  geom_edge_link(aes(start_cap = label_rect(node1.name),
                       end_cap = label_rect(node2.name),
                     color=factor(sig.level.names[sig.levels]),
                     edge_width=.5/sig.levels
                     ), 
                   arrow = arrow(length = unit(4, 'mm')))+
  geom_node_text(label = vertex_attr(graph,"name")) +
  scale_edge_color_manual("Significance Levels", values=sig.colors) +
  scale_edge_width_continuous(labels=rev(sig.level.names)) +
  theme_graph()

```




##### Demo.dailytech_SmartPhone - not a factor

###### emmeans

```{r, eval=FALSE}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numhighdeg, table(Dataset,Overestimated))
# ref_grid(graph.numhd.lmer.full.int.4) @ grid; .wgt. is number of observations

graph.avgdeg.emm.SP <- emmeans(graph.avgdeg.lmer.full, "Demo.dailytech_SmartPhone", nesting = NULL)
#graph.numhd.emm.condition <- emmeans(graph.numhd.lmer.full.int.4, "Condition", lmer.df = "satterthwaite")

graph.avgdeg.emm.SP

graph.avgdeg.emm.SP.df <- dplyr::as_data_frame(graph.avgdeg.emm.SP)

graph.avgdeg.emm.SP.df


# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numhd.emm.condition)

graph.avgdeg.emm.SP.cld <- cld(graph.avgdeg.emm.SP,
                details=TRUE,
                #alpha=0.01,
                #by="Dataset",
                #Letters="|||||||||||||||||||",
                sort=TRUE
)

graph.avgdeg.emm.SP.cld.df <- graph.avgdeg.emm.SP.cld$emmeans

graph.avgdeg.emm.SP.cld.df %>% dplyr::select(Demo.dailytech_SmartPhone,.group)

graph.avgdeg.emm.SP.cld.df

graph.avgdeg.emm.SP.cld.df$Demo.dailytech_SmartPhone <- factor(graph.avgdeg.emm.SP.cld.df$Demo.dailytech_SmartPhone, levels=graph.avgdeg.emm.SP.cld.df %>% arrange(desc(emmean)) %>% dplyr::select(Demo.dailytech_SmartPhone) %>% unlist())


#emmip(graph.numlinks.lmer.full.int, ~Condition, CIs = TRUE)
emmip(graph.avgdeg.emm.SP, ~Demo.dailytech_SmartPhone, CIs = TRUE)
plot(graph.avgdeg.emm.SP)
#plot(graph.numlinks.emm.cond, comparisons = TRUE)

graph.avgdeg.emm.SP.cld.df %>% arrange(desc(emmean))

ggplot(graph.avgdeg.emm.SP.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Demo.dailytech_SmartPhone,ymax=upper.CL,ymin=lower.CL), width=.2) +
  geom_point(aes(x=Demo.dailytech_SmartPhone,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()


#plot(ref_grid(graph.numnodes.lmer.int.3), by="Condition") 
# try to figure this out? maybe only works on the interaction?
```

```{r, eval=FALSE}

graph.numlinks.emm.data.pairs <- dplyr::as_data_frame(pairs(graph.numlinks.emm.data)) 
graph.numlinks.emm.data.pairs
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

pairs.CI <- confint(pairs(graph.numlinks.emm.data))

graph.numlinks.emm.data.pairs <- full_join(graph.numlinks.emm.data.pairs, pairs.CI)

#graph.numhd.diffemm.condition <- emmeans(graph.numhd.lmer.full.int.4, pairwise ~ Condition)
#graph.numhd.diffemm.condition$contrasts
#contrast(graph.numhd.emm.condition)
#confint(graph.numhd.emm.condition)
#pairs(graph.numhd.emm.condition, details=TRUE)
#confint(contrast(graph.numhd.emm.condition))
#confint(pairs(graph.numhd.emm.condition))
#coef(pairs(graph.numhd.emm.condition))


plot(pairs(graph.numlinks.emm.data))
plot(pairs(graph.numlinks.emm.data), comparisons = TRUE)

graph.numlinks.emm.data.pairs$sig.levels <- 
  case_when(graph.numlinks.emm.data.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.numlinks.emm.data.pairs$p.value < .001 ~ sig.level.names[2],
            graph.numlinks.emm.data.pairs$p.value < .01 ~ sig.level.names[3],
            graph.numlinks.emm.data.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.numlinks.emm.data.pairs$sig.levels <- factor(graph.numlinks.emm.data.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)


graph.numlinks.emm.data.pairs$contrast <- factor(graph.numlinks.emm.data.pairs$contrast, levels=graph.numlinks.emm.data.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())

graph.numlinks.emm.data.pairs <- graph.numlinks.emm.data.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.numlinks.emm.data.pairs %>% arrange(estimate)

ggplot(graph.numlinks.emm.data.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.numlinks.emm.data.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

```

```{r, eval=FALSE}

data.copy <- graph.numlinks.emm.data.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         t.ratio=-t.ratio,
         lower.CL=-lower.CL,
         upper.CL=-upper.CL)

graph.numlinks.emm.data.pairs.compl <- bind_rows(graph.numlinks.emm.data.pairs, data.copy)


#cond.lev <- c("Ctrl","Phr","Col","Siz")

#graph.numlinks.emm.data.pairs.compl$From <- factor(graph.numlinks.emm.data.pairs.compl$From, levels=cond.lev)
#graph.numlinks.emm.data.pairs.compl$To <- factor(graph.numlinks.emm.data.pairs.compl$To, levels=cond.lev)

graph.numlinks.emm.data.pairs.compl$From <- factor(graph.numlinks.emm.data.pairs.compl$From, levels=rev(unique(graph.numlinks.emm.data.pairs.compl$From)))

#graph.numlinks.emm.cond.pairs.compl %>% arrange(desc(estimate))
graph.numlinks.emm.data.pairs.compl %>% arrange(estimate)

ggplot(graph.numlinks.emm.data.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numlinks.emm.data.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numlinks.emm.data.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
    scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numlinks.emm.data.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")


```

### Betweenness Centrality

```{r}


```

#### Negative binomial model for click questions Node Rank

Ranks are like count data, in that they are nonnegative integers, so using a negative binomial distribution to model. Negative binomial is especially useful for over-dispersed data - data where the conditional variances exceed conditional means. 

```{r}

# https://stats.idre.ucla.edu/r/dae/negative-binomial-regression/ for non-mixed version

# Test for overdispersion

with(graphics_bc, tapply(NodeRank, Condition, function(x) {
    sprintf("M (SD) = %1.2f (%1.2f)", mean(x), sd(x))
}))

# variances in each condition (except Size) are larger than means in the conditions

```

```{r, cache=TRUE, eval=FALSE}

# negative binomial models - no offset, first single fixed effects, then multiple, then interactions

graph.bc.nb.null <- glmer.nb(NodeRank ~ (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE)

# Model failed to converge with max|grad| = 0.040352 (tol = 0.001, component 1) --> dev.= -2*logLik(.) = 5486.616 

graph.bc.nb.null <- glmer.nb(NodeRank ~ (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE, control=glmerControl(optimizer = "nlminbw"))

graph.bc.nb <- glmer.nb(NodeRank ~ Condition + (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE)

summary(graph.bc.nb)

anova(graph.bc.nb, graph.bc.nb.null)

# model is not significantly different from null model (p=0.232), so Condition isn't a
# significant predictor

graph.bc.nb <- glmer.nb(NodeRank ~ factor(Ctrl_dummy) + (1|Demo.ResponseID), 
                        data=graphics_bc, verbose=TRUE, control=glmerControl(optimizer = "nlminbw"))

summary(graph.bc.nb)

anova(graph.bc.nb, graph.bc.nb.null)

# Ctrl_dummy is not significant

graph.bc.nb <- glmer.nb(NodeRank ~ ConditionPhrasing + (1|Demo.ResponseID), 
                        data=graphics_bc, verbose=TRUE)

summary(graph.bc.nb)

anova(graph.bc.nb, graph.bc.nb.null)

# ConditionPhrasing is not significant

graph.bc.nb <- glmer.nb(NodeRank ~ ConditionGraphics + (1|Demo.ResponseID), 
                        data=graphics_bc, verbose=TRUE)

summary(graph.bc.nb)

anova(graph.bc.nb, graph.bc.nb.null)

# ConditionPhrasing is not significant


#graph.bc.nb.dataset <- glmer.nb(NodeRank ~ Dataset + (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE)

# model failed to converge

graph.bc.nb.dataset <- glmer.nb(NodeRank ~ Dataset + (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE, control=glmerControl(optimizer = "nlminbw"))

summary(graph.bc.nb.dataset)

anova(graph.bc.nb.dataset, graph.bc.nb.null)

# model is significantly different from null model (p < 2.2e-16)

#graph.bc.nb.dataOrder <- glmer.nb(NodeRank ~ DatasetOrder + (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE)

# model failed to converge

graph.bc.nb.dataOrder <- glmer.nb(NodeRank ~ DatasetOrder + (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE, control=glmerControl(optimizer = "bobyqa"))

summary(graph.bc.nb.dataOrder)

anova(graph.bc.nb.dataOrder, graph.bc.nb.null)

# model is significantly different from null model (p = 0.005009)

#graph.bc.nb <- glmer.nb(NodeRank ~ DatasetDuration + (1|Demo.ResponseID), data=graphics_bc %>% filter(!is.na(DatasetDuration)), verbose=TRUE)

# major error: PIRLS step-halvings failed to reduce deviance in pwrssUpdate; rescale data

graphics_bc.CS <- graphics_bc %>% mutate(DatasetDuration=scale(DatasetDuration))

graph.bc.nb <- glmer.nb(NodeRank ~ DatasetDuration + (1|Demo.ResponseID), 
                        data=graphics_bc.CS %>% filter(!is.na(DatasetDuration)), verbose=TRUE)

# get an error about model convergence; trying suggestions from lme4 documentation

# try fitting with all optimizers; if all converge to about the same values, convergence warning can be ignored

#source(system.file("utils", "allFit.R", package="lme4"))

#graph.bc.nb.all <- allFit(graph.bc.nb)
#ss <- summary(graph.bc.nb.all)
#ss$fixef
#ss$llik
#ss$sdcor
#ss$theta
#ss$which.OK

# or can restart fit from apparent optimum
#graph.bc.nb.restart <- update(graph.bc.nb, start=pars)
#summary(graph.bc.nb.restart)

# trying just manually changing optimizer

graph.bc.nb <- glmer.nb(NodeRank ~ DatasetDuration + (1|Demo.ResponseID), 
                        data=graphics_bc.CS %>% filter(!is.na(DatasetDuration)), verbose=TRUE, 
                        control=glmerControl(optimizer = "nlminbw"))

#seems okay; don't see any errors

summary(graph.bc.nb)

graph.bc.nb.null2 <- glmer.nb(NodeRank ~ (1|Demo.ResponseID), data=graphics_bc.CS %>% filter(!is.na(DatasetDuration)), verbose=TRUE, control=glmerControl(optimizer = "nlminbw"))

anova(graph.bc.nb, graph.bc.nb.null2)

# DatasetDuration is not significant 

#graph.bc.nb.taskorder <- glmer.nb(NodeRank ~ TaskOrder + (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE)

# failed to converge

graph.bc.nb <- glmer.nb(NodeRank ~ TaskOrder + (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE, control=glmerControl(optimizer = "Nelder_Mead"))

# still have a failed to converge warning, but results seem similar with different optimizers

summary(graph.bc.nb)

anova(graph.bc.nb, graph.bc.nb.null)

# TaskOrder is not significant

#graph.bc.nb <- glmer.nb(NodeRank ~ QuestionOrder + (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE)

# warnings about rescaling variables

graphics_bc.CS <- graphics_bc %>% mutate(QuestionOrder=scale(QuestionOrder))

graph.bc.nb <- glmer.nb(NodeRank ~ QuestionOrder + (1|Demo.ResponseID), 
                        data=graphics_bc.CS, verbose=TRUE, control=glmerControl(optimizer = "nlminbw"))

summary(graph.bc.nb)

graph.bc.nb.null2 <- glmer.nb(NodeRank ~ (1|Demo.ResponseID), data=graphics_bc.CS, verbose=TRUE, control=glmerControl(optimizer = "nlminbw"))

anova(graph.bc.nb, graph.bc.nb.null2)

# QuestionOrder is not significant


#graph.bc.nb <- glmer.nb(NodeRank ~ CorrectAnswer + (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE)

# error about rescaling

graphics_bc.CS <- graphics_bc %>% mutate(CorrectAnswer=scale(CorrectAnswer))

graph.bc.nb.correct <- glmer.nb(NodeRank ~ CorrectAnswer + (1|Demo.ResponseID), 
                        data=graphics_bc.CS, verbose=TRUE)

summary(graph.bc.nb.correct)

graph.bc.nb.null2 <- glmer.nb(NodeRank ~ (1|Demo.ResponseID), data=graphics_bc.CS, verbose=TRUE, control=glmerControl(optimizer = "nlminbw"))

anova(graph.bc.nb.correct, graph.bc.nb.null2)

# CorrectAnswer is significant (p=9.358e-09)

#graph.bc.nb <- glmer.nb(NodeRank ~ Stats.Q_TotalDuration + (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE)

# warnings about rescaling variables

graphics_bc.CS <- graphics_bc %>% mutate(Stats.Q_TotalDuration=scale(Stats.Q_TotalDuration))

graph.bc.nb.totdur <- glmer.nb(NodeRank ~ Stats.Q_TotalDuration + (1|Demo.ResponseID), data=graphics_bc.CS, verbose=TRUE, control=glmerControl(optimizer = "nlminbw"))

summary(graph.bc.nb.totdur)

graph.bc.nb.null2 <- glmer.nb(NodeRank ~ (1|Demo.ResponseID), data=graphics_bc.CS, verbose=TRUE, control=glmerControl(optimizer = "nlminbw"))

anova(graph.bc.nb.totdur, graph.bc.nb.null2)

# Stats.Q_TotalDuration is significant (p=0.003248)


graph.bc.nb <- glmer.nb(NodeRank ~ Stats.OperatingSystem + (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE, control=glmerControl(optimizer = "bobyqa"))
# very slooooooow, but no errors

summary(graph.bc.nb) # nothing significant

anova(graph.bc.nb, graph.bc.nb.null)

# Stats.OperatingSystems is not significant

graph.bc.nb <- glmer.nb(NodeRank ~ Stats.OperatingSystemCombined + (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE, control=glmerControl(optimizer = "bobyqa"))

summary(graph.bc.nb) # iPhone significantly different from Android

anova(graph.bc.nb, graph.bc.nb.null)

# Stats.OperatingSystemCombined is not significant

graph.bc.nb <- glmer.nb(NodeRank ~ Stats.OperatingSystemCombined2 + (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE, control=glmerControl(optimizer = "bobyqa"))

summary(graph.bc.nb)

anova(graph.bc.nb, graph.bc.nb.null)

# Stats.OperatingSystemCombined2 is not significant

graph.bc.nb <- glmer.nb(NodeRank ~ Stats.OperatingSystemCombined3 + (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE, control=glmerControl(optimizer = "bobyqa"))

summary(graph.bc.nb)

anova(graph.bc.nb, graph.bc.nb.null)

# Stats.OperatingSystemCombined3 is not significant

graph.bc.nb <- glmer.nb(NodeRank ~ Stats.OperatingSystemCombined4 + (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE, control=glmerControl(optimizer = "bobyqa"))

summary(graph.bc.nb)

anova(graph.bc.nb, graph.bc.nb.null)

# Stats.OperatingSystemCombined4 is not significant

graph.bc.nb <- glmer.nb(NodeRank ~ Stats.OperatingSystemCombined5 + (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE, control=glmerControl(optimizer = "bobyqa"))

summary(graph.bc.nb)

anova(graph.bc.nb, graph.bc.nb.null)

# Stats.OperatingSystemCombined5 is not significant

graph.bc.nb <- glmer.nb(NodeRank ~ Stats.OperatingSystemWindows + (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE, control=glmerControl(optimizer = "bobyqa"))

summary(graph.bc.nb)

anova(graph.bc.nb, graph.bc.nb.null)

# Stats.OperatingSystemWindows is not significant

graph.bc.nb <- glmer.nb(NodeRank ~ Stats.OperatingSystemMacintosh + (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE, control=glmerControl(optimizer = "bobyqa"))

summary(graph.bc.nb)

anova(graph.bc.nb, graph.bc.nb.null)

# Stats.OperatingSystemMacintosh is not significant

graph.bc.nb <- glmer.nb(NodeRank ~ Stats.OperatingSystemAndroid + (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE, control=glmerControl(optimizer = "bobyqa"))

summary(graph.bc.nb)

anova(graph.bc.nb, graph.bc.nb.null)

# Stats.OperatingSystemAndroid is not significant

graph.bc.nb <- glmer.nb(NodeRank ~ Stats.OperatingSystemiPhone + (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE, control=glmerControl(optimizer = "bobyqa"))

summary(graph.bc.nb)

anova(graph.bc.nb, graph.bc.nb.null)

# Stats.OperatingSystemiPhone is not significant


#graph.bc.nb <- glmer.nb(NodeRank ~ StatsNumPixels + (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE)

# need to rescale

graphics_bc.CS <- graphics_bc %>% mutate(StatsNumPixels=scale(StatsNumPixels))

graph.bc.nb <- glmer.nb(NodeRank ~ StatsNumPixels + (1|Demo.ResponseID), 
                        data=graphics_bc.CS, verbose=TRUE, 
                        control=glmerControl(optimizer = "nlminbw"))

summary(graph.bc.nb)

graph.bc.nb.null2 <- glmer.nb(NodeRank ~ (1|Demo.ResponseID), data=graphics_bc.CS, verbose=TRUE, control=glmerControl(optimizer = "nlminbw"))

anova(graph.bc.nb, graph.bc.nb.null2)

# StatsNumPixels not significant

#graph.bc.nb <- glmer.nb(NodeRank ~ Demo.age + (1|Demo.ResponseID), data=graphics_bc %>% filter(!is.na(Demo.age)), verbose=TRUE)

# need to rescale

graphics_bc.CS <- graphics_bc %>% mutate(Demo.age=scale(Demo.age))

graph.bc.nb <- glmer.nb(NodeRank ~ Demo.age + (1|Demo.ResponseID), 
                        data=graphics_bc.CS %>% filter(!is.na(Demo.age)), verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))


summary(graph.bc.nb)

graph.bc.nb.null2 <- glmer.nb(NodeRank ~ (1|Demo.ResponseID), 
                        data=graphics_bc.CS %>% filter(!is.na(Demo.age)), verbose=TRUE, 
                        control=glmerControl(optimizer = "nlminbw"))

anova(graph.bc.nb, graph.bc.nb.null2)

# Demo.age is not significant

graph.bc.nb <- glmer.nb(NodeRank ~ Demo.gender + (1|Demo.ResponseID), 
                        data=graphics_bc %>% filter(!is.na(Demo.gender)), verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))

summary(graph.bc.nb)

graph.bc.nb.null.2 <- update(graph.bc.nb, . ~ . - Demo.gender)

summary(graph.bc.nb.null.2)

anova(graph.bc.nb, graph.bc.nb.null.2)

# Demo.gender is not significant (p=0.09937)

graph.bc.nb <- glmer.nb(NodeRank ~ Demo.lang + (1|Demo.ResponseID), 
                        data=graphics_bc %>% filter(!is.na(Demo.lang)), verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))

summary(graph.bc.nb)

graph.bc.nb.null.2 <- update(graph.bc.nb, . ~ . - Demo.lang)

summary(graph.bc.nb.null.2)

anova(graph.bc.nb, graph.bc.nb.null.2)

# Demo.lang is not a significant predictor

graph.bc.nb <- glmer.nb(NodeRank ~ Demo.educ + (1|Demo.ResponseID), 
                        data=graphics_bc %>% filter(!is.na(Demo.educ)), verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))

summary(graph.bc.nb)

graph.bc.nb.null.2 <- update(graph.bc.nb, . ~ . - Demo.educ)

anova(graph.bc.nb, graph.bc.nb.null.2)

# Demo.educ is not significant

graph.bc.nb <- glmer.nb(NodeRank ~ Demo.acfield + (1|Demo.ResponseID), 
                        data=graphics_bc %>% filter(!is.na(Demo.acfield)), verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))

summary(graph.bc.nb)

# several categories significantly different from Anthropology:
# Architecture and design, Arts, Business, Earth sciences, Information science, Library and museum studies, Other, Political science
# marginal: Computer sciences, History, Languages, Psychology, Skipped, Sociology

graph.bc.nb.null.2 <- update(graph.bc.nb, . ~ . - Demo.acfield)

anova(graph.bc.nb, graph.bc.nb.null.2)

# almost significant (p=0.07284)

graph.bc.nb <- glmer.nb(NodeRank ~ Demo.acfieldGrouped + (1|Demo.ResponseID), 
                        data=graphics_bc %>% filter(!is.na(Demo.acfieldGrouped)), verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))

graph.bc.nb.null.2 <- update(graph.bc.nb, . ~ . - Demo.acfieldGrouped)

anova(graph.bc.nb, graph.bc.nb.null.2)

# Demo.acfieldGrouped is not significant

graph.bc.nb.acfield2 <- glmer.nb(NodeRank ~ Demo.acfieldGrouped2 + (1|Demo.ResponseID), 
                        data=graphics_bc %>% filter(!is.na(Demo.acfieldGrouped2)), verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))

graph.bc.nb.null.2 <- update(graph.bc.nb.acfield2, . ~ . - Demo.acfieldGrouped2)

anova(graph.bc.nb.acfield2, graph.bc.nb.null.2)

# Demo.acfieldGrouped2 (actually set up because of results of bc.lmer model) is 
# significant (p=2.861e-05)

graph.bc.nb <- glmer.nb(NodeRank ~ Demo.dailytech_Computer + (1|Demo.ResponseID), 
                        data=graphics_bc %>% filter(!is.na(Demo.dailytech_Computer)), verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))

summary(graph.bc.nb)

# almost significant

graph.bc.nb.null.2 <- update(graph.bc.nb, . ~ . - Demo.dailytech_Computer)

anova(graph.bc.nb, graph.bc.nb.null.2)

# almost significant (p=0.06008)

graph.bc.nb <- glmer.nb(NodeRank ~ Demo.dailytech_Tablet + (1|Demo.ResponseID), 
                        data=graphics_bc %>% filter(!is.na(Demo.dailytech_Tablet)), verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))

summary(graph.bc.nb)

graph.bc.nb.null.2 <- update(graph.bc.nb, . ~ . - Demo.dailytech_Tablet)

anova(graph.bc.nb, graph.bc.nb.null.2)

# not significant

graph.bc.nb <- glmer.nb(NodeRank ~ Demo.dailytech_SmartPhone + (1|Demo.ResponseID), 
                        data=graphics_bc %>% filter(!is.na(Demo.dailytech_SmartPhone)), verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))

summary(graph.bc.nb)

graph.bc.nb.null.2 <- update(graph.bc.nb, . ~ . - Demo.dailytech_SmartPhone)

anova(graph.bc.nb, graph.bc.nb.null.2)

# not significant (p = 0.1108)

graph.bc.nb <- glmer.nb(NodeRank ~ Demo.weeklygaming + (1|Demo.ResponseID), 
                        data=graphics_bc %>% filter(!is.na(Demo.weeklygaming)), verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))

summary(graph.bc.nb)

graph.bc.nb.null.2 <- update(graph.bc.nb, . ~ . - Demo.weeklygaming)

anova(graph.bc.nb, graph.bc.nb.null.2)

# not significant

graph.bc.nb <- glmer.nb(NodeRank ~ Demo.expdataanal + (1|Demo.ResponseID), 
                        data=graphics_bc %>% filter(!is.na(Demo.expdataanal)), verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))

summary(graph.bc.nb)

graph.bc.nb.null.2 <- update(graph.bc.nb, . ~ . - Demo.expdataanal)

anova(graph.bc.nb, graph.bc.nb.null.2)

# not significant

graph.bc.nb <- glmer.nb(NodeRank ~ Demo.expdatavis + (1|Demo.ResponseID), 
                        data=graphics_bc %>% filter(!is.na(Demo.expdatavis)), verbose=TRUE)

summary(graph.bc.nb)

graph.bc.nb.null.2 <- update(graph.bc.nb, . ~ . - Demo.expdatavis)

anova(graph.bc.nb, graph.bc.nb.null.2)

# not significant

graph.bc.nb.readNV <- glmer.nb(NodeRank ~ Demo.expreadnetvis + (1|Demo.ResponseID), 
                        data=graphics_bc %>% filter(!is.na(Demo.expreadnetvis)), verbose=TRUE)

summary(graph.bc.nb.readNV)

# most categories significant; not sure what the reference category is though.  "None"?

graph.bc.nb.null.2 <- update(graph.bc.nb.readNV, . ~ . - Demo.expreadnetvis)

anova(graph.bc.nb.readNV, graph.bc.nb.null.2)

# significant (p = 0.007718)

graph.bc.nb.createNV <- glmer.nb(NodeRank ~ Demo.expcreatenetvis + (1|Demo.ResponseID), 
                        data=graphics_bc %>% filter(!is.na(Demo.expcreatenetvis)), verbose=TRUE)

summary(graph.bc.nb.createNV)

graph.bc.nb.null.2 <- update(graph.bc.nb.createNV, . ~ . - Demo.expcreatenetvis)

anova(graph.bc.nb.createNV, graph.bc.nb.null.2)

# significant (p = 0.003442)

graph.bc.nb.avgdeg <- glmer.nb(NodeRank ~ AvgDeg + (1|Demo.ResponseID), 
                               data=graphics_bc, verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))

summary(graph.bc.nb.avgdeg)

anova(graph.bc.nb.avgdeg, graph.bc.nb.null)

# AvgDeg is significant (p < 2.2e-16)

graph.bc.nb.density <- glmer.nb(NodeRank ~ Density + (1|Demo.ResponseID), 
                                data=graphics_bc, verbose=TRUE)

summary(graph.bc.nb.density)

anova(graph.bc.nb.density, graph.bc.nb.null)

# Density is a significant(p < 2.2e-16)

#graph.bc.nb.largeclust <- glmer.nb(NodeRank ~ LargeClust1 + (1|Demo.ResponseID), 
#                                   data=graphics_bc, verbose=TRUE)

# need to rescale

graphics_bc.CS <- graphics_bc %>% mutate(LargeClust1=scale(LargeClust1))

graph.bc.nb.largeclust <- glmer.nb(NodeRank ~ LargeClust1 + (1|Demo.ResponseID), 
                        data=graphics_bc.CS, verbose=TRUE)

summary(graph.bc.nb.largeclust)

graph.bc.nb.null.2 <- update(graph.bc.nb.largeclust, . ~ . - LargeClust1)

anova(graph.bc.nb.largeclust, graph.bc.nb.null.2)

# LargeClust1 is significant (p < 2.2e-16)

graph.bc.nb.mod <- glmer.nb(NodeRank ~ Modularity + (1|Demo.ResponseID), 
                            data=graphics_bc, verbose=TRUE)

summary(graph.bc.nb.mod)

anova(graph.bc.nb.mod, graph.bc.nb.null)

# Modularity is significant(p < 2.2e-16)

graph.bc.nb.numclust <- glmer.nb(NodeRank ~ NumClust + (1|Demo.ResponseID), 
                                 data=graphics_bc, verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))

summary(graph.bc.nb.numclust)

anova(graph.bc.nb.numclust, graph.bc.nb.null)

# NumClust is significant (p = 1.91e-11)

#graph.bc.nb <- glmer.nb(NodeRank ~ NumHighDegree + (1|Demo.ResponseID), 
#                        data=graphics_bc, verbose=TRUE)

# need to rescale

graphics_bc.CS <- graphics_bc %>% mutate(NumHighDegree=scale(NumHighDegree))

graph.bc.nb.numhighdeg <- glmer.nb(NodeRank ~ NumHighDegree + (1|Demo.ResponseID), 
                        data=graphics_bc.CS, verbose=TRUE)

summary(graph.bc.nb.numhighdeg)

graph.bc.nb.null.2 <- update(graph.bc.nb.numhighdeg, . ~ . - NumHighDegree)

anova(graph.bc.nb.numhighdeg, graph.bc.nb.null.2)

# NumHighDegree is significant (p=0.003951)

#graph.bc.nb.numlinks <- glmer.nb(NodeRank ~ NumLinks + (1|Demo.ResponseID), 
#                                 data=graphics_bc, verbose=TRUE)

# need to rescale

graphics_bc.CS <- graphics_bc %>% mutate(NumLinks=scale(NumLinks))

graph.bc.nb.numlinks <- glmer.nb(NodeRank ~ NumLinks + (1|Demo.ResponseID), 
                        data=graphics_bc.CS, verbose=TRUE)

summary(graph.bc.nb.numlinks)

graph.bc.nb.null.2 <- update(graph.bc.nb.numlinks, . ~ . - NumLinks)

anova(graph.bc.nb.numlinks, graph.bc.nb.null.2)

# NumLinks is significant (p=1.533e-08)

#graph.bc.nb.numnodes <- glmer.nb(NodeRank ~ NumNodes + (1|Demo.ResponseID), 
#                                 data=graphics_bc, verbose=TRUE)

# need to rescale

graphics_bc.CS <- graphics_bc %>% mutate(NumNodes=scale(NumNodes))

graph.bc.nb.numnodes <- glmer.nb(NodeRank ~ NumNodes + (1|Demo.ResponseID), 
                        data=graphics_bc.CS, verbose=TRUE)

summary(graph.bc.nb.numnodes)

graph.bc.nb.null.2 <- update(graph.bc.nb.numnodes, . ~ . - NumNodes)

anova(graph.bc.nb.numnodes, graph.bc.nb.null.2)

# NumNodes is significant (p=1.075e-14)

#graph.bc.nb <- glmer.nb(NodeRank ~ NumNodesClust1 + (1|Demo.ResponseID), 
#                        data=graphics_bc, verbose=TRUE)

# need to rescale

graphics_bc.CS <- graphics_bc %>% mutate(NumNodesClust1=scale(NumNodesClust1))

graph.bc.nb.numnodesclust1 <- glmer.nb(NodeRank ~ NumNodesClust1 + (1|Demo.ResponseID), 
                        data=graphics_bc.CS, verbose=TRUE)

summary(graph.bc.nb.numnodesclust1)

graph.bc.nb.null.2 <- update(graph.bc.nb.numnodesclust1, . ~ . - NumNodesClust1)

anova(graph.bc.nb.numnodesclust1, graph.bc.nb.null.2)

# NumNodesClust1 is significant (p=1.08e-10)
```

```{r, cache=TRUE, eval=FALSE}

# Trying offset, since NodeRank does have a maximum, and that changes by dataset

graph.bc.nb.null.offset <- glmer.nb(NodeRank ~ (1|Demo.ResponseID) + offset(log(MaxNodeRank)), data=graphics_bc, verbose=TRUE)

summary(graph.bc.nb.null.offset)

anova(graph.bc.nb.null, graph.bc.nb.null.offset)

# no significant difference with offset; try once with a significant predictor 

graph.bc.nb.dataset.offset <- glmer.nb(NodeRank ~ Dataset + offset(log(MaxNodeRank)) + (1|Demo.ResponseID), data=graphics_bc, verbose=TRUE, control=glmerControl(optimizer = "nlminbw"))

summary(graph.bc.nb.dataset.offset)

anova(graph.bc.nb.dataset, graph.bc.nb.dataset.offset)

# nope, offset didn't make any difference; proceeding with no-offset models

```


```{r}

#---------------------------------
# Multiple predictors
#---------------------------------

temp <- graphics_bc %>% dplyr::select(Demo.ResponseID, NodeRank, Dataset, DatasetOrder, CorrectAnswer, Stats.Q_TotalDuration, Demo.acfieldGrouped2, Demo.expreadnetvis, Demo.expcreatenetvis, AvgDeg, Density, LargeClust1, Modularity, NumClust, NumHighDegree, NumLinks, NumNodes, NumNodesClust1) %>% drop_na()

temp <- temp %>% mutate(Stats.Q_TotalDuration=scale(Stats.Q_TotalDuration),
                        NormRank=NodeRank/NumNodes)

graph.bc.nb.full <- glmer.nb(NodeRank ~ Dataset + Stats.Q_TotalDuration + 
                               Demo.acfieldGrouped2 + Demo.expcreatenetvis +
                               (1|Demo.ResponseID),
                             data=temp, verbose=TRUE,
                             control=glmerControl(optimizer = "bobyqa"))

summary(graph.bc.nb.full)
# still significant - Dataset, Stats.Q_TotalDuration, Demo.acfieldGrouped2, Demo.expcreatenetvis
```

```{r}
#---------------------------------
# Interactions
#---------------------------------

graph.bc.nb.full.int <- glmer.nb(NodeRank ~ Dataset + Stats.Q_TotalDuration + 
                                   Demo.acfieldGrouped2 + Demo.expcreatenetvis +
                                   Stats.Q_TotalDuration:Demo.acfieldGrouped2 +
                                   (1|Demo.ResponseID),
                                 data=temp, verbose=TRUE,
                                 control=glmerControl(optimizer = "bobyqa"))

summary(graph.bc.nb.full.int)

anova(graph.bc.nb.full, graph.bc.nb.full.int)
# yes, interaction is significantly different from just main effects (p = 0.02812)

```


```{r}

#SAVE THE RESULTS
save(graph.bc.nb.full.int, file = file.path(analysisDataDir,"fits/graph_bc_nb_full_int.RData"))

```

```{r}

graph.bc.nb.full.int.f <- fortify(graph.bc.nb.full.int)

ggplot(graph.bc.nb.full.int.f, aes(.fitted,.resid)) + 
  geom_point() +
  geom_hline(yintercept=0)

ggplot(graph.bc.nb.full.int.f, aes(.resid)) +
  geom_histogram()

# not *quite* normally distributed...  but not too skewed?

ggplot(graph.bc.nb.full.int.f, aes(.fitted,NodeRank)) + 
  geom_point() +
  geom_hline(yintercept=0) +
  scale_y_log10()

ggplot(graph.bc.nb.full.int.f, aes(.fitted,NodeRank, color=Dataset)) + 
  geom_point() +
  geom_hline(yintercept=0) +
  scale_y_log10() +
  scale_color_brewer(palette = "Dark2")

ggplot(graph.bc.nb.full.int.f, aes(NodeRank,.fitted)) + 
  geom_point() +
  geom_hline(yintercept=0)

ggplot(graph.bc.nb.full.int.f, aes(NodeRank, .fitted, color=Dataset)) + 
  geom_point() +
  geom_hline(yintercept=0) +
  scale_color_brewer(palette = "Dark2")

ggplot(graph.bc.nb.full.int.f, aes(NodeRank,.fitted)) + 
  geom_point() +
  geom_hline(yintercept=0) +
  facet_wrap(~Dataset)

(r2nsj = r2beta(graph.bc.nb.full.int, method = 'nsj', partial = TRUE))[1,'Rsq']

ggplot(graphics_bc) + geom_histogram(aes(NodeRank), binwidth=1) + 
  labs(title="Distribution of NodeRank values for\nNode Betweenness Centrality task, graphics conditions")

ggplot(graph.bc.nb.full.int.f, aes(NodeRank,.fitted)) +
geom_bin2d() +
geom_abline(aes(slope = 1, intercept = 0)) +
#scale_y_continuous(limits=c(0,0.3)) +
labs(title="Real vs. Predicted NodeRank values for\nNode Betweenness Centrality task, graphics conditions")


```



```{r}

# is negative binomial different from poisson?  if so, indicates over-dispersion is true
# and negative binomial is necessary

graph.bc.pois <- glmer(NodeRank ~ Dataset + Stats.Q_TotalDuration + 
                                   Demo.acfieldGrouped2 + Demo.expcreatenetvis +
                                   Stats.Q_TotalDuration:Demo.acfieldGrouped2 +
                                   (1|Demo.ResponseID), data=temp, family="poisson")


pchisq(2 * (logLik(graph.bc.nb.full.int) - logLik(graph.bc.pois)), df=1, lower.tail = FALSE)

# value = 6.566148e-73, so keep the negative binomial

```

```{r}
# run without mixed effects to validate

m.glm <- glm.nb(NodeRank ~ Dataset + Stats.Q_TotalDuration + 
                                   Demo.acfieldGrouped2 + Demo.expcreatenetvis +
                                   Stats.Q_TotalDuration:Demo.acfieldGrouped2, data=temp, trace=TRUE)
summary(m.glm)

## The neg.binomial theta parameter:
getME(graph.bc.nb.full.int, "glmer.nb.theta")

#3.835875

## mixed model has 1 additional parameter (RE variance)
stopifnot(attr(logLik(graph.bc.nb.full.int),"df")==attr(logLik(m.glm),"df")+1) # not sure what this does

anova(graph.bc.nb.full.int,m.glm) # can I use anova to compare mixed and fixed effects?
# p < 2.2e-16, so definitely random effects

plot(graph.bc.nb.full.int, resid(.) ~ NodeRank)# works, as long as data 'dd' is found


# TO DO : check if this is all right

```

```{r}

par(mfrow=c(2,2))
qqnorm(resid(graph.bc.nb.full.int), main="normal qq-plot, residuals")
qqline(resid(graph.bc.nb.full.int))

qqnorm(ranef(graph.bc.nb.full.int)$Demo.ResponseID[,1])
qqline(ranef(graph.bc.nb.full.int)$Demo.ResponseID[,1])


plot(fitted(graph.bc.nb.full.int), resid(graph.bc.nb.full.int)) #residuals vs fitted
abline(h=0)

#graph.avgdeg.nb2.f <- fortify(graph.avgdeg.nb2)

#ggplot(graph.avgdeg.nb2.f, aes(.fitted,.resid)) + 
#  geom_point() +
#  geom_hline(yintercept=0)

#temp <- graphics_avgdeg

temp$fitted <- fitted(graph.bc.nb.full.int) 
plot(temp$fitted, jitter(temp$NodeRank,0.1)) #fitted vs observed
abline(0,1)

#ggplot(graph.avgdeg.nb2.f, aes(.fitted,Response)) + 
#  geom_point() +
#  geom_abline(aes(slope = 1, intercept = 0))


```

```{r, cache=TRUE, eval=FALSE}

# Confidence Intervals, using coefficients

(est <- cbind(Estimate = coef(graph.avgdeg.nb.full.int), confint(graph.avgdeg.nb.full.int)))

# exponentiate model to look at incident rate ratios instead of coefficients

exp(est)

```

```{r, eval=FALSE}

# predictions

# model: Response ~ Dataset + TaskOrder + Demo.dailytech_SmartPhone + Dataset:TaskOrder + TaskOrder:Demo.dailytech_SmartPhone + Dataset:Demo.dailytech_SmartPhone + (1 | Demo.ResponseID)

newdata1 <- data.frame(Demo.dailytech_SmartPhone = rep(mean(temp$Demo.dailytech_SmartPhone),54), 
                       Dataset = factor(rep(c(1,3,5,7,8,9),9), levels = levels(temp$Dataset),ordered = TRUE),
                       TaskOrder = rep(1:9,6),
                       Demo.ResponseID = sample(temp$Demo.ResponseID,54))
newdata1$phat <- predict(graph.avgdeg.nb.full.int, newdata1, type = "response")
#newdata1

newdata2 <- data.frame(
  Demo.dailytech_SmartPhone = rep(seq(from = min(temp$Demo.dailytech_SmartPhone), to = max(temp$Demo.dailytech_SmartPhone), length.out = 100), 6),
  Dataset = factor(rep(c(1,3,5,7,8,9), each = 100), levels = levels(temp$Dataset),ordered = TRUE),
  TaskOrder = rep(1:9,len=600),
  Demo.ResponseID = sample(temp$Demo.ResponseID,600)
  )

#predict(graph.avgdeg.nb.full.int, newdata2, type = "link", se.fit=TRUE)
newdata2 <- cbind(newdata2, predict(graph.avgdeg.nb.full.int, newdata2, type = "link", se.fit=TRUE))

# not sure about this; asking for "fit", but that's not recognized. should the new column be called "fit"? what about se.fit?

#newdata2 <- within(newdata2, {
#  Response <- exp(fit)
#  LL <- exp(fit - 1.96 * se.fit)
#  UL <- exp(fit + 1.96 * se.fit)
#})

#ggplot(newdata2, aes(math, DaysAbsent)) +
#  geom_ribbon(aes(ymin = LL, ymax = UL, fill = prog), alpha = .25) +
#  geom_line(aes(colour = prog), size = 2) +
#  labs(x = "Math Score", y = "Predicted Days Absent")

# note on negative binomial:

# TO DO : If the data generating process does not allow for any 0s (such as the number of days spent in the hospital), then a zero-truncated model may be more appropriate.

# TO DO : Count data often have an exposure variable, which indicates the number of times the event could have happened (i.e. a max). This variable should be incorporated into your negative binomial regression model with the use of the offset option. See the glm documentation for details.  (so, that would make sense for click data???)

# other info:
# Cameron, A. C. and Trivedi, P. K. 1998. Regression Analysis of Count Data. New York: Cambridge Press.
# Dupont, W. D. 2002. Statistical Modeling for Biomedical Researchers: A Simple Introduction to the Analysis of Complex Data. New York: Cambridge Press.

```

#### Least Squares

Full model (graph.bc.nb.full.int): 
NodeRank ~ Dataset + Stats.Q_TotalDuration + Demo.acfieldGrouped2 + Demo.expcreatenetvis + Stats.Q_TotalDuration:Demo.acfieldGrouped2 + (1|Demo.ResponseID)

##### Dataset

###### emmeans

```{r}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numhighdeg, table(Dataset,Overestimated))
# ref_grid(graph.numhd.lmer.full.int.4) @ grid; .wgt. is number of observations

graph.bc.emm.data <- emmeans(graph.bc.nb.full.int, "Dataset", nesting = NULL)
#graph.numhd.emm.condition <- emmeans(graph.numhd.lmer.full.int.4, "Condition", lmer.df = "satterthwaite")

graph.bc.emm.data

graph.bc.emm.data.df <- dplyr::as_data_frame(graph.bc.emm.data)

graph.bc.emm.data.df


# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numhd.emm.condition)

graph.bc.emm.data.cld <- cld(graph.bc.emm.data,
                details=TRUE,
                #alpha=0.01,
                #by="Dataset",
                #Letters="|||||||||||||||||||",
                sort=TRUE
)

graph.bc.emm.data.cld.df <- graph.bc.emm.data.cld$emmeans

graph.bc.emm.data.cld.df %>% dplyr::select(Dataset,.group)

graph.bc.emm.data.cld.df

graph.bc.emm.data.cld.df$Dataset <- factor(graph.bc.emm.data.cld.df$Dataset, levels=graph.bc.emm.data.cld.df %>% arrange(desc(emmean)) %>% dplyr::select(Dataset) %>% unlist())


#emmip(graph.numlinks.lmer.full.int, ~Condition, CIs = TRUE)
emmip(graph.bc.emm.data, ~Dataset, CIs = TRUE)
plot(graph.bc.emm.data)
#plot(graph.numlinks.emm.cond, comparisons = TRUE)

graph.bc.emm.data.cld.df %>% arrange(desc(emmean))

ggplot(graph.bc.emm.data.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Dataset,ymax=asymp.UCL,ymin=asymp.LCL), width=.2) +
  geom_point(aes(x=Dataset,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.bc.emm.data.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Dataset,ymax=asymp.UCL,ymin=asymp.LCL), width=.2) +
  geom_point(aes(x=Dataset,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip() +
labs(title="Estimated Marginal Means for Dataset for\nNode Betweenness Centrality task, graphics conditions")


#plot(ref_grid(graph.numnodes.lmer.int.3), by="Condition") 
# try to figure this out? maybe only works on the interaction?
```

```{r}

graph.bc.emm.data.pairs <- dplyr::as_data_frame(pairs(graph.bc.emm.data)) 
graph.bc.emm.data.pairs
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

pairs.CI <- confint(pairs(graph.bc.emm.data))

graph.bc.emm.data.pairs <- full_join(graph.bc.emm.data.pairs, pairs.CI)

#graph.numhd.diffemm.condition <- emmeans(graph.numhd.lmer.full.int.4, pairwise ~ Condition)
#graph.numhd.diffemm.condition$contrasts
#contrast(graph.numhd.emm.condition)
#confint(graph.numhd.emm.condition)
#pairs(graph.numhd.emm.condition, details=TRUE)
#confint(contrast(graph.numhd.emm.condition))
#confint(pairs(graph.numhd.emm.condition))
#coef(pairs(graph.numhd.emm.condition))


plot(pairs(graph.bc.emm.data))
plot(pairs(graph.bc.emm.data), comparisons = TRUE)

graph.bc.emm.data.pairs$sig.levels <- 
  case_when(graph.bc.emm.data.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.bc.emm.data.pairs$p.value < .001 ~ sig.level.names[2],
            graph.bc.emm.data.pairs$p.value < .01 ~ sig.level.names[3],
            graph.bc.emm.data.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.bc.emm.data.pairs$sig.levels <- factor(graph.bc.emm.data.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)


graph.bc.emm.data.pairs$contrast <- factor(graph.bc.emm.data.pairs$contrast, levels=graph.bc.emm.data.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())

graph.bc.emm.data.pairs <- graph.bc.emm.data.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.bc.emm.data.pairs %>% arrange(estimate)

ggplot(graph.bc.emm.data.pairs) +
  geom_errorbar(aes(x=contrast,ymax=asymp.UCL,ymin=asymp.LCL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.bc.emm.data.pairs) +
  geom_errorbar(aes(x=contrast,ymax=asymp.UCL,ymin=asymp.LCL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

```

```{r}

#cond.lev <- c("Ctrl","Phr","Col","Siz")


copy <- graph.bc.emm.data.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         z.ratio=-z.ratio,
         asymp.LCL=-asymp.LCL,
         asymp.UCL=-asymp.UCL)

graph.bc.emm.data.pairs.compl <- bind_rows(graph.bc.emm.data.pairs, copy)

copy$From <- factor(copy$From, levels=rev(unique(copy$From)))
#graph.bc.emm.data.pairs$To <- factor(graph.bc.emm.data.pairs$To, levels=cond.lev)
#graph.bc.emm.data.pairs$From <- factor(graph.bc.emm.data.pairs$From, levels=rev(cond.lev))

highest<-max(abs(copy$estimate))

ggplot(copy, aes(x=To,y=From)) +
  geom_tile(aes(fill=estimate)) +
  geom_text(aes(label=paste0(format(estimate, digits=2, nsmall=2),"\n(",sig.levels,")"))) +
    scale_fill_distiller(type="div", palette=4, limits=c(-highest,highest)) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")


```

```{r}

graph.bc.emm.data.pairs.compl$From <- factor(graph.bc.emm.data.pairs.compl$From, levels=rev(unique(graph.bc.emm.data.pairs.compl$From)))
#graph.bc.emm.data.pairs.compl$To <- factor(graph.bc.emm.data.pairs.compl$To, levels=cond.lev)
#graph.bc.emm.data.pairs.compl$From <- factor(graph.bc.emm.data.pairs.compl$From, levels=rev(cond.lev))


#graph.numlinks.emm.cond.pairs.compl %>% arrange(desc(estimate))
graph.bc.emm.data.pairs.compl %>% arrange(estimate)

ggplot(graph.bc.emm.data.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.bc.emm.data.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.bc.emm.data.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
    scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.bc.emm.data.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")


```

###### networks

```{r, eval=FALSE}

# try a network of the pairwise significance values?  bleh...
# using igraph

graph <- graph_from_data_frame(graph.bc.emm.data.pairs %>% dplyr::select(-contrast), directed=TRUE)

E(graph)$width <- abs(E(graph)$estimate)*10
E(graph)$edge.color <- sig.colors[E(graph)$sig.levels]

graph

plot(graph, 
     edge.arrow.size=.5,
     vertex.frame.color="#555555")

```

```{r, eval=FALSE}

# using ggraph and tidygraph

graph <- graph_from_data_frame(graph.bc.emm.data.pairs.compl %>% dplyr::select(-contrast) %>% filter(sig.levels != "NS"), directed=TRUE)

# plot using ggraph
ggraph(graph, layout = 'kk') +
  geom_edge_link(aes(start_cap = label_rect(node1.name),
                       end_cap = label_rect(node2.name),
                     color=factor(sig.level.names[sig.levels]),
                     edge_width=.5/sig.levels
                     ), 
                   arrow = arrow(length = unit(4, 'mm')))+
  geom_node_text(label = vertex_attr(graph,"name")) +
  scale_edge_color_manual("Significance Levels", values=sig.colors) +
  scale_edge_width_continuous(labels=rev(sig.level.names)) +
  theme_graph()

```





##### Stats.Q_TotalDuration

```{r}

ggplot(graphics_bc) + 
  geom_bin2d(aes(Stats.Q_TotalDuration,NodeRank)) +
  geom_smooth(aes(Stats.Q_TotalDuration,NodeRank), method="lm") +
  labs(title="Total Survey Duration vs. NodeRank for\nNode Betweenness Centrality task, graphics conditions",
       x="Total Duration (sec)")



```

##### Demo.acfieldGrouped2

###### emmeans

```{r}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numhighdeg, table(Dataset,Overestimated))
# ref_grid(graph.numhd.lmer.full.int.4) @ grid; .wgt. is number of observations

graph.bc.emm.acfield2 <- emmeans(graph.bc.nb.full.int, "Demo.acfieldGrouped2", nesting = NULL)
#graph.numhd.emm.condition <- emmeans(graph.numhd.lmer.full.int.4, "Condition", lmer.df = "satterthwaite")

graph.bc.emm.acfield2

graph.bc.emm.acfield2.df <- dplyr::as_data_frame(graph.bc.emm.acfield2)

graph.bc.emm.acfield2.df


# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numhd.emm.condition)

graph.bc.emm.acfield2.cld <- cld(graph.bc.emm.acfield2,
                details=TRUE,
                #alpha=0.01,
                #by="Dataset",
                #Letters="|||||||||||||||||||",
                sort=TRUE
)

graph.bc.emm.acfield2.cld.df <- graph.bc.emm.acfield2.cld$emmeans

graph.bc.emm.acfield2.cld.df %>% dplyr::select(Demo.acfieldGrouped2,.group)

graph.bc.emm.acfield2.cld.df

graph.bc.emm.acfield2.cld.df$Demo.acfieldGrouped2 <- factor(graph.bc.emm.acfield2.cld.df$Demo.acfieldGrouped2, levels=graph.bc.emm.acfield2.cld.df %>% arrange(desc(emmean)) %>% dplyr::select(Demo.acfieldGrouped2) %>% unlist())


#emmip(graph.numlinks.lmer.full.int, ~Condition, CIs = TRUE)
emmip(graph.bc.emm.acfield2, ~Demo.acfieldGrouped2, CIs = TRUE)
plot(graph.bc.emm.acfield2)
#plot(graph.numlinks.emm.cond, comparisons = TRUE)

graph.bc.emm.acfield2.cld.df %>% arrange(desc(emmean))

ggplot(graph.bc.emm.acfield2.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Demo.acfieldGrouped2,ymax=asymp.UCL,ymin=asymp.LCL), width=.2) +
  geom_point(aes(x=Demo.acfieldGrouped2,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.bc.emm.acfield2.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Demo.acfieldGrouped2,ymax=asymp.UCL,ymin=asymp.LCL), width=.2) +
  geom_point(aes(x=Demo.acfieldGrouped2,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip() +
  scale_x_discrete(labels=c("High Error Group","Low Error Group")) +
labs(title="Estimated Marginal Means for Academic Field for\nNode Betweenness Centrality task, graphics conditions",
     x="Academic Field")



#plot(ref_grid(graph.numnodes.lmer.int.3), by="Condition") 
# try to figure this out? maybe only works on the interaction?
```

```{r}

graph.bc.emm.acfield2.pairs <- dplyr::as_data_frame(pairs(graph.bc.emm.acfield2)) 
graph.bc.emm.acfield2.pairs
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

pairs.CI <- confint(pairs(graph.bc.emm.acfield2))

graph.bc.emm.acfield2.pairs <- full_join(graph.bc.emm.acfield2.pairs, pairs.CI)

#graph.numhd.diffemm.condition <- emmeans(graph.numhd.lmer.full.int.4, pairwise ~ Condition)
#graph.numhd.diffemm.condition$contrasts
#contrast(graph.numhd.emm.condition)
#confint(graph.numhd.emm.condition)
#pairs(graph.numhd.emm.condition, details=TRUE)
#confint(contrast(graph.numhd.emm.condition))
#confint(pairs(graph.numhd.emm.condition))
#coef(pairs(graph.numhd.emm.condition))


plot(pairs(graph.bc.emm.acfield2))
#plot(pairs(graph.bc.emm.acfield2), comparisons = TRUE)

graph.bc.emm.acfield2.pairs$sig.levels <- 
  case_when(graph.bc.emm.acfield2.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.bc.emm.acfield2.pairs$p.value < .001 ~ sig.level.names[2],
            graph.bc.emm.acfield2.pairs$p.value < .01 ~ sig.level.names[3],
            graph.bc.emm.acfield2.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.bc.emm.acfield2.pairs$sig.levels <- factor(graph.bc.emm.acfield2.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)


graph.bc.emm.acfield2.pairs$contrast <- factor(graph.bc.emm.acfield2.pairs$contrast, levels=graph.bc.emm.acfield2.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())

graph.bc.emm.acfield2.pairs <- graph.bc.emm.acfield2.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.bc.emm.acfield2.pairs %>% arrange(estimate)

ggplot(graph.bc.emm.acfield2.pairs) +
  geom_errorbar(aes(x=contrast,ymax=asymp.UCL,ymin=asymp.LCL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.bc.emm.acfield2.pairs) +
  geom_errorbar(aes(x=contrast,ymax=asymp.UCL,ymin=asymp.LCL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

```

```{r}

#cond.lev <- c("Ctrl","Phr","Col","Siz")


copy <- graph.bc.emm.acfield2.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         z.ratio=-z.ratio,
         asymp.LCL=-asymp.LCL,
         asymp.UCL=-asymp.UCL)

graph.bc.emm.acfield2.pairs.compl <- bind_rows(graph.bc.emm.acfield2.pairs, copy)

copy$From <- factor(copy$From, levels=rev(unique(copy$From)))
#graph.bc.emm.data.pairs$To <- factor(graph.bc.emm.data.pairs$To, levels=cond.lev)
#graph.bc.emm.data.pairs$From <- factor(graph.bc.emm.data.pairs$From, levels=rev(cond.lev))

highest<-max(abs(copy$estimate))

ggplot(copy, aes(x=To,y=From)) +
  geom_tile(aes(fill=estimate)) +
  geom_text(aes(label=paste0(format(estimate, digits=2, nsmall=2),"\n(",sig.levels,")"))) +
    scale_fill_distiller(type="div", palette=4, limits=c(-highest,highest)) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")


```

```{r}

graph.bc.emm.acfield2.pairs.compl$From <- factor(graph.bc.emm.acfield2.pairs.compl$From, levels=rev(unique(graph.bc.emm.acfield2.pairs.compl$From)))
#graph.bc.emm.data.pairs.compl$To <- factor(graph.bc.emm.data.pairs.compl$To, levels=cond.lev)
#graph.bc.emm.data.pairs.compl$From <- factor(graph.bc.emm.data.pairs.compl$From, levels=rev(cond.lev))


#graph.numlinks.emm.cond.pairs.compl %>% arrange(desc(estimate))
graph.bc.emm.acfield2.pairs.compl %>% arrange(estimate)

ggplot(graph.bc.emm.acfield2.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.bc.emm.acfield2.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.bc.emm.acfield2.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
    scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.bc.emm.acfield2.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")


```

###### networks

```{r, eval=FALSE}

# try a network of the pairwise significance values?  bleh...
# using igraph

graph <- graph_from_data_frame(graph.bc.emm.acfield2.pairs %>% dplyr::select(-contrast), directed=TRUE)

E(graph)$width <- abs(E(graph)$estimate)*10
E(graph)$edge.color <- sig.colors[E(graph)$sig.levels]

graph

plot(graph, 
     edge.arrow.size=.5,
     vertex.frame.color="#555555")

```

```{r, eval=FALSE}

# using ggraph and tidygraph

graph <- graph_from_data_frame(graph.bc.emm.acfield2.pairs %>% dplyr::select(-contrast) %>% filter(sig.levels != "NS"), directed=TRUE)

# plot using ggraph
ggraph(graph, layout = 'kk') +
  geom_edge_link(aes(start_cap = label_rect(node1.name),
                       end_cap = label_rect(node2.name),
                     color=factor(sig.level.names[sig.levels]),
                     edge_width=.5/sig.levels
                     ), 
                   arrow = arrow(length = unit(4, 'mm')))+
  geom_node_text(label = vertex_attr(graph,"name")) +
  #scale_edge_color_manual("Significance Levels", values=sig.colors) +
  #scale_edge_width_continuous(labels=rev(sig.level.names)) +
  theme_graph()

```







##### Demo.expcreatenetvis

###### emmeans

```{r}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numhighdeg, table(Dataset,Overestimated))
# ref_grid(graph.numhd.lmer.full.int.4) @ grid; .wgt. is number of observations

graph.bc.emm.ecnv <- emmeans(graph.bc.nb.full.int, "Demo.expcreatenetvis", nesting = NULL)
#graph.numhd.emm.condition <- emmeans(graph.numhd.lmer.full.int.4, "Condition", lmer.df = "satterthwaite")

graph.bc.emm.ecnv

graph.bc.emm.ecnv.df <- dplyr::as_data_frame(graph.bc.emm.ecnv)

graph.bc.emm.ecnv.df


# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numhd.emm.condition)

graph.bc.emm.ecnv.cld <- cld(graph.bc.emm.ecnv,
                details=TRUE,
                #alpha=0.01,
                #by="Dataset",
                #Letters="|||||||||||||||||||",
                sort=TRUE
)

graph.bc.emm.ecnv.cld.df <- graph.bc.emm.ecnv.cld$emmeans

graph.bc.emm.ecnv.cld.df %>% dplyr::select(Demo.expcreatenetvis,.group)

graph.bc.emm.ecnv.cld.df

#graph.bc.emm.ecnv.cld.df$Demo.expcreatenetvis <- factor(graph.bc.emm.ecnv.cld.df$Demo.expcreatenetvis, levels=graph.bc.emm.ecnv.cld.df %>% arrange(desc(emmean)) %>% dplyr::select(Demo.expcreatenetvis) %>% unlist())
graph.bc.emm.ecnv.cld.df$Demo.expcreatenetvis <- factor(graph.bc.emm.ecnv.cld.df$Demo.expcreatenetvis, levels=freq4)


#emmip(graph.numlinks.lmer.full.int, ~Condition, CIs = TRUE)
emmip(graph.bc.emm.ecnv, ~Demo.expcreatenetvis, CIs = TRUE)
plot(graph.bc.emm.ecnv)
#plot(graph.numlinks.emm.cond, comparisons = TRUE)

graph.bc.emm.ecnv.cld.df %>% arrange(Demo.expcreatenetvis)

ggplot(graph.bc.emm.ecnv.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Demo.expcreatenetvis,ymax=asymp.UCL,ymin=asymp.LCL), width=.2) +
  geom_point(aes(x=Demo.expcreatenetvis,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.bc.emm.ecnv.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=ordered(Demo.expcreatenetvis,levels=rev(freq4)),ymax=asymp.UCL,ymin=asymp.LCL), width=.2) +
  geom_point(aes(x=Demo.expcreatenetvis,y=emmean), size=7) +
  coord_flip() +
  labs(title="Estimated Marginal Means for Experience Creating Network Visualizations for\nNode Betweenness Centrality task, graphics conditions",
       x="Experience Creating Network Visualizations")


#plot(ref_grid(graph.numnodes.lmer.int.3), by="Condition") 
# try to figure this out? maybe only works on the interaction?
```

```{r}

graph.bc.emm.ecnv.pairs <- dplyr::as_data_frame(pairs(graph.bc.emm.ecnv)) 
graph.bc.emm.ecnv.pairs
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

pairs.CI <- confint(pairs(graph.bc.emm.ecnv))

graph.bc.emm.ecnv.pairs <- full_join(graph.bc.emm.ecnv.pairs, pairs.CI)

#graph.numhd.diffemm.condition <- emmeans(graph.numhd.lmer.full.int.4, pairwise ~ Condition)
#graph.numhd.diffemm.condition$contrasts
#contrast(graph.numhd.emm.condition)
#confint(graph.numhd.emm.condition)
#pairs(graph.numhd.emm.condition, details=TRUE)
#confint(contrast(graph.numhd.emm.condition))
#confint(pairs(graph.numhd.emm.condition))
#coef(pairs(graph.numhd.emm.condition))


plot(pairs(graph.bc.emm.ecnv))
#plot(pairs(graph.bc.emm.acfield2), comparisons = TRUE)

graph.bc.emm.ecnv.pairs$sig.levels <- 
  case_when(graph.bc.emm.ecnv.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.bc.emm.ecnv.pairs$p.value < .001 ~ sig.level.names[2],
            graph.bc.emm.ecnv.pairs$p.value < .01 ~ sig.level.names[3],
            graph.bc.emm.ecnv.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.bc.emm.ecnv.pairs$sig.levels <- factor(graph.bc.emm.ecnv.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)


graph.bc.emm.ecnv.pairs$contrast <- factor(graph.bc.emm.ecnv.pairs$contrast, levels=graph.bc.emm.ecnv.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())

graph.bc.emm.ecnv.pairs <- graph.bc.emm.ecnv.pairs %>% separate(contrast, c("From", "To"), sep="[-]", remove=FALSE) %>% mutate(From=str_trim(From),To=str_trim(To))

graph.bc.emm.ecnv.pairs %>% arrange(estimate)

ggplot(graph.bc.emm.ecnv.pairs) +
  geom_errorbar(aes(x=contrast,ymax=asymp.UCL,ymin=asymp.LCL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.bc.emm.ecnv.pairs) +
  geom_errorbar(aes(x=contrast,ymax=asymp.UCL,ymin=asymp.LCL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

```

```{r}

#cond.lev <- c("Ctrl","Phr","Col","Siz")


copy <- graph.bc.emm.ecnv.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         z.ratio=-z.ratio,
         asymp.LCL=-asymp.LCL,
         asymp.UCL=-asymp.UCL)

graph.bc.emm.ecnv.pairs.compl <- bind_rows(graph.bc.emm.ecnv.pairs, copy)

#copy$From <- factor(copy$From, levels=rev(unique(copy$From)))
copy$To <- factor(copy$To, levels=freq4)
copy$From <- factor(copy$From, levels=rev(freq4))

highest<-max(abs(copy$estimate))

ggplot(copy, aes(x=To,y=From)) +
  geom_tile(aes(fill=estimate)) +
  geom_text(aes(label=paste0(format(estimate, digits=2, nsmall=2),"\n(",sig.levels,")"))) +
    scale_fill_distiller(type="div", palette=4, limits=c(-highest,highest)) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")


```

```{r}

#graph.bc.emm.ecnv.pairs.compl$From <- factor(graph.bc.emm.ecnv.pairs.compl$From, levels=rev(unique(graph.bc.emm.ecnv.pairs.compl$From)))
graph.bc.emm.ecnv.pairs.compl$To <- factor(graph.bc.emm.ecnv.pairs.compl$To, levels=freq4)
graph.bc.emm.ecnv.pairs.compl$From <- factor(graph.bc.emm.ecnv.pairs.compl$From, levels=rev(freq4))


#graph.numlinks.emm.cond.pairs.compl %>% arrange(desc(estimate))
graph.bc.emm.ecnv.pairs.compl %>% arrange(estimate)

ggplot(graph.bc.emm.ecnv.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.bc.emm.ecnv.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.bc.emm.ecnv.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
    scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.bc.emm.ecnv.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")


```

###### networks

```{r, eval=FALSE}

# try a network of the pairwise significance values?  bleh...
# using igraph

graph <- graph_from_data_frame(graph.bc.emm.ecnv.pairs %>% dplyr::select(-contrast), directed=TRUE)

E(graph)$width <- abs(E(graph)$estimate)*10
E(graph)$edge.color <- sig.colors[E(graph)$sig.levels]

graph

plot(graph, 
     edge.arrow.size=.5,
     vertex.frame.color="#555555")

```

```{r, eval=FALSE}

# using ggraph and tidygraph

graph <- graph_from_data_frame(graph.bc.emm.ecnv.pairs %>% dplyr::select(-contrast) %>% filter(sig.levels != "NS"), directed=TRUE)

# plot using ggraph
ggraph(graph, layout = 'kk') +
  geom_edge_link(aes(start_cap = label_rect(node1.name),
                       end_cap = label_rect(node2.name),
                     color=factor(sig.level.names[sig.levels]),
                     edge_width=.5/sig.levels
                     ), 
                   arrow = arrow(length = unit(4, 'mm')))+
  geom_node_text(label = vertex_attr(graph,"name")) +
  #scale_edge_color_manual("Significance Levels", values=sig.colors) +
  #scale_edge_width_continuous(labels=rev(sig.level.names)) +
  theme_graph()

```







##### Demo.acfieldGrouped2:Stats.Q_TotalDuration

```{r}

ggplot(graphics_bc) + 
  geom_bin2d(aes(Stats.Q_TotalDuration,NodeRank)) +
  geom_smooth(aes(Stats.Q_TotalDuration,NodeRank), method="lm") +
  labs(title="Total Survey Duration vs. NodeRank by Academic Field for\nNode Betweenness Centrality task, graphics conditions",
       x="Total Duration (sec)") +
  facet_wrap(~factor(Demo.acfieldGrouped2, labels=c("Low Error Group","High Error Group")))



```

### Select Highest Degree Node

#### Negative binomial model for click questions Node Rank

Ranks are like count data, in that they are nonnegative integers, so using a negative binomial distribution to model. Negative binomial is especially useful for over-dispersed data - data where the conditional variances exceed conditional means. 

```{r}

# https://stats.idre.ucla.edu/r/dae/negative-binomial-regression/ for non-mixed version

# Test for overdispersion

with(graphics_clickhighdeg, tapply(NodeRank, Condition, function(x) {
    sprintf("M (SD) = %1.2f (%1.2f)", mean(x), sd(x))
}))

# variances in each condition (except Control) are larger than means in the conditions

```


```{r, cache=TRUE, eval=FALSE}



graph.clickhd.nb.null <- glmer.nb(NodeRank ~ (1|Demo.ResponseID), data=graphics_clickhighdeg, verbose=TRUE)

graph.clickhd.nb <- glmer.nb(NodeRank ~ Condition + (1|Demo.ResponseID), data=graphics_clickhighdeg, verbose=TRUE)

summary(graph.clickhd.nb)

anova(graph.clickhd.nb, graph.clickhd.nb.null)

# model is not significantly different from null model (p=0.5654), so Condition isn't a
# significant predictor

graph.clickhd.nb <- glmer.nb(NodeRank ~ factor(Ctrl_dummy) + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg, verbose=TRUE)

summary(graph.clickhd.nb)

anova(graph.clickhd.nb, graph.clickhd.nb.null)

# Ctrl_dummy is not significant

graph.clickhd.nb <- glmer.nb(NodeRank ~ ConditionPhrasing + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg, verbose=TRUE)

summary(graph.clickhd.nb)

anova(graph.clickhd.nb, graph.clickhd.nb.null)

# ConditionPhrasing is not significant

graph.clickhd.nb <- glmer.nb(NodeRank ~ ConditionPhrasing + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg %>% filter(Condition %in% c("Ctrl","Phr")), verbose=TRUE)

summary(graph.clickhd.nb)

graph.clickhd.nb.null.2 <- update(graph.clickhd.nb, . ~ . - ConditionPhrasing)

anova(graph.clickhd.nb, graph.clickhd.nb.null.2)

# ConditionPhrasing is not significant


graph.clickhd.nb <- glmer.nb(NodeRank ~ ConditionGraphics + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg, verbose=TRUE)

summary(graph.clickhd.nb)

anova(graph.clickhd.nb, graph.clickhd.nb.null)

# ConditionGraphics is not significant


graph.clickhd.nb.dataset <- glmer.nb(NodeRank ~ Dataset + (1|Demo.ResponseID), data=graphics_clickhighdeg, verbose=TRUE)

summary(graph.clickhd.nb.dataset)

anova(graph.clickhd.nb.dataset, graph.clickhd.nb.null)

# model is significantly different from null model (p < 2.2e-16)

graph.clickhd.nb <- glmer.nb(NodeRank ~ DatasetOrder + (1|Demo.ResponseID), data=graphics_clickhighdeg, verbose=TRUE)

summary(graph.clickhd.nb)

anova(graph.clickhd.nb, graph.clickhd.nb.null)

# DatasetOrder is not significant

#graph.clickhd.nb <- glmer.nb(NodeRank ~ DatasetDuration + (1|Demo.ResponseID), data=graphics_clickhighdeg %>% filter(!is.na(DatasetDuration)), verbose=TRUE)

# major error: PIRLS step-halvings failed to reduce deviance in pwrssUpdate; rescale data

graphics_clickhighdeg.CS <- graphics_clickhighdeg %>% mutate(DatasetDuration=scale(DatasetDuration))

graph.clickhd.nb <- glmer.nb(NodeRank ~ DatasetDuration + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg.CS %>% filter(!is.na(DatasetDuration)), verbose=TRUE)

summary(graph.clickhd.nb)

graph.clickhd.nb.null2 <- update(graph.clickhd.nb, . ~ . - DatasetDuration)

anova(graph.clickhd.nb, graph.clickhd.nb.null2)

# DatasetDuration is not significant 

graph.clickhd.nb <- glmer.nb(NodeRank ~ TaskOrder + (1|Demo.ResponseID), data=graphics_clickhighdeg, verbose=TRUE)

summary(graph.clickhd.nb)

anova(graph.clickhd.nb, graph.clickhd.nb.null)

# TaskOrder is not significant

#graph.clickhd.nb <- glmer.nb(NodeRank ~ QuestionOrder + (1|Demo.ResponseID), data=graphics_clickhighdeg, verbose=TRUE)

# warnings about rescaling variables

graphics_clickhighdeg.CS <- graphics_clickhighdeg %>% mutate(QuestionOrder=scale(QuestionOrder))

graph.clickhd.nb <- glmer.nb(NodeRank ~ QuestionOrder + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg.CS, verbose=TRUE)

summary(graph.clickhd.nb)

graph.clickhd.nb.null2 <- update(graph.clickhd.nb, . ~ . - QuestionOrder)

anova(graph.clickhd.nb, graph.clickhd.nb.null2)

# QuestionOrder is not significant


#graph.clickhd.nb <- glmer.nb(NodeRank ~ CorrectAnswer + (1|Demo.ResponseID), data=graphics_clickhighdeg, verbose=TRUE)

# error about rescaling

graphics_clickhighdeg.CS <- graphics_clickhighdeg %>% mutate(CorrectAnswer=scale(CorrectAnswer))

graph.clickhd.nb.correct <- glmer.nb(NodeRank ~ CorrectAnswer + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg.CS, verbose=TRUE)

summary(graph.clickhd.nb.correct)

graph.clickhd.nb.null2 <- update(graph.clickhd.nb.correct, . ~ . - CorrectAnswer)

anova(graph.clickhd.nb.correct, graph.clickhd.nb.null2)

# CorrectAnswer is significant (p=4.931e-13)

#graph.clickhd.nb <- glmer.nb(NodeRank ~ Stats.Q_TotalDuration + (1|Demo.ResponseID), data=graphics_clickhighdeg, verbose=TRUE)

# warnings about rescaling variables

graphics_clickhighdeg.CS <- graphics_clickhighdeg %>% mutate(Stats.Q_TotalDuration=scale(Stats.Q_TotalDuration))

graph.clickhd.nb <- glmer.nb(NodeRank ~ Stats.Q_TotalDuration + (1|Demo.ResponseID), data=graphics_clickhighdeg.CS, verbose=TRUE, control=glmerControl(optimizer = "nlminbw"))

summary(graph.clickhd.nb)

graph.clickhd.nb.null2 <- update(graph.clickhd.nb, . ~ . - Stats.Q_TotalDuration)

anova(graph.clickhd.nb, graph.clickhd.nb.null2)

# Stats.Q_TotalDuration is not significant


graph.clickhd.nb <- glmer.nb(NodeRank ~ Stats.OperatingSystem + (1|Demo.ResponseID), data=graphics_clickhighdeg, verbose=TRUE, control=glmerControl(optimizer = "bobyqa"))
# very slooooooow, but no errors

summary(graph.clickhd.nb) # nothing significant

anova(graph.clickhd.nb, graph.clickhd.nb.null)

# Stats.OperatingSystems is not significant

graph.clickhd.nb <- glmer.nb(NodeRank ~ Stats.OperatingSystemCombined + (1|Demo.ResponseID), data=graphics_clickhighdeg, verbose=TRUE, control=glmerControl(optimizer = "bobyqa"))

summary(graph.clickhd.nb) # nothing significant

anova(graph.clickhd.nb, graph.clickhd.nb.null)

# Stats.OperatingSystemCombined is not significant

graph.clickhd.nb <- glmer.nb(NodeRank ~ Stats.OperatingSystemCombined2 + (1|Demo.ResponseID), data=graphics_clickhighdeg, verbose=TRUE, control=glmerControl(optimizer = "bobyqa"))

summary(graph.clickhd.nb)

anova(graph.clickhd.nb, graph.clickhd.nb.null)

# Stats.OperatingSystemCombined2 is not significant

graph.clickhd.nb <- glmer.nb(NodeRank ~ Stats.OperatingSystemCombined3 + (1|Demo.ResponseID), data=graphics_clickhighdeg, verbose=TRUE, control=glmerControl(optimizer = "bobyqa"))

summary(graph.clickhd.nb)

anova(graph.clickhd.nb, graph.clickhd.nb.null)

# Stats.OperatingSystemCombined3 is not significant

graph.clickhd.nb <- glmer.nb(NodeRank ~ Stats.OperatingSystemCombined4 + (1|Demo.ResponseID), data=graphics_clickhighdeg, verbose=TRUE, control=glmerControl(optimizer = "bobyqa"))

summary(graph.clickhd.nb)

anova(graph.clickhd.nb, graph.clickhd.nb.null)

# Stats.OperatingSystemCombined4 is not significant

graph.clickhd.nb <- glmer.nb(NodeRank ~ Stats.OperatingSystemCombined5 + (1|Demo.ResponseID), data=graphics_clickhighdeg, verbose=TRUE, control=glmerControl(optimizer = "bobyqa"))

summary(graph.clickhd.nb)

anova(graph.clickhd.nb, graph.clickhd.nb.null)

# Stats.OperatingSystemCombined5 is not significant

graph.clickhd.nb <- glmer.nb(NodeRank ~ Stats.OperatingSystemWindows + (1|Demo.ResponseID), data=graphics_clickhighdeg, verbose=TRUE, control=glmerControl(optimizer = "bobyqa"))

summary(graph.clickhd.nb)

anova(graph.clickhd.nb, graph.clickhd.nb.null)

# Stats.OperatingSystemWindows is not significant

graph.clickhd.nb <- glmer.nb(NodeRank ~ Stats.OperatingSystemMacintosh + (1|Demo.ResponseID), data=graphics_clickhighdeg, verbose=TRUE, control=glmerControl(optimizer = "bobyqa"))

summary(graph.clickhd.nb)

anova(graph.clickhd.nb, graph.clickhd.nb.null)

# Stats.OperatingSystemMacintosh is not significant

graph.clickhd.nb <- glmer.nb(NodeRank ~ Stats.OperatingSystemAndroid + (1|Demo.ResponseID), data=graphics_clickhighdeg, verbose=TRUE, control=glmerControl(optimizer = "bobyqa"))

summary(graph.clickhd.nb)

anova(graph.clickhd.nb, graph.clickhd.nb.null)

# Stats.OperatingSystemAndroid is not significant

graph.clickhd.nb <- glmer.nb(NodeRank ~ Stats.OperatingSystemiPhone + (1|Demo.ResponseID), data=graphics_clickhighdeg, verbose=TRUE, control=glmerControl(optimizer = "bobyqa"))

summary(graph.clickhd.nb)

anova(graph.clickhd.nb, graph.clickhd.nb.null)

# Stats.OperatingSystemiPhone is not significant


#graph.clickhd.nb <- glmer.nb(NodeRank ~ StatsNumPixels + (1|Demo.ResponseID), data=graphics_clickhighdeg, verbose=TRUE)

# need to rescale

graphics_clickhighdeg.CS <- graphics_clickhighdeg %>% mutate(StatsNumPixels=scale(StatsNumPixels))

graph.clickhd.nb <- glmer.nb(NodeRank ~ StatsNumPixels + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg.CS, verbose=TRUE, 
                        control=glmerControl(optimizer = "nlminbw"))

summary(graph.clickhd.nb)

graph.clickhd.nb.null2 <- update(graph.clickhd.nb, . ~ . - StatsNumPixels)

anova(graph.clickhd.nb, graph.clickhd.nb.null2)

# StatsNumPixels not significant

#graph.clickhd.nb <- glmer.nb(NodeRank ~ Demo.age + (1|Demo.ResponseID), data=graphics_clickhighdeg %>% filter(!is.na(Demo.age)), verbose=TRUE)

# need to rescale

graphics_clickhighdeg.CS <- graphics_clickhighdeg %>% mutate(Demo.age=scale(Demo.age))

graph.clickhd.nb <- glmer.nb(NodeRank ~ Demo.age + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg.CS %>% filter(!is.na(Demo.age)), verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))


summary(graph.clickhd.nb)

graph.clickhd.nb.null2 <- update(graph.clickhd.nb, . ~ . - Demo.age)

anova(graph.clickhd.nb, graph.clickhd.nb.null2)

# Demo.age is not significant

graph.clickhd.nb <- glmer.nb(NodeRank ~ Demo.gender + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg %>% filter(!is.na(Demo.gender)), verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))

summary(graph.clickhd.nb)

graph.clickhd.nb.null.2 <- update(graph.clickhd.nb, . ~ . - Demo.gender)

anova(graph.clickhd.nb, graph.clickhd.nb.null.2)

# Demo.gender is not significant 

graph.clickhd.nb <- glmer.nb(NodeRank ~ Demo.lang + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg %>% filter(!is.na(Demo.lang)), verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))

summary(graph.clickhd.nb)

graph.clickhd.nb.null.2 <- update(graph.clickhd.nb, . ~ . - Demo.lang)

anova(graph.clickhd.nb, graph.clickhd.nb.null.2)

# Demo.lang is not a significant predictor

graph.clickhd.nb <- glmer.nb(NodeRank ~ Demo.educ + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg %>% filter(!is.na(Demo.educ)), verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))

summary(graph.clickhd.nb)

graph.clickhd.nb.null.2 <- update(graph.clickhd.nb, . ~ . - Demo.educ)

anova(graph.clickhd.nb, graph.clickhd.nb.null.2)

# Demo.educ is not significant

graph.clickhd.nb <- glmer.nb(NodeRank ~ Demo.acfield + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg %>% filter(!is.na(Demo.acfield)), verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))
# tons of categories, very slow

summary(graph.clickhd.nb)

# many categories significantly different from Anthropology:
# ***: Business
# **: Arts, Computer sciences, Economics, Information science, Law, Linguistics, 
#     Medicine, Other, Political science, Skipped, Sociology
# *: Architecture and design, Biology, Education, Engineering, History, Journalism, 
#    media studies and communication, Languages, Library and museum studies, Literature, 
#    Mathematics, Philosophy, Psychology, Public administration

graph.clickhd.nb.null.2 <- update(graph.clickhd.nb, . ~ . - Demo.acfield)

anova(graph.clickhd.nb, graph.clickhd.nb.null.2)

# not significant

graph.clickhd.nb <- glmer.nb(NodeRank ~ Demo.acfieldGrouped + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg %>% filter(!is.na(Demo.acfieldGrouped)), verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))

summary(graph.clickhd.nb)

graph.clickhd.nb.null.2 <- update(graph.clickhd.nb, . ~ . - Demo.acfieldGrouped)

anova(graph.clickhd.nb, graph.clickhd.nb.null.2)

# Demo.acfieldGrouped is not significant

graph.clickhd.nb <- glmer.nb(NodeRank ~ Demo.acfieldGrouped2 + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg %>% filter(!is.na(Demo.acfieldGrouped2)), verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))

summary(graph.clickhd.nb)

graph.clickhd.nb.null.2 <- update(graph.clickhd.nb, . ~ . - Demo.acfieldGrouped2)

anova(graph.clickhd.nb, graph.clickhd.nb.null.2)

# Demo.acfieldGrouped2 is not significant

graph.clickhd.nb.acfield3 <- glmer.nb(NodeRank ~ Demo.acfieldGrouped3 + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg %>% filter(!is.na(Demo.acfieldGrouped3)), verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))

summary(graph.clickhd.nb.acfield3)

graph.clickhd.nb.null.2 <- update(graph.clickhd.nb.acfield3, . ~ . - Demo.acfieldGrouped3)

anova(graph.clickhd.nb.acfield3, graph.clickhd.nb.null.2)

# Demo.acfieldGrouped3 (made up of ** and *** fields from clickhd.nb - Demo.acfield) is significant

graph.clickhd.nb <- glmer.nb(NodeRank ~ Demo.dailytech_Computer + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg %>% filter(!is.na(Demo.dailytech_Computer)), verbose=TRUE)

summary(graph.clickhd.nb)

# almost significant

graph.clickhd.nb.null.2 <- update(graph.clickhd.nb, . ~ . - Demo.dailytech_Computer)

anova(graph.clickhd.nb, graph.clickhd.nb.null.2)

# not significant

graph.clickhd.nb <- glmer.nb(NodeRank ~ Demo.dailytech_Tablet + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg %>% filter(!is.na(Demo.dailytech_Tablet)), verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))

summary(graph.clickhd.nb)

graph.clickhd.nb.null.2 <- update(graph.clickhd.nb, . ~ . - Demo.dailytech_Tablet)

anova(graph.clickhd.nb, graph.clickhd.nb.null.2)

# almost significant (p=0.06001)

graph.clickhd.nb.SP <- glmer.nb(NodeRank ~ Demo.dailytech_SmartPhone + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg %>% filter(!is.na(Demo.dailytech_SmartPhone)), verbose=TRUE)

summary(graph.clickhd.nb.SP)

graph.clickhd.nb.null.2 <- update(graph.clickhd.nb.SP, . ~ . - Demo.dailytech_SmartPhone)

anova(graph.clickhd.nb.SP, graph.clickhd.nb.null.2)

# significant (p = 0.008337)

graph.clickhd.nb <- glmer.nb(NodeRank ~ Demo.weeklygaming + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg %>% filter(!is.na(Demo.weeklygaming)), verbose=TRUE)

summary(graph.clickhd.nb)

graph.clickhd.nb.null.2 <- update(graph.clickhd.nb, . ~ . - Demo.weeklygaming)

anova(graph.clickhd.nb, graph.clickhd.nb.null.2)

# not significant

graph.clickhd.nb <- glmer.nb(NodeRank ~ Demo.expdataanal + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg %>% filter(!is.na(Demo.expdataanal)), verbose=TRUE)

summary(graph.clickhd.nb)

graph.clickhd.nb.null.2 <- update(graph.clickhd.nb, . ~ . - Demo.expdataanal)

anova(graph.clickhd.nb, graph.clickhd.nb.null.2)

# not significant

graph.clickhd.nb <- glmer.nb(NodeRank ~ Demo.expdatavis + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg %>% filter(!is.na(Demo.expdatavis)), verbose=TRUE)

summary(graph.clickhd.nb)

graph.clickhd.nb.null.2 <- update(graph.clickhd.nb, . ~ . - Demo.expdatavis)

anova(graph.clickhd.nb, graph.clickhd.nb.null.2)

# not significant

graph.clickhd.nb <- glmer.nb(NodeRank ~ Demo.expreadnetvis + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg %>% filter(!is.na(Demo.expreadnetvis)), verbose=TRUE)

summary(graph.clickhd.nb)

graph.clickhd.nb.null.2 <- update(graph.clickhd.nb, . ~ . - Demo.expreadnetvis)

anova(graph.clickhd.nb, graph.clickhd.nb.null.2)

# not significant

graph.clickhd.nb <- glmer.nb(NodeRank ~ Demo.expcreatenetvis + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg %>% filter(!is.na(Demo.expcreatenetvis)), verbose=TRUE)

summary(graph.clickhd.nb)

graph.clickhd.nb.null.2 <- update(graph.clickhd.nb, . ~ . - Demo.expcreatenetvis)

anova(graph.clickhd.nb, graph.clickhd.nb.null.2)

# not significant

graph.clickhd.nb.avgdeg <- glmer.nb(NodeRank ~ AvgDeg + (1|Demo.ResponseID), 
                               data=graphics_clickhighdeg, verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))

summary(graph.clickhd.nb.avgdeg)

anova(graph.clickhd.nb.avgdeg, graph.clickhd.nb.null)

# AvgDeg is marginally significant (p < 0.02327)

graph.clickhd.nb <- glmer.nb(NodeRank ~ Density + (1|Demo.ResponseID), 
                                data=graphics_clickhighdeg, verbose=TRUE)

summary(graph.clickhd.nb)

anova(graph.clickhd.nb, graph.clickhd.nb.null)

# Density is not significant

#graph.clickhd.nb.largeclust <- glmer.nb(NodeRank ~ LargeClust1 + (1|Demo.ResponseID), 
#                                   data=graphics_clickhighdeg, verbose=TRUE)

# need to rescale

graphics_clickhighdeg.CS <- graphics_clickhighdeg %>% mutate(LargeClust1=scale(LargeClust1))

graph.clickhd.nb <- glmer.nb(NodeRank ~ LargeClust1 + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg.CS, verbose=TRUE)

summary(graph.clickhd.nb)

graph.clickhd.nb.null.2 <- update(graph.clickhd.nb, . ~ . - LargeClust1)

anova(graph.clickhd.nb, graph.clickhd.nb.null.2)

# LargeClust1 is not significant

graph.clickhd.nb <- glmer.nb(NodeRank ~ Modularity + (1|Demo.ResponseID), 
                            data=graphics_clickhighdeg, verbose=TRUE)

summary(graph.clickhd.nb)

anova(graph.clickhd.nb, graph.clickhd.nb.null)

# Modularity is not significant

graph.clickhd.nb.numclust <- glmer.nb(NodeRank ~ NumClust + (1|Demo.ResponseID), 
                                 data=graphics_clickhighdeg, verbose=TRUE, 
                        control=glmerControl(optimizer = "bobyqa"))

summary(graph.clickhd.nb.numclust)

anova(graph.clickhd.nb.numclust, graph.clickhd.nb.null)

# NumClust is significant (p = 0.0008861)

#graph.clickhd.nb <- glmer.nb(NodeRank ~ NumHighDegree + (1|Demo.ResponseID), 
#                        data=graphics_clickhighdeg, verbose=TRUE)

# need to rescale

graphics_clickhighdeg.CS <- graphics_clickhighdeg %>% mutate(NumHighDegree=scale(NumHighDegree))

graph.clickhd.nb.numhighdeg <- glmer.nb(NodeRank ~ NumHighDegree + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg.CS, verbose=TRUE)

summary(graph.clickhd.nb.numhighdeg)

graph.clickhd.nb.null.2 <- update(graph.clickhd.nb.numhighdeg, . ~ . - NumHighDegree)

anova(graph.clickhd.nb.numhighdeg, graph.clickhd.nb.null.2)

# NumHighDegree is significant (p=4.931e-13)

#graph.clickhd.nb.numlinks <- glmer.nb(NodeRank ~ NumLinks + (1|Demo.ResponseID), 
#                                 data=graphics_clickhighdeg, verbose=TRUE)

# need to rescale

graphics_clickhighdeg.CS <- graphics_clickhighdeg %>% mutate(NumLinks=scale(NumLinks))

graph.clickhd.nb <- glmer.nb(NodeRank ~ NumLinks + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg.CS, verbose=TRUE)

summary(graph.clickhd.nb)

graph.clickhd.nb.null.2 <- update(graph.clickhd.nb, . ~ . - NumLinks)

anova(graph.clickhd.nb, graph.clickhd.nb.null.2)

# NumLinks is barely not significant (p=0.05679)

#graph.clickhd.nb.numnodes <- glmer.nb(NodeRank ~ NumNodes + (1|Demo.ResponseID), 
#                                 data=graphics_clickhighdeg, verbose=TRUE)

# need to rescale

graphics_clickhighdeg.CS <- graphics_clickhighdeg %>% mutate(NumNodes=scale(NumNodes))

graph.clickhd.nb <- glmer.nb(NodeRank ~ NumNodes + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg.CS, verbose=TRUE)

summary(graph.clickhd.nb)

graph.clickhd.nb.null.2 <- update(graph.clickhd.nb, . ~ . - NumNodes)

anova(graph.clickhd.nb, graph.clickhd.nb.null.2)

# NumNodes is barely not significant (p=0.07374)

#graph.clickhd.nb <- glmer.nb(NodeRank ~ NumNodesClust1 + (1|Demo.ResponseID), 
#                        data=graphics_clickhighdeg, verbose=TRUE)

# need to rescale

graphics_clickhighdeg.CS <- graphics_clickhighdeg %>% mutate(NumNodesClust1=scale(NumNodesClust1))

graph.clickhd.nb.numnodesclust1 <- glmer.nb(NodeRank ~ NumNodesClust1 + (1|Demo.ResponseID), 
                        data=graphics_clickhighdeg.CS, verbose=TRUE)

summary(graph.clickhd.nb.numnodesclust1)

graph.clickhd.nb.null.2 <- update(graph.clickhd.nb.numnodesclust1, . ~ . - NumNodesClust1)

anova(graph.clickhd.nb.numnodesclust1, graph.clickhd.nb.null.2)

# NumNodesClust1 is significant (p=0.008985)
```

```{r}

#---------------------------------
# Multiple predictors
#---------------------------------

temp <- graphics_clickhighdeg %>% dplyr::select(Demo.ResponseID, NodeRank, Dataset, CorrectAnswer, Demo.acfieldGrouped3, Demo.dailytech_SmartPhone, AvgDeg, NumClust, NumHighDegree, NumNodesClust1) %>% drop_na()

#temp <- temp %>% mutate(Stats.Q_TotalDuration=scale(Stats.Q_TotalDuration))

graph.clickhd.nb.full <- glmer.nb(NodeRank ~ Dataset +
                                    Demo.acfieldGrouped3 + Demo.dailytech_SmartPhone +
                                    (1|Demo.ResponseID),
                                  data=temp, verbose=TRUE,
                                  control=glmerControl(optimizer = "bobyqa"))

# not every dataset is significant; should i be combining? TO DO

summary(graph.clickhd.nb.full)
# still significant - Dataset, Demo.acfieldGrouped3, Demo.dailytech_SmartPhone
```

```{r, eval=FALSE}
#---------------------------------
# Interactions
#---------------------------------

graph.clickhd.nb.full.int <- glmer.nb(NodeRank ~ Dataset +
                                        Demo.acfieldGrouped3 + Demo.dailytech_SmartPhone +
                                        Demo.acfieldGrouped3:Demo.dailytech_SmartPhone +
                                        (1|Demo.ResponseID),
                                      data=temp, verbose=TRUE,
                                      control=glmerControl(optimizer = "bobyqa"))

summary(graph.clickhd.nb.full.int)

anova(graph.clickhd.nb.full, graph.clickhd.nb.full.int)

# no significant interactions

```


```{r}

#SAVE THE RESULTS
save(graph.clickhd.nb.full, file = file.path(analysisDataDir,"fits/graph_clickhd_nb_full.RData"))

```


```{r}

graph.clickhd.nb.full.f <- fortify(graph.clickhd.nb.full)

ggplot(graph.clickhd.nb.full.f, aes(.fitted,.resid)) + 
  geom_point() +
  geom_hline(yintercept=0)

ggplot(graph.clickhd.nb.full.f, aes(.resid)) +
  geom_histogram()

# not *quite* normally distributed...  but not too skewed?

ggplot(graph.clickhd.nb.full.f, aes(.fitted,NodeRank)) + 
  geom_point() +
  geom_hline(yintercept=0) +
  scale_y_log10()

ggplot(graph.clickhd.nb.full.f, aes(.fitted,NodeRank, color=Dataset)) + 
  geom_point() +
  geom_hline(yintercept=0) +
  scale_y_log10() +
  scale_color_brewer(palette = "Dark2")

ggplot(graph.clickhd.nb.full.f, aes(.fitted,NodeRank)) + 
  geom_point() +
  geom_hline(yintercept=0) +
  scale_y_log10() +
  facet_wrap(~Dataset)

(r2nsj = r2beta(graph.numhd.lmer.full.int.6, method = 'nsj', partial = TRUE))[1,'Rsq']

ggplot(graphics_clickhighdeg) + geom_histogram(aes(NodeRank), binwidth=1) +
labs(title="Distribution of NodeRank values for\nHighest Degree Node task, graphics conditions")

ggplot(graph.clickhd.nb.full.f, aes(NodeRank,.fitted)) +
geom_bin2d() +
geom_abline(aes(slope = 1, intercept = 0)) +
#scale_y_continuous(limits=c(0,0.3)) +
labs(title="Real vs. Predicted NodeRank values for\nHighest Degree Node task, graphics conditions")



```



```{r, eval=FALSE}

# is negative binomial different from poisson?  if so, indicates over-dispersion is true
# and negative binomial is necessary

graph.clickhd.pois <- glmer(NodeRank ~ Dataset + Demo.acfieldGrouped3 + Demo.dailytech_SmartPhone +
                                   (1|Demo.ResponseID), data=temp, family="poisson")

pchisq(2 * (logLik(graph.clickhd.nb.full) - logLik(graph.clickhd.pois)), df=1, lower.tail = FALSE)

# value = 2.926157e-08, so keep the negative binomial

```

```{r, eval=FALSE}
# run without mixed effects to validate

m.glm <- glm.nb(NodeRank ~ Dataset + Demo.acfieldGrouped3 + Demo.dailytech_SmartPhone, 
                data=temp, trace=TRUE)
summary(m.glm)

## The neg.binomial theta parameter:
getME(graph.clickhd.nb.full, "glmer.nb.theta")

#11.58727

## mixed model has 1 additional parameter (RE variance)
stopifnot(attr(logLik(graph.clickhd.nb.full),"df")==attr(logLik(m.glm),"df")+1) # not sure what this does

anova(graph.clickhd.nb.full,m.glm) # can I use anova to compare mixed and fixed effects?
# p < 5.213e-09, so definitely random effects

plot(graph.clickhd.nb.full, resid(.) ~ NodeRank)# works, as long as data 'dd' is found


# TO DO : check if this is all right

```

```{r, eval=FALSE}

par(mfrow=c(2,2))
qqnorm(resid(graph.clickhd.nb.full), main="normal qq-plot, residuals")
qqline(resid(graph.clickhd.nb.full))

qqnorm(ranef(graph.clickhd.nb.full)$Demo.ResponseID[,1])
qqline(ranef(graph.clickhd.nb.full)$Demo.ResponseID[,1])


plot(fitted(graph.clickhd.nb.full), resid(graph.clickhd.nb.full)) #residuals vs fitted
abline(h=0)

#graph.avgdeg.nb2.f <- fortify(graph.avgdeg.nb2)

#ggplot(graph.avgdeg.nb2.f, aes(.fitted,.resid)) + 
#  geom_point() +
#  geom_hline(yintercept=0)

#temp <- graphics_avgdeg

temp$fitted <- fitted(graph.clickhd.nb.full) 
plot(temp$fitted, jitter(temp$NodeRank,0.1)) #fitted vs observed
abline(0,1)

#ggplot(graph.avgdeg.nb2.f, aes(.fitted,Response)) + 
#  geom_point() +
#  geom_abline(aes(slope = 1, intercept = 0))


```

```{r, cache=TRUE, eval=FALSE}

# Confidence Intervals, using coefficients

(est <- cbind(Estimate = coef(graph.avgdeg.nb.full.int), confint(graph.avgdeg.nb.full.int)))

# exponentiate model to look at incident rate ratios instead of coefficients

exp(est)

```

```{r, eval=FALSE}

# predictions

# model: Response ~ Dataset + TaskOrder + Demo.dailytech_SmartPhone + Dataset:TaskOrder + TaskOrder:Demo.dailytech_SmartPhone + Dataset:Demo.dailytech_SmartPhone + (1 | Demo.ResponseID)

newdata1 <- data.frame(Demo.dailytech_SmartPhone = rep(mean(temp$Demo.dailytech_SmartPhone),54), 
                       Dataset = factor(rep(c(1,3,5,7,8,9),9), levels = levels(temp$Dataset),ordered = TRUE),
                       TaskOrder = rep(1:9,6),
                       Demo.ResponseID = sample(temp$Demo.ResponseID,54))
newdata1$phat <- predict(graph.avgdeg.nb.full.int, newdata1, type = "response")
#newdata1

newdata2 <- data.frame(
  Demo.dailytech_SmartPhone = rep(seq(from = min(temp$Demo.dailytech_SmartPhone), to = max(temp$Demo.dailytech_SmartPhone), length.out = 100), 6),
  Dataset = factor(rep(c(1,3,5,7,8,9), each = 100), levels = levels(temp$Dataset),ordered = TRUE),
  TaskOrder = rep(1:9,len=600),
  Demo.ResponseID = sample(temp$Demo.ResponseID,600)
  )

#predict(graph.avgdeg.nb.full.int, newdata2, type = "link", se.fit=TRUE)
newdata2 <- cbind(newdata2, predict(graph.avgdeg.nb.full.int, newdata2, type = "link", se.fit=TRUE))

# not sure about this; asking for "fit", but that's not recognized. should the new column be called "fit"? what about se.fit?

#newdata2 <- within(newdata2, {
#  Response <- exp(fit)
#  LL <- exp(fit - 1.96 * se.fit)
#  UL <- exp(fit + 1.96 * se.fit)
#})

#ggplot(newdata2, aes(math, DaysAbsent)) +
#  geom_ribbon(aes(ymin = LL, ymax = UL, fill = prog), alpha = .25) +
#  geom_line(aes(colour = prog), size = 2) +
#  labs(x = "Math Score", y = "Predicted Days Absent")

# note on negative binomial:

# TO DO : If the data generating process does not allow for any 0s (such as the number of days spent in the hospital), then a zero-truncated model may be more appropriate.

# TO DO : Count data often have an exposure variable, which indicates the number of times the event could have happened (i.e. a max). This variable should be incorporated into your negative binomial regression model with the use of the offset option. See the glm documentation for details.  (so, that would make sense for click data???)

# other info:
# Cameron, A. C. and Trivedi, P. K. 1998. Regression Analysis of Count Data. New York: Cambridge Press.
# Dupont, W. D. 2002. Statistical Modeling for Biomedical Researchers: A Simple Introduction to the Analysis of Complex Data. New York: Cambridge Press.

```



#### Least Squares

Full model (graph.clickhd.nb.full):
NodeRank ~ Dataset + Demo.acfieldGrouped3 + Demo.dailytech_SmartPhone + (1|Demo.ResponseID)

##### Dataset

###### broom

```{r}

graph.clickhd.broom.tidy <- tidy(graph.clickhd.nb.full, conf.int=TRUE)
graph.clickhd.broom.aug <- augment(graph.clickhd.nb.full, temp)
graph.clickhd.broom.ci <- confint_tidy(graph.clickhd.nb.full)
graph.clickhd.broom.tidyci <- bind_cols(graph.clickhd.broom.tidy %>% arrange(group), graph.clickhd.broom.ci)

graph.clickhd.broom.tidyci$term <- factor(graph.clickhd.broom.tidyci$term,
                                          levels=graph.clickhd.broom.tidyci %>% arrange(estimate) %>%
                                            select(term) %>% unlist())

ggplot(graph.clickhd.broom.tidyci, aes(term, estimate)) + 
  geom_point() + 
  coord_flip()

ggplot(graph.clickhd.broom.aug %>% group_by(Dataset) %>% summarize(est=mean(.fitted))) +
  geom_point(aes(Dataset,est)) +
  scale_y_continuous(limits = c(-.06,1.2), breaks=c(0,.3,.6,.9,1.2)) +
  coord_flip()

plot(emmeans(graph.clickhd.nb.full, "Dataset"))

ggplot(graph.clickhd.broom.aug) +
  geom_violin(aes(Dataset,.fitted)) +
  scale_y_continuous(limits = c(-.06,1.2), breaks=c(0,.3,.6,.9,1.2)) +
  coord_flip()


```

###### emmeans

```{r}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numhighdeg, table(Dataset,Overestimated))
# ref_grid(graph.numhd.lmer.full.int.4) @ grid; .wgt. is number of observations

graph.clickhd.emm.data <- emmeans(graph.clickhd.nb.full, "Dataset", nesting = NULL)
#graph.numhd.emm.condition <- emmeans(graph.numhd.lmer.full.int.4, "Condition", lmer.df = "satterthwaite")

graph.clickhd.emm.data

graph.clickhd.emm.data.df <- dplyr::as_data_frame(graph.clickhd.emm.data)

graph.clickhd.emm.data.df


# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numhd.emm.condition)

graph.clickhd.emm.data.cld <- cld(graph.clickhd.emm.data,
                details=TRUE,
                #alpha=0.01,
                #by="Dataset",
                #Letters="|||||||||||||||||||",
                sort=TRUE
)

graph.clickhd.emm.data.cld.df <- graph.clickhd.emm.data.cld$emmeans

graph.clickhd.emm.data.cld.df %>% dplyr::select(Dataset,.group)

graph.clickhd.emm.data.cld.df

graph.clickhd.emm.data.cld.df$Dataset <- factor(graph.clickhd.emm.data.cld.df$Dataset, levels=graph.clickhd.emm.data.cld.df %>% arrange(desc(emmean)) %>% dplyr::select(Dataset) %>% unlist())


#emmip(graph.numlinks.lmer.full.int, ~Condition, CIs = TRUE)
emmip(graph.clickhd.emm.data, ~Dataset, CIs = TRUE)
plot(graph.clickhd.emm.data)
#plot(graph.numlinks.emm.cond, comparisons = TRUE)

graph.clickhd.emm.data.cld.df %>% arrange(desc(emmean))

ggplot(graph.clickhd.emm.data.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Dataset,ymax=asymp.UCL,ymin=asymp.LCL), width=.2) +
  geom_point(aes(x=Dataset,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.clickhd.emm.data.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Dataset,ymax=asymp.UCL,ymin=asymp.LCL), width=.2) +
  geom_point(aes(x=Dataset,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip() +
labs(title="Estimated Marginal Means for Dataset for\nHighest Degree Node task, graphics conditions")

#plot(ref_grid(graph.numnodes.lmer.int.3), by="Condition") 
# try to figure this out? maybe only works on the interaction?
```

```{r}

graph.clickhd.emm.data.pairs <- dplyr::as_data_frame(pairs(graph.clickhd.emm.data)) 
graph.clickhd.emm.data.pairs
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

pairs.CI <- confint(pairs(graph.clickhd.emm.data))

graph.clickhd.emm.data.pairs <- full_join(graph.clickhd.emm.data.pairs, pairs.CI)

#graph.numhd.diffemm.condition <- emmeans(graph.numhd.lmer.full.int.4, pairwise ~ Condition)
#graph.numhd.diffemm.condition$contrasts
#contrast(graph.numhd.emm.condition)
#confint(graph.numhd.emm.condition)
#pairs(graph.numhd.emm.condition, details=TRUE)
#confint(contrast(graph.numhd.emm.condition))
#confint(pairs(graph.numhd.emm.condition))
#coef(pairs(graph.numhd.emm.condition))


plot(pairs(graph.clickhd.emm.data))
plot(pairs(graph.clickhd.emm.data), comparisons = TRUE)

graph.clickhd.emm.data.pairs$sig.levels <- 
  case_when(graph.clickhd.emm.data.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.clickhd.emm.data.pairs$p.value < .001 ~ sig.level.names[2],
            graph.clickhd.emm.data.pairs$p.value < .01 ~ sig.level.names[3],
            graph.clickhd.emm.data.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.clickhd.emm.data.pairs$sig.levels <- factor(graph.clickhd.emm.data.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)


graph.clickhd.emm.data.pairs$contrast <- factor(graph.clickhd.emm.data.pairs$contrast, levels=graph.clickhd.emm.data.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())

graph.clickhd.emm.data.pairs <- graph.clickhd.emm.data.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.clickhd.emm.data.pairs %>% arrange(estimate)

ggplot(graph.clickhd.emm.data.pairs) +
  geom_errorbar(aes(x=contrast,ymax=asymp.UCL,ymin=asymp.LCL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.clickhd.emm.data.pairs) +
  geom_errorbar(aes(x=contrast,ymax=asymp.UCL,ymin=asymp.LCL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

```

```{r}

#cond.lev <- c("Ctrl","Phr","Col","Siz")


copy <- graph.clickhd.emm.data.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         z.ratio=-z.ratio,
         asymp.LCL=-asymp.LCL,
         asymp.UCL=-asymp.UCL)

graph.clickhd.emm.data.pairs.compl <- bind_rows(graph.clickhd.emm.data.pairs, copy)

copy$From <- factor(copy$From, levels=rev(unique(copy$From)))
#graph.bc.emm.data.pairs$To <- factor(graph.bc.emm.data.pairs$To, levels=cond.lev)
#graph.bc.emm.data.pairs$From <- factor(graph.bc.emm.data.pairs$From, levels=rev(cond.lev))

highest<-max(abs(copy$estimate))

ggplot(copy, aes(x=To,y=From)) +
  geom_tile(aes(fill=estimate)) +
  geom_text(aes(label=paste0(format(estimate, digits=2, nsmall=2),"\n(",sig.levels,")"))) +
    scale_fill_distiller(type="div", palette=4, limits=c(-highest,highest)) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")


```

```{r}

graph.clickhd.emm.data.pairs.compl$From <- factor(graph.clickhd.emm.data.pairs.compl$From, levels=rev(unique(graph.clickhd.emm.data.pairs.compl$From)))
#graph.bc.emm.data.pairs.compl$To <- factor(graph.bc.emm.data.pairs.compl$To, levels=cond.lev)
#graph.bc.emm.data.pairs.compl$From <- factor(graph.bc.emm.data.pairs.compl$From, levels=rev(cond.lev))


#graph.numlinks.emm.cond.pairs.compl %>% arrange(desc(estimate))
graph.clickhd.emm.data.pairs.compl %>% arrange(estimate)

ggplot(graph.clickhd.emm.data.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.clickhd.emm.data.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.clickhd.emm.data.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
    scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.clickhd.emm.data.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")


```

###### networks

```{r, eval=FALSE}

# try a network of the pairwise significance values?  bleh...
# using igraph

graph <- graph_from_data_frame(graph.clickhd.emm.data.pairs %>% dplyr::select(-contrast), directed=TRUE)

E(graph)$width <- abs(E(graph)$estimate)*10
E(graph)$edge.color <- sig.colors[E(graph)$sig.levels]

graph

plot(graph, 
     edge.arrow.size=.5,
     vertex.frame.color="#555555")

```

```{r, eval=FALSE}

# using ggraph and tidygraph

graph <- graph_from_data_frame(graph.clickhd.emm.data.pairs %>% dplyr::select(-contrast) %>% filter(sig.levels != "NS"), directed=TRUE)

# plot using ggraph
ggraph(graph, layout = 'kk') +
  geom_edge_link(aes(start_cap = label_rect(node1.name),
                       end_cap = label_rect(node2.name),
                     color=factor(sig.level.names[sig.levels]),
                     edge_width=.5/sig.levels
                     ), 
                   arrow = arrow(length = unit(4, 'mm')))+
  geom_node_text(label = vertex_attr(graph,"name")) +
  #scale_edge_color_manual("Significance Levels", values=sig.colors) +
  #scale_edge_width_continuous(labels=rev(sig.level.names)) +
  theme_graph()

```





##### Demo.acfieldGrouped3

###### emmeans

```{r}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numhighdeg, table(Dataset,Overestimated))
# ref_grid(graph.numhd.lmer.full.int.4) @ grid; .wgt. is number of observations

graph.bc.emm.acfield3 <- emmeans(graph.clickhd.nb.full, "Demo.acfieldGrouped3", nesting = NULL)
#graph.numhd.emm.condition <- emmeans(graph.numhd.lmer.full.int.4, "Condition", lmer.df = "satterthwaite")

graph.bc.emm.acfield3

graph.bc.emm.acfield3.df <- dplyr::as_data_frame(graph.bc.emm.acfield3)

graph.bc.emm.acfield3.df


# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numhd.emm.condition)

graph.bc.emm.acfield3.cld <- cld(graph.bc.emm.acfield3,
                details=TRUE,
                #alpha=0.01,
                #by="Dataset",
                #Letters="|||||||||||||||||||",
                sort=TRUE
)

graph.bc.emm.acfield3.cld.df <- graph.bc.emm.acfield3.cld$emmeans

graph.bc.emm.acfield3.cld.df %>% dplyr::select(Demo.acfieldGrouped3,.group)

graph.bc.emm.acfield3.cld.df

graph.bc.emm.acfield3.cld.df$Demo.acfieldGrouped3 <- factor(graph.bc.emm.acfield3.cld.df$Demo.acfieldGrouped3, levels=graph.bc.emm.acfield3.cld.df %>% arrange(desc(emmean)) %>% dplyr::select(Demo.acfieldGrouped3) %>% unlist())


#emmip(graph.numlinks.lmer.full.int, ~Condition, CIs = TRUE)
emmip(graph.bc.emm.acfield3, ~Demo.acfieldGrouped3, CIs = TRUE)
plot(graph.bc.emm.acfield3)
#plot(graph.numlinks.emm.cond, comparisons = TRUE)

graph.bc.emm.acfield3.cld.df %>% arrange(desc(emmean))

ggplot(graph.bc.emm.acfield3.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Demo.acfieldGrouped3,ymax=asymp.UCL,ymin=asymp.LCL), width=.2) +
  geom_point(aes(x=Demo.acfieldGrouped3,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.bc.emm.acfield3.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Demo.acfieldGrouped3,ymax=asymp.UCL,ymin=asymp.LCL), width=.2) +
  geom_point(aes(x=Demo.acfieldGrouped3,y=emmean), size=7) +
  scale_x_discrete(labels=c("High Error Group","Low Error Group"),name="Academic Field") +
  coord_flip() +
labs(title="Estimated Marginal Means for Academic Field for\nHighest Degree Node task, graphics conditions")


#plot(ref_grid(graph.numnodes.lmer.int.3), by="Condition") 
# try to figure this out? maybe only works on the interaction?
```

```{r}

graph.bc.emm.acfield3.pairs <- dplyr::as_data_frame(pairs(graph.bc.emm.acfield3)) 
graph.bc.emm.acfield3.pairs
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

pairs.CI <- confint(pairs(graph.bc.emm.acfield3))

graph.bc.emm.acfield3.pairs <- full_join(graph.bc.emm.acfield3.pairs, pairs.CI)

#graph.numhd.diffemm.condition <- emmeans(graph.numhd.lmer.full.int.4, pairwise ~ Condition)
#graph.numhd.diffemm.condition$contrasts
#contrast(graph.numhd.emm.condition)
#confint(graph.numhd.emm.condition)
#pairs(graph.numhd.emm.condition, details=TRUE)
#confint(contrast(graph.numhd.emm.condition))
#confint(pairs(graph.numhd.emm.condition))
#coef(pairs(graph.numhd.emm.condition))


plot(pairs(graph.bc.emm.acfield3))
#plot(pairs(graph.bc.emm.acfield2), comparisons = TRUE)

graph.bc.emm.acfield3.pairs$sig.levels <- 
  case_when(graph.bc.emm.acfield3.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.bc.emm.acfield3.pairs$p.value < .001 ~ sig.level.names[2],
            graph.bc.emm.acfield3.pairs$p.value < .01 ~ sig.level.names[3],
            graph.bc.emm.acfield3.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.bc.emm.acfield3.pairs$sig.levels <- factor(graph.bc.emm.acfield3.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)


graph.bc.emm.acfield3.pairs$contrast <- factor(graph.bc.emm.acfield3.pairs$contrast, levels=graph.bc.emm.acfield3.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())

graph.bc.emm.acfield3.pairs <- graph.bc.emm.acfield3.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.bc.emm.acfield3.pairs %>% arrange(estimate)

ggplot(graph.bc.emm.acfield3.pairs) +
  geom_errorbar(aes(x=contrast,ymax=asymp.UCL,ymin=asymp.LCL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.bc.emm.acfield3.pairs) +
  geom_errorbar(aes(x=contrast,ymax=asymp.UCL,ymin=asymp.LCL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

```

```{r}

#cond.lev <- c("Ctrl","Phr","Col","Siz")


copy <- graph.bc.emm.acfield3.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         z.ratio=-z.ratio,
         asymp.LCL=-asymp.LCL,
         asymp.UCL=-asymp.UCL)

graph.bc.emm.acfield3.pairs.compl <- bind_rows(graph.bc.emm.acfield3.pairs, copy)

copy$From <- factor(copy$From, levels=rev(unique(copy$From)))
#graph.bc.emm.data.pairs$To <- factor(graph.bc.emm.data.pairs$To, levels=cond.lev)
#graph.bc.emm.data.pairs$From <- factor(graph.bc.emm.data.pairs$From, levels=rev(cond.lev))

highest<-max(abs(copy$estimate))

ggplot(copy, aes(x=To,y=From)) +
  geom_tile(aes(fill=estimate)) +
  geom_text(aes(label=paste0(format(estimate, digits=2, nsmall=2),"\n(",sig.levels,")"))) +
    scale_fill_distiller(type="div", palette=4, limits=c(-highest,highest)) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")


```

```{r}

graph.bc.emm.acfield3.pairs.compl$From <- factor(graph.bc.emm.acfield3.pairs.compl$From, levels=rev(unique(graph.bc.emm.acfield3.pairs.compl$From)))
#graph.bc.emm.data.pairs.compl$To <- factor(graph.bc.emm.data.pairs.compl$To, levels=cond.lev)
#graph.bc.emm.data.pairs.compl$From <- factor(graph.bc.emm.data.pairs.compl$From, levels=rev(cond.lev))


#graph.numlinks.emm.cond.pairs.compl %>% arrange(desc(estimate))
graph.bc.emm.acfield3.pairs.compl %>% arrange(estimate)

ggplot(graph.bc.emm.acfield3.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.bc.emm.acfield3.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.bc.emm.acfield3.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
    scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.bc.emm.acfield3.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")


```

###### networks

```{r, eval=FALSE}

# try a network of the pairwise significance values?  bleh...
# using igraph

graph <- graph_from_data_frame(graph.bc.emm.acfield3.pairs %>% dplyr::select(-contrast), directed=TRUE)

E(graph)$width <- abs(E(graph)$estimate)*10
E(graph)$edge.color <- sig.colors[E(graph)$sig.levels]

graph

plot(graph, 
     edge.arrow.size=.5,
     vertex.frame.color="#555555")

```

```{r, eval=FALSE}

# using ggraph and tidygraph

graph <- graph_from_data_frame(graph.bc.emm.acfield3.pairs %>% dplyr::select(-contrast) %>% filter(sig.levels != "NS"), directed=TRUE)

# plot using ggraph
ggraph(graph, layout = 'kk') +
  geom_edge_link(aes(start_cap = label_rect(node1.name),
                       end_cap = label_rect(node2.name),
                     color=factor(sig.level.names[sig.levels]),
                     edge_width=.5/sig.levels
                     ), 
                   arrow = arrow(length = unit(4, 'mm')))+
  geom_node_text(label = vertex_attr(graph,"name")) +
  #scale_edge_color_manual("Significance Levels", values=sig.colors) +
  #scale_edge_width_continuous(labels=rev(sig.level.names)) +
  theme_graph()

```







##### Demo.dailytech_SmartPhone

```{r}

ggplot(graphics_clickhighdeg, aes(Demo.dailytech_SmartPhone, NodeRank)) +
  geom_bin2d() +
  geom_smooth(method="lm") +
  labs(title="Smart Phone Usage vs. NodeRank for\nHighest Degree Node task, graphics conditions",
x="Average Daily Time Using Smart Phone (hours)")


```

### Percentage of Nodes in Largest Cluster

#### Beta regression for percentage


See also: http://rcompanion.org/handbook/J_02.html

```{r}


#graphics_lgclust.2 <- graphics_lgclust %>% mutate(ResponsePct = (Response-.001)/100)
graphics_lgclust.2 <- graphics_lgclust %>% mutate(ResponseInfl = Response/100,
                                                  ResponsePct = (Response+0.00000001)/100.01)
# should give a min of .00001 and a max of .99999
```


```{r}

temp <- graphics_lgclust %>% dplyr::select(Demo.ResponseID, Response, Condition, Dataset, DatasetOrder, DatasetStartTime, TaskOrder, CorrectAnswer, Underestimated, Stats.Q_TotalDuration, Stats.OperatingSystem, Demo.age, Demo.gender, Demo.lang, Demo.educ, Demo.acfield, Demo.dailytech_Computer, Demo.dailytech_Tablet, Demo.dailytech_SmartPhone, Demo.weeklygaming, Demo.expdataanal, Demo.expdatavis, Demo.expreadnetvis, Demo.expcreatenetvis, StatsNumPixels, AvgDeg, Density, LargeClust1, Modularity, NumClust, NumHighDegree, NumLinks, NumNodes, NumNodesClust1, ConditionPhrasing, ConditionGraphics, ConditionColor, Ctrl_dummy, Demo.expreadnetvis.alot, Demo.expcreatenetvis.alot, Stats.OperatingSystemCombined, Stats.OperatingSystemCombined2, Stats.OperatingSystemCombined3, Stats.OperatingSystemCombined4, Stats.OperatingSystemCombined5, Stats.OperatingSystemWindows, Stats.OperatingSystemMacintosh, Stats.OperatingSystemAndroid, Stats.OperatingSystemiPhone, Stats.OperatingSystemNumClust, Demo.acfieldGrouped, Demo.acfieldGrouped2, Demo.acfieldGrouped3, Overestimated, UnderestDummy, DatasetDuration) %>% drop_na() %>% mutate(ResponsePct = Response/100, StatsNumPixels=scale(StatsNumPixels))

```

##### brms/tidybayes

```{r, eval=FALSE}

#library(rstan)

theme_set(theme_grey())

#fit <- brm(ResponseInfl~Dataset, data = graphics_lgclust.2, family = zero_one_inflated_beta())
#fit <- brm(bf(ResponseInfl ~ Dataset + UnderestDummy + Demo.gender + 
#    Demo.lang + Demo.expreadnetvis + Stats.OperatingSystemWindows + 
#    Dataset:UnderestDummy + Demo.gender:Stats.OperatingSystemWindows + 
#    UnderestDummy:Demo.gender + UnderestDummy:Stats.OperatingSystemWindows, 
#    sigma ~ Dataset + UnderestDummy), data = graphics_lgclust.2, family = zero_one_inflated_beta())

#compose_data(graphics_lgclust.2)

# THIS WAS RUN
#fit <- brm(bf(ResponseInfl ~ Dataset + UnderestDummy + Demo.gender + 
#    Demo.lang + Demo.expreadnetvis + Stats.OperatingSystemWindows + 
#    Dataset:UnderestDummy + Demo.gender:Stats.OperatingSystemWindows + 
#    UnderestDummy:Demo.gender + UnderestDummy:Stats.OperatingSystemWindows), 
#    data = graphics_lgclust.2, family = zero_one_inflated_beta())

#fit2 <- update(fit, formula = . ~ . + (1 | Demo.ResponseID), newdata=graphics_lgclust.2)

LOO(fit, fit2)

# fit2 has lower LOOIC (1646.85 < 1620.62), which is good

fit2$formula

#fixed_form <- brms:::extract_effects(fit$formula)$fixed
#mm <- brms:::get_model_matrix(fixed_form, data = fit$data) 

coef(fit2)
fixef(fit2)
fixef(fit2, robust=TRUE)
fitted(fit2)
tidy(fit2)


fit2 %<>% recover_types(graphics_lgclust.2)

#print(fit2, pars = c("b_Intercept"))

#str(extract(fit2))

summary(fit2, waic = TRUE) 

```

```{r}

#plot(fit, ask=FALSE) 
#plot(marginal_effects(fit, probs = c(0.05, 0.95)),points=TRUE, ask=FALSE)
#plot(marginal_effects(fit, probs = c(0.05, 0.95)),ask=FALSE)
plot(marginal_effects(fit, effects="Dataset", probs = c(0.05, 0.95)),ask=FALSE)

```

```{r, eval=FALSE}
#fit.df <- tidy(fit2)

# diff between each dataset and dataset 1
hyp.vs.1 <- c("Dataset.L = 0", 
         "Dataset.Q = 0",
         "Dataset.C = 0",
         "DatasetE4 = 0",
         "DatasetE5 = 0")

hyp.vs.1.res <- hypothesis(fit2, hyp.vs.1)

# 1 = Intercept
# 3 = Dataset.L + Intercept
# 5 = Dataset.Q + Intercept
# 7 = Dataset.C + Intercept
# 8 = DatasetE4 + Intercept
# 9 = DatasetE5 + Intercept

# diff between each dataset and dataset 3
hyp.vs.3 <- c("Dataset.Q > Dataset.L", # 5 vs. 3
         "Dataset.C > Dataset.L",
         "DatasetE4 > Dataset.L",
         "DatasetE5 > Dataset.L")

hyp.vs.3.res <- hypothesis(fit2, hyp.vs.3)

# diff between each dataset and dataset 5
hyp.vs.5 <- c("Dataset.C > Dataset.Q", # 7 vs. 5
         "DatasetE4 > Dataset.Q",
         "DatasetE5 > Dataset.Q")

hyp.vs.5.res <- hypothesis(fit2, hyp.vs.5)

# diff between each dataset and dataset 7
hyp.vs.7 <- c("DatasetE4 > Dataset.C", # 8 vs. 7
         "DatasetE5 > Dataset.C")

hyp.vs.7.res <- hypothesis(fit2, hyp.vs.7)

# diff between each dataset and dataset 8
hyp.vs.8 <- c("DatasetE5 > DatasetE4" # 9 vs. 8
         )

hyp.vs.8.res <- hypothesis(fit2, hyp.vs.8)

# sequential differences
hyp.seq <- c("Dataset.L = 0",
             "Dataset.L + Dataset.Q > Dataset.L",
             "Dataset.Q + Dataset.C > Dataset.Q",
             "Dataset.C + DatasetE4 > Dataset.C",
             "DatasetE4 + DatasetE5 > DatasetE4")

(hyp.seq.res <- hypothesis(fit2, hyp.seq))

```

```{r}

# all pairs

hyp.pairs <- c("Dataset.L = 0", # 3 vs. 1
         "Dataset.Q = 0",
         "Dataset.C = 0",
         "DatasetE4 = 0",
         "DatasetE5 = 0",
         "Dataset.Q > Dataset.L", # 5 vs. 3
         "Dataset.C > Dataset.L",
         "DatasetE4 > Dataset.L",
         "DatasetE5 > Dataset.L",
         "Dataset.C > Dataset.Q", # 7 vs. 5
         "DatasetE4 > Dataset.Q",
         "DatasetE5 > Dataset.Q",
         "DatasetE4 > Dataset.C", # 8 vs. 7
         "DatasetE5 > Dataset.C",
         "DatasetE5 > DatasetE4")

# above syntax converts to Dataset.Q - Dataset.L > 0, which then calculates evidence ratio, which often makes upper CI infinite; correct syntax is Dataset.Q - Dataset.L = 0

hyp.pairs.2 <- c("Dataset.L = 0", # 3 vs. 1
         "Dataset.Q = 0",
         "Dataset.C = 0",
         "DatasetE4 = 0",
         "DatasetE5 = 0",
         "Dataset.Q - Dataset.L = 0", # 5 vs. 3
         "Dataset.C - Dataset.L = 0",
         "DatasetE4 - Dataset.L = 0",
         "DatasetE5 - Dataset.L = 0",
         "Dataset.C - Dataset.Q = 0", # 7 vs. 5
         "DatasetE4 - Dataset.Q = 0",
         "DatasetE5 - Dataset.Q = 0",
         "DatasetE4 - Dataset.C = 0", # 8 vs. 7
         "DatasetE5 - Dataset.C = 0",
         "DatasetE5 - DatasetE4 = 0")


(hyp.pairs.2.res <- hypothesis(fit2, hyp.pairs.2))

#plot(hyp.pairs.2.res, chars = NULL, ask=FALSE)

hyp.pairs.2.res.df <- hyp.pairs.2.res$hypothesis

hyp.pairs.2.res.df$contrast <- c("3-1","5-1","7-1","8-1","9-1","5-3","7-3","8-3","9-3","7-5","8-5","9-5","8-7","9-7","9-8")

hyp.pairs.2.res.df$contrast <- factor(hyp.pairs.2.res.df$contrast,
                                    levels=hyp.pairs.2.res.df %>% arrange(desc(Estimate)) %>%
                                      dplyr::select(contrast) %>% unlist())

ggplot(hyp.pairs.2.res.df, aes(contrast,Estimate)) + 
  geom_errorbar(aes(ymin=`l-95% CI`,ymax=`u-95% CI`)) +
  geom_point(aes(fill=Star=="*"), size=7, shape=21) +
  geom_hline(yintercept = 0) +
  scale_fill_manual(values=star.colors,name="Outside 95% CI") +
  coord_flip()

```

```{r}

hyp.pairs.2.res.df <- hyp.pairs.2.res.df %>% separate(contrast, c("From", "To"), sep="[-]", remove=FALSE)

copy <- hyp.pairs.2.res.df %>% rename(From=To,To=From) %>% 
  mutate(Estimate=-Estimate,
         `l-95% CI`=-`l-95% CI`,
         `u-95% CI`=-`u-95% CI`)

pairs.compl <- bind_rows(hyp.pairs.2.res.df, copy)


#cond.lev <- c("Ctrl","Phr","Col","Siz")

#graph.numnodes.emm.conddata.pairs.compl$From <- factor(graph.numnodes.emm.conddata.pairs.compl$From, levels=cond.lev)
#graph.numnodes.emm.conddata.pairs.compl$To <- factor(graph.numnodes.emm.conddata.pairs.compl$To, levels=cond.lev)

pairs.compl$From <- factor(pairs.compl$From, levels=c(9,8,7,5,3,1))
pairs.compl$To <- factor(pairs.compl$To, levels=c(1,3,5,7,8,9))

#graph.numlinks.emm.conddata.pairs.compl %>% arrange(desc(estimate))
pairs.compl %>% arrange(Estimate)

# can't get color to go the right direction
ggplot(pairs.compl %>% filter(Estimate >= 0)) +
  geom_tile(aes(x=To,y=From,fill=Estimate), color="black") +
  scale_fill_distiller(palette="Greys", direction=1) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(Estimate),fill=Star=="*"),shape=21, color="black") +
  scale_fill_manual(values=star.colors, name="Outside 95% CI") +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=Estimate)) +
  scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(Estimate),fill=Estimate, color=Star=="*"), shape=21,stroke=1) +
  scale_fill_distiller(type="div", palette=4, limits=c(-max(abs(pairs.compl$Estimate)),max(abs(pairs.compl$Estimate)))) +
  scale_color_manual(values=c("grey90","black"), name="Outside 95% CI") +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

hyp.pairs.2.res.df$From <- factor(hyp.pairs.2.res.df$From, levels=c(9,8,7,5,3,1))
hyp.pairs.2.res.df$To <- factor(hyp.pairs.2.res.df$To, levels=c(1,3,5,7,8,9))


ggplot(hyp.pairs.2.res.df) +
  geom_count(aes(x=To,y=From,size=abs(Estimate),fill=Estimate, color=Star=="*"), shape=21,stroke=1) +
  scale_fill_distiller(type="div", palette=4, limits=c(-max(abs(pairs.compl$Estimate)),max(abs(pairs.compl$Estimate)))) +
  scale_color_manual(values=c("grey90","black"), name="Outside 95% CI") +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")




```


##### mgcv

```{r, eval=FALSE}

#mgcv

library(mgcv)

graph.lgclust.beta.data <- gam(ResponsePct~Dataset,family=mgcv::betar(),data=graphics_lgclust.2)
graph.lgclust.beta.data.infl <- gam(ResponseInfl~Dataset,family=mgcv::betar(),data=graphics_lgclust.2)

gam.check(graph.lgclust.beta.data.infl)

bGAM <- coef(graph.lgclust.beta.data.infl)[2:6]
seGAM <- diag(vcov(graph.lgclust.beta.data.infl))[2:6]

    df <- data.frame(term     = nms <- names(bGAM),
                     estimate = bGAM)
    df <- transform(df,
                    upper = estimate + sqrt(seGAM),
                    lower = estimate - sqrt(seGAM))
    df
    
    p1 <- ggplot(df, aes(y = estimate, x = term, ymax = upper, ymin = lower)) +
    geom_pointrange() +
    labs(y = NULL,
         x = "Regression estimate",
         caption = "Bars are ±1 SE")

p1


```

##### glmmTMB

```{r, eval=FALSE}

#package glmmTMB:

(graph.lgclust.beta.cond <- glmmTMB(ResponsePct ~ Condition + (1|Demo.ResponseID), graphics_lgclust.2, family=list(family="beta",link="logit")))

summary(graph.lgclust.beta.cond) # no pseudo R^2, unlike betareg

#(graph.lgclust.beta.cond.ZI <- glmmTMB(Response ~ Condition + (1|Demo.ResponseID), graphics_lgclust.2, family=list(family="beta",link="logit"),ziformula =~1))
#Error in nlminb(start = par, objective = fn, gradient = gr, control = control$optCtrl) : gradient function must return a numeric vector of length 7

#ranef(graph.lgclust.beta.cond)

#fixef(graph.lgclust.beta.cond)

#confint(graph.lgclust.beta.cond)

#getME(graph.lgclust.beta.cond, name=c("X"))

hist(residuals(graph.lgclust.beta.cond))

lrtest(graph.lgclust.beta.cond)

```

##### betareg

```{r, eval=FALSE}


# betareg package

graph.lgclust.beta.cond <- betareg(ResponsePct~Condition, data=graphics_lgclust.2, type="ML") 
# specify random effects?
# no zero inflation?

summary(graph.lgclust.beta.cond)

lrtest(graph.lgclust.beta.cond)

# from car library

Anova(graph.lgclust.beta.cond, type="II")

```

##### broom

```{r, cache=TRUE}

mod7$call

mod7.tidy.df <- tidy(mod7)
mod7.tidy.df.mu <- mod7.tidy.df %>% filter(parameter == "mu")

mod7.ci.df <- confint_tidy(mod7)
mod7.ci.df.nona <- mod7.ci.df %>% drop_na()

mod7.tidyci.df <- bind_cols(mod7.tidy.df.mu, mod7.ci.df.nona)

mod7.aug.df <- augment(mod7,temp) # augment isn't supposed to work but seems to
#mod7.summ.df <- glance(mod7) #glance doesn't work

mod7.tidyci.df$term <- factor(mod7.tidyci.df$term,
                                          levels=mod7.tidyci.df %>% arrange(estimate) %>%
                                            dplyr::select(term) %>% unlist())

ggplot(mod7.aug.df) + geom_point(aes(ResponsePct,.fitted))

#ggplot(mod7.tidyci.df, aes(term, estimate)) + 
#  geom_point() + 
#  coord_flip()

#ggplot(mod7.aug.df %>% group_by(Dataset) %>% summarize(est=mean(.fitted))) +
#  geom_point(aes(Dataset,est)) +
#  #scale_y_continuous(limits = c(-.06,1.2), breaks=c(0,.3,.6,.9,1.2)) +
#  coord_flip()

#plot(emmeans(graph.clickhd.nb.full, "Dataset"))

#ggplot(mod7.aug.df) +
#  geom_violin(aes(Dataset,.fitted)) +
#  geom_point(data=mod7.aug.df %>% group_by(Dataset) %>% summarize(est=median(ResponsePct)),aes(Dataset,est)) +
#  #scale_y_continuous(limits = c(-.06,1.2), breaks=c(0,.3,.6,.9,1.2)) +
#  coord_flip()

# could be okay, but not sure of calculation
#ggplot(data = mod7.aug.df) + 
#  geom_errorbar(data=mod7.aug.df %>% group_by(Dataset) %>% 
#               summarize(est=mean(.fitted), 
#                         ymin=mean(.fitted-1.96*.se.fit), 
#                         ymax=mean(.fitted+1.96*.se.fit)),
#             aes(Dataset,est, ymin=ymin, ymax=ymax, width=.2)) +
#  geom_point(data=mod7.aug.df %>% group_by(Dataset) %>% 
#               summarize(est=mean(.fitted), 
#                         ymin=mean(.fitted-1.96*.se.fit), 
#                         ymax=mean(.fitted+1.96*.se.fit)),
#             aes(Dataset,est))

# no good
#ggplot(data = mod7.aug.df) + 
#  geom_errorbar(data=mod7.aug.df %>% group_by(Dataset) %>% 
#               summarize(est=mean(ResponsePct), 
#                         ymin=mean(.fitted-1.96*.se.fit), 
#                         ymax=mean(.fitted+1.96*.se.fit)),
#             aes(Dataset,est, ymin=ymin, ymax=ymax, width=.2)) +
#  geom_point(data=mod7.aug.df %>% group_by(Dataset) %>% 
#               summarize(est=mean(ResponsePct), 
#                         ymin=mean(.fitted-1.96*.se.fit), 
#                         ymax=mean(.fitted+1.96*.se.fit)),
#             aes(Dataset,est))
  

```

```{r, eval=FALSE}



set.seed(2014)

# doesn't work
bootnls <- mod7.aug.df %>% bootstrap(100) %>% do(tidy(
      gamlss(formula = ResponsePct ~ Dataset + UnderestDummy + Demo.gender + 
    Demo.lang + Demo.expreadnetvis + Stats.OperatingSystemWindows + 
    Dataset:UnderestDummy + Demo.gender:Stats.OperatingSystemWindows + 
    UnderestDummy:Demo.gender + UnderestDummy:Stats.OperatingSystemWindows, 
    sigma.formula = ~Dataset + UnderestDummy, family = BEINF, 
    ., trace = FALSE)
    ))
alpha = .05
bootnls %>% group_by(term) %>% summarize(low=quantile(estimate, alpha / 2),
                                         high=quantile(estimate, 1 - alpha / 2))
ggplot(bootnls, aes(estimate)) + geom_histogram(binwidth=2) + facet_wrap(~ term, scales="free")

bootnls_aug <- mtcars %>% bootstrap(100) %>%
    do(augment(nls(mpg ~ k / wt + b, ., start=list(k=1, b=0)), .))

ggplot(bootnls_aug, aes(wt, mpg)) + geom_point() +
    geom_line(aes(y=.fitted, group=replicate), alpha=.2)

smoothspline_aug <- mtcars %>% bootstrap(100) %>%
    do(augment(smooth.spline(.$wt, .$mpg, df=4), .))

ggplot(smoothspline_aug, aes(wt, mpg)) + geom_point() +
    geom_line(aes(y=.fitted, group=replicate), alpha=.2)

```


```{r, eval=FALSE}

graph.lgclust.broom.tidy <- tidy(mod7)
graph.lgclust.broom.aug <- augment(graph.lgclust.nb.full, temp)
graph.lgclust.broom.ci <- confint_tidy(graph.lgclust.nb.full)
graph.lgclust.broom.tidyci <- bind_cols(graph.lgclust.broom.tidy %>% arrange(group), graph.lgclust.broom.ci)

graph.clickhd.broom.tidyci$term <- factor(graph.clickhd.broom.tidyci$term,
                                          levels=graph.clickhd.broom.tidyci %>% arrange(estimate) %>%
                                            select(term) %>% unlist())

ggplot(graph.clickhd.broom.tidyci, aes(term, estimate)) + 
  geom_point() + 
  coord_flip()

ggplot(graph.clickhd.broom.aug %>% group_by(Dataset) %>% summarize(est=mean(.fitted))) +
  geom_point(aes(Dataset,est)) +
  scale_y_continuous(limits = c(-.06,1.2), breaks=c(0,.3,.6,.9,1.2)) +
  coord_flip()

plot(emmeans(graph.clickhd.nb.full, "Dataset"))

ggplot(graph.clickhd.broom.aug) +
  geom_violin(aes(Dataset,.fitted)) +
  scale_y_continuous(limits = c(-.06,1.2), breaks=c(0,.3,.6,.9,1.2)) +
  coord_flip()

```

##### gamlss

```{r, eval=FALSE}

# gamlss
# also from http://rcompanion.org/handbook/J_02.html
# https://stats.stackexchange.com/questions/48028/beta-regression-of-proportion-data-including-1-and-0
# http://www.de.ufpe.br/~raydonal/Talks/talk-10-12-2008.pdf
# https://stats.stackexchange.com/questions/253738/what-is-mu-in-zero-one-beta-inflated-models-gamlss-beinf
# http://www.de.ufpe.br/~raydonal/Talks/Gamlss-Theory.pdf
# http://www.de.ufpe.br/~raydonal/Talks/Gamlss-Applications.pdf
# https://www.researchgate.net/publication/228429663_Instructions_on_how_to_use_the_gamlss_package_in_R_Second_Edition

# For subsets use data=subset(mydata, subset_of_mydata),
# for na.action use data=na.omit(mydata)
# The function refit() can be used if the converged component of the gamlss fitted object is FALSE
# Warning: The random(), ra() and rc() additive functions do not have a predict option implemented.

#temp <- graphics_lgclust %>% mutate(Response=Response/100) %>% dplyr::select(Demo.ResponseID, Response, Condition, Dataset, DatasetOrder) %>% drop_na()

```

```{r, eval=FALSE}
#===== Fit model (all covariates) =====
mod.0 <- gamlss(Response~. + re(random=~1|Demo.ResponseID, opt = 'optim'), nu.formula=~., family=BEINF, data=temp)

#==== model selection for alpha using AIC ====
mod.1 <- stepGAIC(mod.0, what="nu")

#==== model selection for mu using AIC ====
mod.2 <- stepGAIC(mod.1)

#==== final fit model ====
fit <- gamlss(formula = Response ~ Dataset + (re(random = ~1 | Demo.ResponseID, opt = "optim")) , nu.formula = ~1, family = BEINF, data = temp, trace = FALSE)

summary(fit)
mean.fit <- meanBEINF(fit)

# https://stats.stackexchange.com/questions/309047/zero-inflated-beta-regression-using-gamlss-for-vegetation-cover-data

#means_m1 <- lpred(fit, type='response', what='mu', se.fit=T)
# can't do prediction with random effects?


```

```{r, eval=FALSE}
graph.lgclust.beta.cond <- gamlss(Response~Condition+random(factor(Demo.ResponseID)), data=temp, family=BEINF) 

graph.lgclust.beta.cond.2 <- gamlss(Response~Condition+re(random=~1|Demo.ResponseID, opt = 'optim'), data=temp, family=BEINF) 

graph.lgclust.beta.cond.3 <- gamlss(Response~re(fixed=~Condition, random=~1|Demo.ResponseID, opt = 'optim'), data=temp, family=BEINF) 


car::Anova(graph.lgclust.beta.cond.2)
# Error: $ operator is invalid for atomic vectors

AIC(graph.lgclust.beta.cond,graph.lgclust.beta.cond.2,graph.lgclust.beta.cond.3)

lrtest(graph.lgclust.beta.cond.2)

print(graph.lgclust.beta.cond.2)

summary(graph.lgclust.beta.cond.2)

#names(graph.lgclust.beta.cond.2)

#deviance(graph.lgclust.beta.cond.2, "G")
#deviance(graph.lgclust.beta.cond.2, "P")


#plot(fitted(graph.lgclust.beta.cond), fitted(graph.lgclust.beta.cond.2))

plot(fitted(graph.lgclust.beta.cond.2), residuals(graph.lgclust.beta.cond.2))

plot(graph.lgclust.beta.cond.2)

#term.plot(graph.lgclust.beta.cond.2)
wp(graph.lgclust.beta.cond.2)
wp(graph.lgclust.beta.cond.2,ylim.all=2)

#summary results
summary(graph.lgclust.beta.cond)
# fit values
mean.fit <- meanBEINF(graph.lgclust.beta.cond)
#meanBEINF(graph.lgclust.beta.cond)[1]

#source("ExtraBIc.R")
#source("residualsBIc.R")
# can't find these files

#==== residuals =====
#a <- residuals.BIc(graph.lgclust.beta.cond) #standardized residual
#b <- residuals.BIc(graph.lgclust.beta.cond, type="experimental") #weighted residual
#c <- residuals.BIc(graph.lgclust.beta.cond, type="quantil") #quantal residual

#==== normal probability plots ====
#envelope.BIc(graph.lgclust.beta.cond, main="standardized residual" )
#envelope.BIc(graph.lgclust.beta.cond, type="experimental", main="weighted residual" )
#envelope.BIc(graph.lgclust.beta.cond, type="quantil", main="quantal residual")


```

```{r, eval=FALSE}

# from https://pdfs.semanticscholar.org/ed3d/f96aa477d6454d5737403a5aab751ccd9315.pdf

#gamlss(Response~Condition+random(factor(Demo.ResponseID)), data=temp, family=BEINF) 
#gamlss(Response~Condition+re(random=~1|Demo.ResponseID, opt = 'optim'), data=temp, family=BEINF) 
#gamlss(Response~re(fixed=~Condition, random=~1|Demo.ResponseID, opt = 'optim'), data=temp, family=BEINF)

mod01.0 <- gamlss(Response ~ 1, data = temp, family = BEINF)
mod01.r <- gamlss(Response ~ 1 + random(factor(Demo.ResponseID)), data = temp, family = BEINF) # lowest deviance, highest AIC, highest df
mod01.r1 <- gamlss(Response ~ 1 + re(random=~1|Demo.ResponseID), data = temp, family = BEINF)
mod01.r2 <- gamlss(Response ~ re(fixed=~1, random=~1|Demo.ResponseID), data = temp, family = BEINF)
mod01.r3 <- gamlss(Response ~ 1 + re(random=~1|Demo.ResponseID, opt = 'optim'), data = temp, family = BEINF) # change in optimizer decreases df a small fraction, much faster 
mod01.r4 <- gamlss(Response ~ re(fixed=~1, random=~1|Demo.ResponseID, opt = 'optim'), data = temp, family = BEINF)
AIC(mod01.0,mod01.r,mod01.r1,mod01.r2,mod01.r3,mod01.r4) # keep .r3 syntax

mod01 <- gamlss(Response ~ 1 + re(random=~1|Demo.ResponseID, opt = 'optim'), data = temp, family = BEINF)

mod02.0 <- gamlss(Response ~ Condition, data = temp, family = BEINF)
mod02.r <- gamlss(Response ~ Condition + re(random=~1|Demo.ResponseID, opt = 'optim'), data = temp, family = BEINF)
mod02.0.s <- gamlss(Response ~ 1 + re(random=~1|Demo.ResponseID, opt = 'optim'), sigma.fo = ~Condition, data = temp, family = BEINF)
mod02.0.n <- gamlss(Response ~ 1 + re(random=~1|Demo.ResponseID, opt = 'optim'), nu.fo = ~Condition, data = temp, family = BEINF)
mod02.0.t <- gamlss(Response ~ 1 + re(random=~1|Demo.ResponseID, opt = 'optim'), tau.fo = ~Condition, data = temp, family = BEINF)
mod02.0.s.n <- gamlss(Response ~ 1 + re(random=~1|Demo.ResponseID, opt = 'optim'), sigma.fo = ~Condition, nu.fo = ~Condition, data = temp, family = BEINF)
mod02.0.s.t <- gamlss(Response ~ 1 + re(random=~1|Demo.ResponseID, opt = 'optim'), sigma.fo = ~Condition, tau.fo = ~Condition, data = temp, family = BEINF)
mod02.0.n.t <- gamlss(Response ~ 1 + re(random=~1|Demo.ResponseID, opt = 'optim'), tau.fo = ~Condition, nu.fo = ~Condition, data = temp, family = BEINF)
mod02.0.s.n.t <- gamlss(Response ~ 1 + re(random=~1|Demo.ResponseID, opt = 'optim'), sigma.fo = ~Condition, nu.fo = ~Condition, tau.fo = ~Condition, data = temp, family = BEINF)
mod02.r.s <- gamlss(Response ~ Condition + re(random=~1|Demo.ResponseID, opt = 'optim'), sigma.fo = ~Condition, data = temp, family = BEINF)
mod02.r.n <- gamlss(Response ~ Condition + re(random=~1|Demo.ResponseID, opt = 'optim'), nu.fo = ~Condition, data = temp, family = BEINF)
mod02.r.t <- gamlss(Response ~ Condition + re(random=~1|Demo.ResponseID, opt = 'optim'), tau.fo = ~Condition, data = temp, family = BEINF)
mod02.r.s.n <- gamlss(Response ~ Condition + re(random=~1|Demo.ResponseID, opt = 'optim'), sigma.fo = ~Condition, nu.fo = ~Condition, data = temp, family = BEINF)
mod02.r.s.t <- gamlss(Response ~ Condition + re(random=~1|Demo.ResponseID, opt = 'optim'), sigma.fo = ~Condition, tau.fo = ~Condition, data = temp, family = BEINF)
mod02.r.n.t <- gamlss(Response ~ Condition + re(random=~1|Demo.ResponseID, opt = 'optim'), tau.fo = ~Condition, nu.fo = ~Condition, data = temp, family = BEINF)
mod02.r.s.n.t <- gamlss(Response ~ Condition + re(random=~1|Demo.ResponseID, opt = 'optim'), sigma.fo = ~Condition, nu.fo = ~Condition, tau.fo = ~Condition, data = temp, family = BEINF)

#summary(mod02.r.s.n.t)

AIC(mod01, mod02.0, mod02.r, mod02.0.s, mod02.0.n, mod02.0.t, mod02.0.s.n, mod02.0.s.t, mod02.0.n.t, mod02.0.s.n.t, mod02.r.s, mod02.r.n, mod02.r.t, mod02.r.s.n, mod02.r.s.t, mod02.r.n.t, mod02.r.s.n.t) 
# best is mod01

AIC(mod01, mod02.0, mod02.r, mod02.0.s, mod02.0.n, mod02.0.t, mod02.0.s.n, mod02.0.s.t, mod02.0.n.t, mod02.0.s.n.t, mod02.r.s, mod02.r.n, mod02.r.t, mod02.r.s.n, mod02.r.s.t, mod02.r.n.t, mod02.r.s.n.t, k=3.8) 
# best is mod01

AIC(mod01, mod02.0, mod02.r, mod02.0.s, mod02.0.n, mod02.0.t, mod02.0.s.n, mod02.0.s.t, mod02.0.n.t, mod02.0.s.n.t, mod02.r.s, mod02.r.n, mod02.r.t, mod02.r.s.n, mod02.r.s.t, mod02.r.n.t, mod02.r.s.n.t, k=7.96) 
# best is mod01

# adding condition does not improve model 

plot(mod01)
term.plot(mod01, se=T)

#op <- par(mfrow = c(4, 2))
#lev <- c(1, 2, 3, 4, 5, 6, 7)
#ind <- c(3, 2, 9, 12, 1, 7, 4)
#j <- 0
#for (i in ind) {
#  j = 1 + j
#  xlab <- paste("treatment = ", eval(substitute(lev[j])))
#  ylab <- paste("p(y)")
#  plotBEINF(mu = fitted(mod22)[i],
#  sigma = fitted(mod22, "sigma")[i],
#  nu = fitted(mod22, "nu")[i],
#  tau = fitted(mod22, "tau")[i],
#  from = 0, to = 1, n = 101, xlab = xlab, ylab = ylab)
#  }
#term.plot(mod22, se = T)
#par(op)

plotBEINF(mu=fitted(mod01)[1],
          sigma=fitted(mod01, "sigma")[1],
          nu=fitted(mod01, "nu")[1],
          tau=fitted(mod01, "tau")[1],
          from = 0, to = 1, n=101)

```

```{r, cache=TRUE}



#data(usair)
#mod1 <- gamlss(y ~ ., data = usair, family = GA)

#mod1 <- gamlss(ResponsePct ~ Condition +
#Dataset + DatasetOrder +
#DatasetStartTime + TaskOrder + CorrectAnswer + Underestimated +
#Stats.Q_TotalDuration + Stats.OperatingSystem + Demo.age +
#Demo.gender + Demo.lang + Demo.educ + Demo.acfield +
#Demo.dailytech_Computer + Demo.dailytech_Tablet + Demo.dailytech_SmartPhone +
#Demo.weeklygaming + Demo.expdataanal + Demo.expdatavis + Demo.expreadnetvis +
#Demo.expcreatenetvis + StatsNumPixels + AvgDeg + Density + LargeClust1 +
#Modularity + NumClust + NumHighDegree + NumLinks + NumNodes + NumNodesClust1 +
#ConditionPhrasing + ConditionGraphics + ConditionColor + Ctrl_dummy +
#Demo.expreadnetvis.alot + Demo.expcreatenetvis.alot + Stats.OperatingSystemCombined +
#Stats.OperatingSystemCombined2 + Stats.OperatingSystemCombined3 +
#Stats.OperatingSystemCombined4 + Stats.OperatingSystemCombined5 +
#Stats.OperatingSystemWindows + Stats.OperatingSystemMacintosh +
#Stats.OperatingSystemAndroid + Stats.OperatingSystemiPhone +
#Stats.OperatingSystemNumClust + Demo.acfieldGrouped + Demo.acfieldGrouped2 +
#Demo.acfieldGrouped3 + Overestimated + UnderestDummy +
#DatasetDuration,
#data = temp, family = BEINF)

mod1 <- gamlss(ResponsePct ~ Dataset + 
                 UnderestDummy + 
                 Demo.gender + Demo.lang + 
                 Demo.expreadnetvis + 
                 Stats.OperatingSystemWindows,
               data = temp, family = BEINF)

#library(MASS)
#dropterm(mod1, test = "Chisq")

dropterm(mod1, test = "Chisq")

#To demonstrate the function addterm consider adding a two way interaction term into the model mod1. Note that the scope argument has to be defined explicitly here.
#addterm(mod1, scope = ~(x1 + x2 + x3 + x4 + x5 + x6)^2, test = "Chisq")

addterm(mod1, scope = ~(Dataset + UnderestDummy + Demo.gender + Demo.lang + Demo.expreadnetvis + Stats.OperatingSystemWindows)^2, test = "Chisq")

#Dataset:UnderestDummy, UnderestDummy:Stats.OperatingSystemWindows, UnderestDummy:Demo.gender

mod2 <- gamlss(ResponsePct ~ Dataset + 
                 UnderestDummy + 
                 Demo.gender + Demo.lang + 
                 Demo.expreadnetvis + 
                 Stats.OperatingSystemWindows +
                 Dataset:UnderestDummy +
                 UnderestDummy:Stats.OperatingSystemWindows +
                 UnderestDummy:Demo.gender,
               data = temp, family = BEINF)

summary(mod2)

mod3 <- stepGAIC(mod1, scope = list(lower = ~1, upper = ~(Dataset + UnderestDummy + Demo.gender + Demo.lang + Demo.expreadnetvis + Stats.OperatingSystemWindows)^2))

# Final
# ResponsePct ~ Dataset + UnderestDummy + Demo.gender + Demo.lang + 
#    Demo.expreadnetvis + Stats.OperatingSystemWindows + Dataset:UnderestDummy + 
#    Demo.gender:Stats.OperatingSystemWindows + UnderestDummy:Demo.gender + 
#    UnderestDummy:Stats.OperatingSystemWindows

AIC(mod1, mod2, mod3)
# mod3 is best

mod3$anova
# pretty complicated model, though

#gs <- gamlss.scope(model.frame(ResponsePct ~ Dataset + factor(UnderestDummy) + factor(Demo.gender) + factor(Demo.lang) + Demo.expreadnetvis + factor(Stats.OperatingSystemWindows), data = temp))

#gs

#mod4 <- stepGAIC.CH(mod3, scope = gs, k = 2)
# no real point looking for smoothing functions; all of these are factor variables
#mod4$anova
#formula(mod4, "mu")

#op <- par(mfrow = c(3, 2))
# term.plot(mod3, se = T, partial = T)
# par(op)

mod7<-stepGAIC(mod3, what="sigma", scope=~Dataset + UnderestDummy + Demo.gender + Demo.lang + Demo.expreadnetvis + Stats.OperatingSystemWindows)


# final sigma: ~Dataset + UnderestDummy 
```

```{r}

#SAVE THE RESULTS
save(mod7, file = file.path(analysisDataDir,"fits/graph_lgclust_beinf_int.RData"))

```


```{r}

predict.current <- bind_cols(temp,as.data.frame(predict(mod7,what="mu",type="response",se.fit=TRUE)))
# can also get fitted values with fitted(mod7), just join to temp

ggplot(predict.current) + geom_point(aes(ResponsePct,fit))

# trying to reproduce other M/SE calculations; doesn't seem quite right
#ggplot(predict.current %>% 
#         group_by(Dataset) %>% 
#         summarise(avgFit=mean(fit),avgSE=mean(se.fit)) %>% 
#         mutate(lower.CI=avgFit-avgSE, upper.CI=avgFit+avgSE)) + 
#  geom_pointrange(aes(Dataset,avgFit,ymin=lower.CI,ymax=upper.CI))

#lsmeans(mod7, ~ Dataset)
#Anova(mod7)

ggplot(mod7.aug.df) + geom_point(aes(ResponsePct, .fitted))

# the fitted values from this are different from the fitted values from augment with broom --
# different scale anyway.  why?
# answer: augment is using type="link" rather than type="response"; hard to compare to ResponsePct directly, but
# matches result from term.plot better?

```


```{r}

ggplot(graphics_lgclust, aes(Response)) +
  geom_histogram(binwidth = 1) +
  labs(title="Distribution of Response values for Percentage of Nodes\nin Largest Cluster task, graphics conditions")


Rsq(mod7)
Rsq(mod7, type="both")

#mod7.aug.df <- augment(mod7,temp)

ggplot(mod7.aug.df, aes(ResponsePct,.fitted)) + 
  geom_bin2d() +
  geom_smooth(method="lm") +
  labs(title="Real vs. Predicted Response values for Percentage of Nodes\nin Largest Cluster task, graphics conditions",
       x="Response as a Percentage")



```

```{r, eval=FALSE}
#a1 <- mod7$anova
#a1 <- anova(mod7)
#a1 <- aov(mod7, what="mu")

#posthoc <- TukeyHSD(x=a1, 'temp$Dataset', conf.level=0.95)
# doesn't work

summary(mod7)

#acfResid(mod7)

#dtop(mod7)

plot(mod7)

plot2way(mod7,c("Dataset","UnderestDummy"))

print(mod7)

rqres.plot(mod7, ylim.all=1)
#rqres.plot(mod7, howmany=40, plot="all")

term.plot(mod7, ask=FALSE)

ggplot(mod7.aug.df %>% group_by(Dataset) %>% summarise(median=median(.fitted))) + geom_boxplot(aes(Dataset,median)) + scale_y_continuous(limits=c(-2,3))

#term.plot(mod7, ask=FALSE, pages=1)
#term.plot(mod7, ask=FALSE, partial.resid = TRUE)
term.plot(mod7, what="mu", ask=FALSE)
term.plot(mod7, what="sigma", ask=FALSE)



temp2 <- temp
temp2$Demo.ResponseID <- factor(temp2$Demo.ResponseID)



hist(temp$ResponsePct)

pdf.plot(obj=mod7, min=0, max=1, step=.01)

# plotting the distribution
plotBEINF(mu = predict(mod7, what="mu", type="response")[1], 
          sigma = predict(mod7, what="sigma", type="response")[1], 
          nu = predict(mod7, what="nu", type="response")[1], 
          tau = predict(mod7, what="tau", type="response")[1],
          from = 0, 
          to = 1, 
          n = 101)

# trying link instead
#plotBEINF(mu = predict(mod7, what="mu", type="link"), 
#          sigma = predict(mod7, what="sigma", type="link"), 
#          nu = predict(mod7, what="nu", type="link"), 
#          tau = predict(mod7, what="tau", type="link"),
#          from = 0, 
#          to = 1, 
#          n = 101)


# plotting the cdf
plot(function(y) pBEINF(y, mu = predict(mod7, what="mu", type="response")[1], 
          sigma = predict(mod7, what="sigma", type="response")[1], 
          nu = predict(mod7, what="nu", type="response")[1], 
          tau = predict(mod7, what="tau", type="response")[1]), 0, 1)

# plotting the inverse cdf
plot(function(y) qBEINF(y, mu = predict(mod7, what="mu", type="response")[1], 
          sigma = predict(mod7, what="sigma", type="response")[1], 
          nu = predict(mod7, what="nu", type="response")[1], 
          tau = predict(mod7, what="tau", type="response")[1]), 0.01, .99)

# mean
meanBEINF(mod7)[1]



# from http://www.stat.tugraz.at/friedl/GAMLSS/Practical-Graz.pdf
# The worm plot (see Section ??) is a de-trended normal Q-Q plot of the residuals. Modelinadequacy is indicated when many points plotted lie outside the (dotted) point-wise 95% confidence bands. 

wp(mod7, ylim.all=1) # not great

#wp(mod7, resid = resid(mod7), xvar=~temp$Dataset)
# not quite right

#edfAll(mod7)

fittedPlot(mod7, x=temp$Dataset)
fittedPlot(mod7, x=temp$Demo.expreadnetvis)
fittedPlot(mod7, x=temp$Demo.lang)
fittedPlot(mod7, x=factor(temp$Stats.OperatingSystemWindows))
fittedPlot(mod7, x=factor(temp$UnderestDummy))
fittedPlot(mod7, x=factor(temp$Demo.gender))

#Q.stats(mod7,xvar=temp$Dataset,n.inter=30)


```

```{r, eval=FALSE}


smod7<-summary(mod7, save=TRUE)
smod7$mu.coef.table
smod7$sigma.coef.table
smod7$coef.table
smod7$coef
smod7$object$anova
#to get a list of all the slots in the object
str(smod7)

estimate.pval.mu <- as.data.frame(cbind(term=rownames(smod7$coef.table[c(1:23),]),smod7$coef.table[c(1:23),]), row.names=FALSE, stringsAsFactors = FALSE)


```

```{r, eval=FALSE}

# try https://stats.stackexchange.com/questions/29044/plotting-confidence-intervals-for-the-predicted-probabilities-from-a-logistic-re

# https://stats.stackexchange.com/questions/299792/r-lm-covariance-matrix-manual-calculation-failure

#print(vcov(mod7))

#new.data <- expand.grid(
#  ResponsePct=seq(0,1,by=.001),
#  Dataset=unique(temp$Dataset),
#  UnderestDummy=unique(temp$UnderestDummy),
#  Demo.gender=unique(temp$Demo.gender),
#  Demo.lang=unique(temp$Demo.lang),
#  Demo.expreadnetvis=unique(temp$Demo.expreadnetvis),
#  Stats.OperatingSystemWindows=unique(temp$Stats.OperatingSystemWindows)
#  )

#beta.pred <-bind_cols(as.data.frame(predictAll(mod7, newdata=new.data, type="response")))

pi <- mod7.aug.df$.fitted

w <- pi * (1 - pi)

v <- diag(w, length(w), length(w))

#XtX_inv <- solve(t(as.matrix(new.data)) %*% v %*% as.matrix(new.data))
# still doesn't work

#p0 = nu /(1+nu+tau) & p1 = tau/(1+nu+tau)

vcov.mod7 <- vcov(mod7) # just mu? 23 x 23 (no, mu has 25 coefficients, but 23 df?)
vcov.mod7.2 <- smod7$covmat$vcov # all? 32 x 32
std.err <- sqrt(t(as.matrix(new.data)) %*% vcov.mod7 %*% as.matrix(new.data))

trans <- t(as.matrix(new.data))
new.data.mat <- as.matrix(new.data)

trans %*% new.data.mat

plot(mod7)

sum.pred <- beta.pred %>% group_by(Dataset) %>% summarise(mean=mean(mu),
                                                          sd=sd(mu),
                                                          sample.size=n(),
                                                          df=sample.size-1,
                                                          alpha=.025,
                                                          t.dist=1.96,
                                                          mod=t.dist*(sd/sqrt(sample.size)),
                                                          lower.ci=mean-mod,
                                                          upper.ci=mean+mod
                                                          )

ggplot(beta.pred) + geom_boxplot(aes(Dataset, mu)) + scale_y_continuous(limits=c(0,1)) + coord_flip()
ggplot(sum.pred, aes(Dataset, mean)) + geom_errorbar(aes(ymin=lower.ci,ymax=upper.ci)) + geom_point() + scale_y_continuous(limits=c(0,1)) + coord_flip()



```

```{r, eval=FALSE}
#mod2 <- stepGAIC.VR(mod1) 
#or
#mod2<-stepGAIC(mod1, additive=FALSE)
#mod2$anova
#mod2 <- stepGAIC(mod1, k = log(41))
#mod3 <- stepGAIC(mod1, scope = list(lower = ~1, upper = ~(x1 + x2 + x3 + x4 + x5 + x6)^2))
#mod3$anova
#mod2 <- stepGAIC.VR(mod1)
#mod2$anova
#mod2 <- stepGAIC(mod1, k = log(41))
#mod3 <- stepGAIC(mod1, scope = list(lower = ~1, upper = ~(x1 + x2 + x3 + x4 + x5 + x6)^2))
#gs <- gamlss.scope(model.frame(y ~ x1 + x2 + x3 + x4 + x5 + x6, data = usair))
#gs
#gs1 <- gamlss.scope(model.frame(y ~ x1 + x2 + x3 + x4 + x5 + x6, data = usair), smoother = "lo", arg = "span=.7", form = TRUE)
#gs1
#mod5 <- gamlss(y ~ 1, data = usair, family = GA)
#mod6 <- stepGAIC(mod5, gs, additive = TRUE)
#mod6$anova
#mod6
#mod7<-stepGAIC(mod6, what="sigma", scope=~x1+x2+x3+x4+x5+x6)
#mod7$anova

#We start with a model for mu including all the explanatory variables.
#We shall now use the dropterm to check if model m1 can be simplified by dropping any of the existing terms in mu and the function addterm to check whether two way interactions of the existing terms are needed.
#Based on the Chi square tests no terms can be left out and no two way interaction is needed.
#Since we established that adding or dropping terms in mu is not beneficial there is nopoint using stepGAIC.VR() for modelling the mu parameter with linear terms. Instead we will use (stepGAIC.CH()) trying to establish if smoothing terms are needed in the mu model.
#gs <- gamlss.scope(model.frame(Claims ~ factor(SD) + L_Popdensity + L_KI + L_Accidents + L_Population, data = LGAclaims))
#gs
#m2 <- stepGAIC.CH(m1, scope = gs, k = 2)
#m2$anova
#formula(m2, "mu")
#The best model includes smoothing terms for L_Popdensity, L_Accidents and L_Population but not for L_KI.
#op <- par(mfrow = c(3, 2))
#term.plot(m2, se = T, partial = T)
#par(op)
#Given that we have establish a good model for mu, we proceed to find a good model for sigma. We start first with linear terms but we exclude the factor SD since some of the levels of the factor have very few observations.
#m11 <- stepGAIC.VR(m2, scope = ~L_Popdensity + L_KI + L_Accidents + L_Population, what = "sigma", k = 2)
#m11$anova
#Note that the argument what is used here to determine which distribution parameter is to be modelled. Here variables L_Population, L_KI and L_Accidents were found important in explaining the sigma parameter. The model chosen using AIC appears over complicated. Maybe a higher penalty for GAIC would be more appropriate here.
```

```{r, eval=FALSE}

# https://github.com/mjskay/when-ish-is-my-bus/blob/master/bus-model.Rmd

predictions <- expand.grid(
  ResponsePct=seq(0,1,by=.001),
  Dataset=unique(temp$Dataset),
  UnderestDummy=unique(temp$UnderestDummy),
  Demo.gender=unique(temp$Demo.gender),
  Demo.lang=unique(temp$Demo.lang),
  Demo.expreadnetvis=unique(temp$Demo.expreadnetvis),
  Stats.OperatingSystemWindows=unique(temp$Stats.OperatingSystemWindows)
  ) %>% 
  cbind(predictAll(mod7, newdata = ., data=temp)) %>% 
  mutate(
        upper95 = qBEINF(.975, mu, sigma, nu, tau),
        lower95 = qBEINF(.025, mu, sigma, nu, tau),
        upper80 = qBEINF(.9, mu, sigma, nu, tau),
        lower80 = qBEINF(.1, mu, sigma, nu, tau),
        upper50 = qBEINF(.75, mu, sigma, nu, tau),
        lower50 = qBEINF(.25, mu, sigma, nu, tau),
        upper10 = qBEINF(.55, mu, sigma, nu, tau),
        lower10 = qBEINF(.45, mu, sigma, nu, tau)
    )
  
# What is predictAll adding?  is it really predicting a new value for ResponsePct? maybe need to take a log of mu?

predictions %>%
    ggplot(aes(x = ResponsePct, y=mu)) +
  geom_bin2d() +
  facet_wrap(~Dataset)
```

```{r, eval=FALSE}

mbi1 <- gamlss(ResponsePct ~ 1, data = temp, family = BEINF)
mbi2<-stepGAIC(mbi1,scope=list(upper=~(Condition + Dataset + DatasetOrder)^2))

summary(mbi2)
mbi2$anova

mBB21<-stepGAIC(mbi2,what="sigma",scope=list(upper=~(Condition + Dataset + DatasetOrder)^2))

mBB22<-stepGAIC(mBB21,what="mu")

mBB22$call

mBB23 <- stepGAIC(mBB22,scope=gamlss.scope(model.frame(Response~Dataset, data=temp)),what="mu")

mBB23$anova

term.plot(mBB23)

mBB23$call

```

#### Least Squares

mod7
gamlss(formula = ResponsePct ~ Dataset + UnderestDummy + Demo.gender + 
    Demo.lang + Demo.expreadnetvis + Stats.OperatingSystemWindows + 
    Dataset:UnderestDummy + Demo.gender:Stats.OperatingSystemWindows + 
    UnderestDummy:Demo.gender + UnderestDummy:Stats.OperatingSystemWindows, 
    sigma.formula = ~Dataset + UnderestDummy, family = BEINF, 
    data = temp, trace = FALSE)

##### Dataset

###### gamlss

```{r}

term.plot(mod7, ask=FALSE)

```


```{r}

#means_m1 <- lpred(mod7, type='response', what='mu', se.fit=T)

means_m1 <- lpred(mod7, type='terms', terms="Dataset", what='mu', se.fit=T)

#mod.t <- lpred(mod7, type = "terms", terms= "Dataset")
#mod.t

#mod.lp <- lp(mod7)
#mod.lp

df_fit <- data.frame(Dataset = temp$Dataset, M = means_m1$fit, SE = means_m1$se.fit)
names(df_fit) <- c("Dataset","M","SE")

#ggplot(df_fit, aes(Dataset, M)) + 
#  geom_pointrange(aes(ymin=M-SE, ymax=M+SE)) + 
#  scale_y_continuous(labels=scales::percent)

# not bad, might work
ggplot(df_fit, aes(Dataset, M)) + 
  geom_errorbar(aes(ymin=M-SE, ymax=M+SE), width=.2) + 
  geom_point(size=7) +
  labs(title="Model Fit for Dataset for Percentage of Nodes\nin Largest Cluster task, graphics conditions",
       y="Fit")


```

```{r, eval=FALSE}

#df_fit.compare <- df_fit %>% tibble::rowid_to_column(., ".iteration") %>% 
#  mutate(.chain=1,
#         Dataset=as.character(Dataset)) %>% 
#  rename(estimate=M) %>%
#  dplyr::select(-SE)

df_fit.compare <- mod7.aug.df %>% 
  dplyr::select(Dataset,.fitted) %>%
  tibble::rowid_to_column(., ".iteration") %>% 
  mutate(.chain=1, Dataset=as.character(Dataset)) %>% 
  rename(estimate=.fitted) 

mod7.pairs <- df_fit.compare %>% compare_levels(estimate, by=Dataset)

```

```{r, eval=FALSE}

library(modelr)

mod7.aug.df %>%
  data_grid(Dataset) %>%
  add_predicted_samples(mod7) %>%
  ggplot(aes(x = pred, y = Dataset)) +
  stat_pointintervalh(.prob = c(.66, .95))

```


###### lsmeans/emmeans

```{r, eval=FALSE}

# any way to get post-hoc analysis? emmeans and lsmeans don't seem to work 
# (lsmeans only works on linear models, emmeans doesn't handle the random effects??)

lsmeansLT(graph.lgclust.beta.cond, test.effs = "Condition")
#Error in lsmeansLT(graph.lgclust.beta.cond, test.effs = "Condition") : The model is not linear mixed effects model

emmeans(graph.lgclust.beta.cond, "Condition")
#Error in `contrasts<-`(`*tmp*`, how.many, value = contr) : 
#  contrasts can be applied only to factors with 2 or more levels

graph.lgclust.beta.cond.norand <- gamlss(Response~Condition, data=temp, family=BEINF) 

emmeans(graph.lgclust.beta.cond.norand, "Condition")

```


###### brms/tidybayes

note: moved code up ; this section never got updated

```{r, eval=FALSE}


# https://mvuorre.github.io/post/2017/bayes-factors-with-brms/

# http://mjskay.github.io/tidybayes/articles/tidy-brms.html#gathering-samples-from-a-fit-in-tidy-format-using-spread_samples

# https://github.com/paul-buerkner/brms/issues/95

# Check exact names of terms
#tidybayes::parameters(fit)

# b_Intercept is the global mean, and sigma is the standard deviation of observations

fit %>%
  gather_samples(b_Intercept, sigma) %>%
  head(10)

# If we want the mean and 95% quantile interval of the parameters, we can apply mean_qi
# We can specify the columns we want to get means and intervals from, as above, or if we omit the list of columns, mean_qi will use every column that is not a grouping column or a special column (one that starts with ., like .chain or .iteration).

fit %>%
  gather_samples(b_Intercept, sigma) %>%
  mean_qi()

# b_Intercept is the global mean, and the individual parameters are offsets from that mean

fit %>%
  gather_samples(b_Intercept, b_Dataset.L, b_Dataset.Q, b_Dataset.C, b_DatasetE4, b_DatasetE5) %>%
  head(10)

m %>%
  spread_samples(`condition_.*`[condition], regex = TRUE) %>%
  head(10)



```

```{r, eval=FALSE}

library(modelr)

graphics_lgclust.2 %>%
  data_grid(Dataset) %>%
  add_fitted_samples(fit) %>%
  ggplot(aes(x = estimate, y = Dataset)) +
  stat_pointintervalh(.prob = c(.66, .95))

```

```{r, eval=FALSE}

# https://github.com/paul-buerkner/brms/issues/95

(hyp2 <- hypothesis(fit, c("Aa2 + Bb2 + Aa2:Bb2 = 0", "Intercept = 0"),
                    alpha = 0.025))
plot(hyp2)

```


```{r, eval=FALSE}

pairs <- fit %>%
  gather_samples(b_Intercept, b_Dataset.L, b_Dataset.Q, b_Dataset.C, b_DatasetE4, b_DatasetE5) %>%
  mutate(contrast=case_when(
    term=="b_Intercept" ~ 1,
    term=="b_Dataset.L" ~ 3,
    term=="b_Dataset.Q" ~ 5,
    term=="b_Dataset.C" ~ 7,
    term=="b_DatasetE4" ~ 8,
    term=="b_DatasetE5" ~ 9
  )) %>%
  compare_levels(estimate, by=contrast)
  
pairs$contrast <- factor(pairs$contrast, 
                         levels=pairs %>% 
                           group_by(contrast) %>% 
                           summarise(avgEst=mean(estimate)) %>%
                           arrange(desc(avgEst)) %>% dplyr::select(contrast) %>% unlist())

m %>%
  spread_samples(b_Intercept, r_condition[condition,]) %>%
  mean_qi(condition_mean = b_Intercept + r_condition)

m %>%
  spread_samples(b_Intercept, r_condition[condition,]) %>%
  mean_qi(condition_mean = b_Intercept + r_condition, .prob = c(.95, .66)) %>%
  ggplot(aes(y = condition, x = condition_mean)) +
  geom_pointintervalh() 

ggplot(pairs, aes(y=contrast,x=estimate)) + geom_halfeyeh()
ggplot(pairs, aes(y=contrast,x=estimate)) + geom_halfeyeh() + geom_vline(xintercept=0)

```

```{r, eval=FALSE}

grouped_pairs <- pairs %>% group_by(contrast) %>% summarise(avgEst=mean(estimate)) %>% 
  separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

grouped_pairs %>% arrange(avgEst)
#graph.numlinks.emm.conddata.pairs %>% View()

copy <- grouped_pairs %>% rename(From=To,To=From) %>% 
  mutate(avgEst=-avgEst)

pairs.compl <- bind_rows(grouped_pairs, copy)


#cond.lev <- c("Ctrl","Phr","Col","Siz")

#graph.numnodes.emm.conddata.pairs.compl$From <- factor(graph.numnodes.emm.conddata.pairs.compl$From, levels=cond.lev)
#graph.numnodes.emm.conddata.pairs.compl$To <- factor(graph.numnodes.emm.conddata.pairs.compl$To, levels=cond.lev)

pairs.compl$From <- factor(pairs.compl$From, levels=c(9,8,7,5,3,1))


#graph.numlinks.emm.conddata.pairs.compl %>% arrange(desc(estimate))
pairs.compl %>% arrange(avgEst)

ggplot(pairs.compl) +
  geom_tile(aes(x=To,y=From), color="black") +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(avgEst))) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=avgEst)) +
  scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(avgEst),color=avgEst)) +
  scale_color_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")



```

###### bayesplot

```{r, eval=FALSE}

# https://cran.r-project.org/web/packages/bayesplot/vignettes/plotting-mcmc-draws.html

library(bayesplot)

posterior <- as.array(fit) # in example, model is from stan_glm

mcmc_scatter(x, pars = c("alpha", "sigma"),
                  transform = list(sigma = "log"))

mcmc_hex(x, pars = c("sigma", "alpha"), transform = list(sigma = "log"))

mcmc_intervals(posterior, pars = c("cyl", "drat", "am", "sigma"))

mcmc_violin(posterior, pars = c("wt", "sigma"), probs = c(0.1, 0.5, 0.9))

mcmc_pairs(posterior, pars = c("(Intercept)", "wt", "sigma"),
           off_diag_args = list(size = 1.5))

mcmc_pairs(x, pars = "alpha", regex_pars = "beta\\[[1,4]\\]",
           diag_fun = "dens", off_diag_fun = "hex")


```

###### ggmcmc

```{r, eval=FALSE}

library(ggmcmc)

# http://xavier-fim.net/packages/ggmcmc/
# S is a data frame object with four variables, namely:
# - Iteration Number of iteration.
# - Chain Number of the chain.
# - Parameter Name of the parameter.
# - value value sampled.

ggmcmc(S)

ggs_histogram(S)

ggs_crosscorrelation(S)

L.radon.intercepts <- data.frame(
  Parameter=paste("alpha[", radon$counties$id.county, "]", sep=""),
  Label=radon$counties$County)
head(L.radon.intercepts)

S.full <- ggs(radon$s.radon, par_labels=L.radon.intercepts, family="^alpha")

ggs_caterpillar(S.full)

```


###### networks

```{r, eval=FALSE}

# try a network of the pairwise significance values?  bleh...
# using igraph

graph <- graph_from_data_frame(graph.bc.emm.data.pairs %>% dplyr::select(-contrast), directed=TRUE)

E(graph)$width <- abs(E(graph)$estimate)*10
E(graph)$edge.color <- sig.colors[E(graph)$sig.levels]

graph

plot(graph, 
     edge.arrow.size=.5,
     vertex.frame.color="#555555")

```

```{r, eval=FALSE}

# using ggraph and tidygraph

graph <- graph_from_data_frame(graph.bc.emm.data.pairs.compl %>% dplyr::select(-contrast) %>% filter(sig.levels != "NS"), directed=TRUE)

# plot using ggraph
ggraph(graph, layout = 'kk') +
  geom_edge_link(aes(start_cap = label_rect(node1.name),
                       end_cap = label_rect(node2.name),
                     color=factor(sig.level.names[sig.levels]),
                     edge_width=.5/sig.levels
                     ), 
                   arrow = arrow(length = unit(4, 'mm')))+
  geom_node_text(label = vertex_attr(graph,"name")) +
  scale_edge_color_manual("Significance Levels", values=sig.colors) +
  scale_edge_width_continuous(labels=rev(sig.level.names)) +
  theme_graph()

```




##### UnderestDummy

###### gamlss

```{r}

term.plot(mod7, ask=FALSE)

```


```{r}

#means_m1 <- lpred(mod7, type='response', what='mu', se.fit=T)

means_m1 <- lpred(mod7, type='terms', terms="UnderestDummy", what='mu', se.fit=T)

#mod.t <- lpred(mod7, type = "terms", terms= "Dataset")
#mod.t

#mod.lp <- lp(mod7)
#mod.lp

df_fit <- data.frame(UnderestDummy = temp$UnderestDummy, M = means_m1$fit, SE = means_m1$se.fit)
names(df_fit) <- c("UnderestDummy","M","SE")

#ggplot(df_fit, aes(Dataset, M)) + 
#  geom_pointrange(aes(ymin=M-SE, ymax=M+SE)) + 
#  scale_y_continuous(labels=scales::percent)

# not bad, might work
ggplot(df_fit, aes(UnderestDummy, M)) + 
  geom_errorbar(aes(ymin=M-SE, ymax=M+SE), width=.2) + 
  geom_point(size=7)

ggplot(df_fit, aes(UnderestDummy, M)) + 
  geom_errorbar(aes(ymin=M-SE, ymax=M+SE), width=.2) + 
  geom_point(size=7) +
  scale_x_discrete(labels=c("Underestimated", "Correct or Overestimated"), name="Underestimated") +
  labs(title="Model Fit for Underestimated for Percentage of Nodes\nin Largest Cluster task, graphics conditions",
       y="Fit")


```


##### Demo.gender

###### gamlss

```{r}

term.plot(mod7, ask=FALSE)

```


```{r}

#means_m1 <- lpred(mod7, type='response', what='mu', se.fit=T)

means_m1 <- lpred(mod7, type='terms', terms="Demo.gender", what='mu', se.fit=T)

#mod.t <- lpred(mod7, type = "terms", terms= "Dataset")
#mod.t

#mod.lp <- lp(mod7)
#mod.lp

df_fit <- data.frame(Demo.gender = temp$Demo.gender, M = means_m1$fit, SE = means_m1$se.fit)
names(df_fit) <- c("Demo.gender","M","SE")

#ggplot(df_fit, aes(Dataset, M)) + 
#  geom_pointrange(aes(ymin=M-SE, ymax=M+SE)) + 
#  scale_y_continuous(labels=scales::percent)

# not bad, might work
ggplot(df_fit, aes(Demo.gender, M)) + 
  geom_errorbar(aes(ymin=M-SE, ymax=M+SE), width=.2) + 
  geom_point(size=7)

ggplot(df_fit, aes(Demo.gender, M)) + 
  geom_errorbar(aes(ymin=M-SE, ymax=M+SE), width=.2) + 
  geom_point(size=7) +
  #scale_x_discrete(labels=c("Underestimated", "Correct or Overestimated"), name="Underestimated") +
  labs(title="Model Fit for Gender for Percentage of Nodes\nin Largest Cluster task, graphics conditions",
       y="Fit")

```



##### Demo.lang

###### gamlss

```{r}

term.plot(mod7, ask=FALSE)

```


```{r}

#means_m1 <- lpred(mod7, type='response', what='mu', se.fit=T)

means_m1 <- lpred(mod7, type='terms', terms="Demo.lang", what='mu', se.fit=T)

#mod.t <- lpred(mod7, type = "terms", terms= "Dataset")
#mod.t

#mod.lp <- lp(mod7)
#mod.lp

df_fit <- data.frame(Demo.lang = temp$Demo.lang, M = means_m1$fit, SE = means_m1$se.fit)
names(df_fit) <- c("Demo.lang","M","SE")

#ggplot(df_fit, aes(Dataset, M)) + 
#  geom_pointrange(aes(ymin=M-SE, ymax=M+SE)) + 
#  scale_y_continuous(labels=scales::percent)

# not bad, might work
ggplot(df_fit, aes(Demo.lang, M)) + 
  geom_errorbar(aes(ymin=M-SE, ymax=M+SE), width=.2) + 
  geom_point(size=7)

ggplot(df_fit, aes(Demo.lang, M)) + 
    geom_errorbar(aes(ymin=M-SE, ymax=M+SE), width=.2) + 
    geom_point(size=7) +
    #scale_x_discrete(labels=c("Underestimated", "Correct or Overestimated"), name="Underestimated") +
    labs(title="Model Fit for Language for Percentage of Nodes\nin Largest Cluster task, graphics conditions",
         y="Fit", x="Primary Language Spoken at Home")

```




##### Demo.expreadnetvis

###### gamlss

```{r}

term.plot(mod7, ask=FALSE)

```


```{r}

#means_m1 <- lpred(mod7, type='response', what='mu', se.fit=T)

means_m1 <- lpred(mod7, type='terms', terms="Demo.expreadnetvis", what='mu', se.fit=T)

#mod.t <- lpred(mod7, type = "terms", terms= "Dataset")
#mod.t

#mod.lp <- lp(mod7)
#mod.lp

df_fit <- data.frame(Demo.expreadnetvis = temp$Demo.expreadnetvis, M = means_m1$fit, SE = means_m1$se.fit)
names(df_fit) <- c("Demo.expreadnetvis","M","SE")

#ggplot(df_fit, aes(Dataset, M)) + 
#  geom_pointrange(aes(ymin=M-SE, ymax=M+SE)) + 
#  scale_y_continuous(labels=scales::percent)

# not bad, might work
ggplot(df_fit, aes(Demo.expreadnetvis, M)) + 
  geom_errorbar(aes(ymin=M-SE, ymax=M+SE), width=.2) + 
  geom_point(size=7)

ggplot(df_fit, aes(Demo.expreadnetvis, M)) + 
    geom_errorbar(aes(ymin=M-SE, ymax=M+SE), width=.2) + 
    geom_point(size=7) +
    #scale_x_discrete(labels=c("Underestimated", "Correct or Overestimated"), name="Underestimated") +
    labs(title="Model Fit for Experience Reading Network Visualizations for Percentage of Nodes\nin Largest Cluster task, graphics conditions",
         y="Fit", x="Experience Reading Network Visualizations")


```






##### Stats.OperatingSystemWindows

###### gamlss

```{r}

term.plot(mod7, ask=FALSE)

```


```{r}

#means_m1 <- lpred(mod7, type='response', what='mu', se.fit=T)

means_m1 <- lpred(mod7, type='terms', terms="Stats.OperatingSystemWindows", what='mu', se.fit=T)

#mod.t <- lpred(mod7, type = "terms", terms= "Dataset")
#mod.t

#mod.lp <- lp(mod7)
#mod.lp

df_fit <- data.frame(Stats.OperatingSystemWindows = temp$Stats.OperatingSystemWindows, M = means_m1$fit, SE = means_m1$se.fit)
names(df_fit) <- c("Stats.OperatingSystemWindows","M","SE")

#ggplot(df_fit, aes(Dataset, M)) + 
#  geom_pointrange(aes(ymin=M-SE, ymax=M+SE)) + 
#  scale_y_continuous(labels=scales::percent)

# not bad, might work
ggplot(df_fit, aes(Stats.OperatingSystemWindows, M)) + 
  geom_errorbar(aes(ymin=M-SE, ymax=M+SE), width=.2) + 
  geom_point(size=7)

ggplot(df_fit, aes(Stats.OperatingSystemWindows, M)) + 
    geom_errorbar(aes(ymin=M-SE, ymax=M+SE), width=.2) + 
    geom_point(size=7) +
    #scale_x_discrete(labels=c("Underestimated", "Correct or Overestimated"), name="Underestimated") +
    labs(title="Model Fit for Operating Systems for Percentage of Nodes\nin Largest Cluster task, graphics conditions",
         y="Fit", x="Operating Systems")

```







##### Dataset:UnderestDummy

###### gamlss

```{r}

plot2way(mod7,c("Dataset","UnderestDummy"))
plot2way(mod7,c("UnderestDummy","Dataset"))

```


```{r, eval=FALSE}

means_m1 <- data.frame(lpred(mod7, type='terms', terms=c("Dataset","UnderestDummy"), what='mu', se.fit=T)) %>%
  unite(data.comb, fit.Dataset, se.fit.Dataset) %>% 
  unite(under.comb, fit.UnderestDummy, se.fit.UnderestDummy) %>%
  bind_cols(temp %>% dplyr::select(Dataset, UnderestDummy),.) %>%
  gather(key=term,value=united, data.comb, under.comb) %>%
  separate(united,into=c("fit","se.fit"), sep="[_]",convert=TRUE) %>%
  mutate(term=case_when(term=="data.comb" ~ "Dataset",
                        term=="under.comb" ~ "UnderestDummy"))

#means_m1

means_m1 <- data.frame(lpred(mod7, type='terms', terms=c("Dataset","UnderestDummy"), what='mu', se.fit=T)) %>%
  unite(data.comb, fit.Dataset, se.fit.Dataset) %>% 
  unite(under.comb, fit.UnderestDummy, se.fit.UnderestDummy) %>%
  bind_cols(temp %>% dplyr::select(Dataset, UnderestDummy),.) %>%
  gather(key=term,value=united, data.comb, under.comb) %>%
  separate(united,into=c("fit","se.fit"), sep="[_]",convert=TRUE) %>%
  mutate(term=case_when(term=="data.comb" ~ "Dataset",
                        term=="under.comb" ~ "UnderestDummy")) %>%
  group_by(Dataset, UnderestDummy,term) %>%
  summarize(meanFit=mean(fit),
            meanSE=mean(se.fit))

ggplot(means_m1, aes(Dataset, meanFit, color=term)) + 
  geom_errorbar(aes(ymin=meanFit-meanSE, ymax=meanFit+meanSE), width=.2) + 
  geom_point(size=7) +
  facet_grid(.~term)

```


##### Demo.gender:Stats.OperatingSystemWindows


```{r}

plot2way(mod7,c("Demo.gender","Stats.OperatingSystemWindows"))
plot2way(mod7,c("Stats.OperatingSystemWindows","Demo.gender"))

```

##### UnderestDummy:Demo.gender

```{r}

plot2way(mod7,c("UnderestDummy","Demo.gender"))
plot2way(mod7,c("Demo.gender","UnderestDummy"))

```

##### UnderestDummy:Stats.OperatingSystemWindows

```{r}

plot2way(mod7,c("UnderestDummy","Stats.OperatingSystemWindows"))
plot2way(mod7,c("Stats.OperatingSystemWindows","UnderestDummy"))

```

### Number of Clusters

#### lme4

```{r, cache=TRUE}

# Individual fixed effects

graph.numclust.lmer.cond <- lmer(LogError ~ Condition + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer.cond) # Color significantly different from Control

anova(graph.numclust.lmer.cond)

# Condition is significant (p=5.234e-07)

graph.numclust.lmer.phr <- lmer(LogError ~ ConditionPhrasing + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer.phr)

anova(graph.numclust.lmer.phr)

# ConditionPhrasing is significant (p=0.003226)

graph.numclust.lmer.gr <- lmer(LogError ~ ConditionGraphics + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer.gr)

anova(graph.numclust.lmer.gr)

# ConditionGraphics is significant (p=1.653e-07)

graph.numclust.lmer.col <- lmer(LogError ~ ConditionColor + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer.col)

anova(graph.numclust.lmer.col)

# ConditionColor is significant (p=2.897e-08)

graph.numclust.lmer <- lmer(LogError ~ Ctrl_dummy + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# Ctrl_dummy not significant; trying Dataset

graph.numclust.lmer.dataset <- lmer(LogError ~ Dataset + (1|Demo.ResponseID), data = graphics_numclust, REML = T)

lmsum <- summary(graph.numclust.lmer.dataset)
lmsum
#names(lmsum)

anova(graph.numclust.lmer.dataset)

# Dataset is significant (p < 2.2e-16); trying QuestionOrder

graph.numclust.lmer <- lmer(LogError ~ QuestionOrder + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# QuestionOrder is not significant; trying DatasetOrder

graph.numclust.lmer <- lmer(LogError ~ DatasetOrder + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# DatasetOrder is barely not significant (p=0.0684); trying DatasetDuration

graph.numclust.lmer <- lmer(LogError ~ DatasetDuration + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# DatasetDuration is not significant; trying DatasetStartTime

graph.numclust.lmer <- lmer(LogError ~ DatasetStartTime + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# DatasetStartTime is not significant; trying TaskOrder

graph.numclust.lmer <- lmer(LogError ~ TaskOrder + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# TaskOrder is not significant; trying CorrectAnswer

graph.numclust.lmer.correct <- lmer(LogError ~ CorrectAnswer + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer.correct)

anova(graph.numclust.lmer.correct)

# CorrectAnswer is highly significant (p = 5.251e-07); trying Underestimated

graph.numclust.lmer.underest <- lmer(LogError ~ Underestimated + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer.underest)

anova(graph.numclust.lmer.underest)

# Underestimated is highly significant (p < 2.2e-16)

graph.numclust.lmer.overest <- lmer(LogError ~ Overestimated + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer.overest)

anova(graph.numclust.lmer.overest)

# Underestimated is highly significant (p < 2.2e-16)

graph.numclust.lmer <- lmer(LogError ~ ClustConf + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# ClustConf is not significant

graph.numclust.lmer <- lmer(LogError ~ Stats.Q_TotalDuration + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# Stats.Q_TotalDuration is not significant; trying Stats.dataset_count

graph.numclust.lmer <- lmer(LogError ~ Stats.dataset_count + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# Stats.dataset_count is not significant; trying Stats.OperatingSystem

graph.numclust.lmer <- lmer(LogError ~ Stats.OperatingSystem + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer)

# Various significant categories:
# *: Android 6.0.1, CrOS x86_64 9592.96.0, Linux x86_64, Ubuntu, Windows NT 10.0
#    Windows NT 5.1, Windows NT 6.0, Windows NT 6.1

anova(graph.numclust.lmer)

# Stats.OperatingSystem is not quite significant; trying Stats.OperatingSystemCombined

graph.numclust.lmer <- lmer(LogError ~ Stats.OperatingSystemCombined + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer) # no significant categories

anova(graph.numclust.lmer)

# Stats.OperatingSystemCombined is not significant; trying Stats.OperatingSystemCombined2

graph.numclust.lmer <- lmer(LogError ~ Stats.OperatingSystemCombined2 + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# Stats.OperatingSystemCombined2 is not significant; trying Stats.OperatingSystemCombined3

graph.numclust.lmer <- lmer(LogError ~ Stats.OperatingSystemCombined3 + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer) # Windows almost significantly different from Macintosh (0.0888)

anova(graph.numclust.lmer)

# Stats.OperatingSystemCombined3 is not significant; trying Stats.OperatingSystemCombined4

graph.numclust.lmer <- lmer(LogError ~ Stats.OperatingSystemCombined4 + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# Stats.OperatingSystemCombined4 is not significant; trying Stats.OperatingSystemCombined5

graph.numclust.lmer <- lmer(LogError ~ Stats.OperatingSystemCombined5 + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# Stats.OperatingSystemCombined5 is not significant; trying Stats.OperatingSystemWindows

graph.numclust.lmer <- lmer(LogError ~ Stats.OperatingSystemWindows + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# Stats.OperatingSystemWindows is not significant; trying Stats.OperatingSystemMacintosh

graph.numclust.lmer <- lmer(LogError ~ Stats.OperatingSystemMacintosh + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# Stats.OperatingSystemMacintosh is not significant

graph.numclust.lmer.OShighsig <- lmer(LogError ~ Stats.OperatingSystemNumClust + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer.OShighsig)

anova(graph.numclust.lmer.OShighsig)

# Stats.OperatingSystemNumClust is significant (p=0.0002445); trying StatsNumPixels

graph.numclust.lmer.pixels <- lmer(LogError ~ StatsNumPixels + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer.pixels)

anova(graph.numclust.lmer.pixels)

# StatsNumPixels is significant (p=0.02508); trying Demo.age

graph.numclust.lmer <- lmer(LogError ~ Demo.age + (1|Demo.ResponseID), data=graphics_numclust %>% filter(!(is.na(Demo.age))), REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# Demo.age is not significant; trying Demo.gender

graph.numclust.lmer <- lmer(LogError ~ Demo.gender + (1|Demo.ResponseID), data=graphics_numclust %>% filter(!(is.na(Demo.gender))), REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# Demo.gender is not significant; trying Demo.lang

graph.numclust.lmer <- lmer(LogError ~ Demo.lang + (1|Demo.ResponseID), data=graphics_numclust %>% filter(!(is.na(Demo.lang))), REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# Demo.lang is not significant; trying Demo.educ

graph.numclust.lmer <- lmer(LogError ~ Demo.educ + (1|Demo.ResponseID), data=graphics_numclust %>% filter(!(is.na(Demo.educ))), REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# Demo.educ is not significant; trying Demo.acfield

graph.numclust.lmer <- lmer(LogError ~ Demo.acfield + (1|Demo.ResponseID), data=graphics_numclust %>% filter(!(is.na(Demo.acfield))), REML = T)

summary(graph.numclust.lmer) # no significant categories

anova(graph.numclust.lmer)

# Demo.acfield is not significant; trying Demo.acfieldGrouped

graph.numclust.lmer <- lmer(LogError ~ Demo.acfieldGrouped + (1|Demo.ResponseID), data=graphics_numclust %>% filter(!(is.na(Demo.acfieldGrouped))), REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# Demo.acfieldGrouped is not significant; trying Demo.dailytech_Computer

graph.numclust.lmer <- lmer(LogError ~ Demo.dailytech_Computer + (1|Demo.ResponseID), data=graphics_numclust %>% filter(!(is.na(Demo.dailytech_Computer))), REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# Demo.dailytech_Computer is not quite significant (p=0.0655); trying Demo.dailytech_Tablet

graph.numclust.lmer <- lmer(LogError ~ Demo.dailytech_Tablet + (1|Demo.ResponseID), data=graphics_numclust %>% filter(!(is.na(Demo.dailytech_Tablet))), REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# Demo.dailytech_Tablet is not significant; trying Demo.dailytech_SmartPhone

graph.numclust.lmer.SP <- lmer(LogError ~ Demo.dailytech_SmartPhone + (1|Demo.ResponseID), data=graphics_numclust %>% filter(!(is.na(Demo.dailytech_SmartPhone))), REML = T)

summary(graph.numclust.lmer.SP)

anova(graph.numclust.lmer.SP)

# Demo.dailytech_SmartPhone is significant (p=0.01925); trying Demo.weeklygaming

graph.numclust.lmer <- lmer(LogError ~ Demo.weeklygaming + (1|Demo.ResponseID), data=graphics_numclust %>% filter(!(is.na(Demo.weeklygaming))), REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# Demo.weeklygaming is not significant; trying Demo.expdataanal

graph.numclust.lmer <- lmer(LogError ~ Demo.expdataanal + (1|Demo.ResponseID), data=graphics_numclust %>% filter(!(is.na(Demo.expdataanal))), REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# Demo.expdataanal is not significant; trying Demo.expdatavis

graph.numclust.lmer <- lmer(LogError ~ Demo.expdatavis + (1|Demo.ResponseID), data=graphics_numclust %>% filter(!(is.na(Demo.expdatavis))), REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# Demo.expdatavis is not significant; trying Demo.expreadnetvis

graph.numclust.lmer.ERNV <- lmer(LogError ~ Demo.expreadnetvis + (1|Demo.ResponseID), data=graphics_numclust %>% filter(!(is.na(Demo.expreadnetvis))), REML = T)

summary(graph.numclust.lmer.ERNV) # several levels significant

anova(graph.numclust.lmer.ERNV)

# Demo.expreadnetvis is significant (p=0.000261); trying Demo.expreadnetvis.alot

graph.numclust.lmer.ERNVAL <- lmer(LogError ~ Demo.expreadnetvis.alot + (1|Demo.ResponseID), data=graphics_numclust %>% filter(!(is.na(Demo.expreadnetvis.alot))), REML = T)

summary(graph.numclust.lmer.ERNVAL)

anova(graph.numclust.lmer.ERNVAL)

# Demo.expreadnetvis.alot is significant (p=4.177e-06)

graph.numclust.lmer <- lmer(LogError ~ Demo.expreadnetvis.none + (1|Demo.ResponseID), data=graphics_numclust %>% filter(!(is.na(Demo.expreadnetvis.none))), REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# Demo.expreadnetvis.none is not significant

graph.numclust.lmer <- lmer(LogError ~ Demo.expreadnetvis.three + (1|Demo.ResponseID), data=graphics_numclust %>% filter(!(is.na(Demo.expreadnetvis.three))), REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# Demo.expreadnetvis.three is not significant

graph.numclust.lmer.ECNV <- lmer(LogError ~ Demo.expcreatenetvis + (1|Demo.ResponseID), data=graphics_numclust %>% filter(!(is.na(Demo.expcreatenetvis))), REML = T)

summary(graph.numclust.lmer.ECNV) # a couple significant differences

anova(graph.numclust.lmer.ECNV)

# Demo.expcreatenetvis is marginally significant (p=0.02167); trying Demo.expcreatenetvis.alot

graph.numclust.lmer.ECNVAL <- lmer(LogError ~ Demo.expcreatenetvis.alot + (1|Demo.ResponseID), data=graphics_numclust %>% filter(!(is.na(Demo.expcreatenetvis.alot))), REML = T)

summary(graph.numclust.lmer.ECNVAL)

anova(graph.numclust.lmer.ECNVAL)

# Demo.expcreatenetvis.alot is significant (p=0.002181); trying AvgDeg

graph.numclust.lmer.avgdeg <- lmer(LogError ~ AvgDeg + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer.avgdeg)

anova(graph.numclust.lmer.avgdeg)

# AvgDeg is significant (p=2.351e-10); trying Density

graph.numclust.lmer.dens <- lmer(LogError ~ Density + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer.dens)

anova(graph.numclust.lmer.dens)

# Density is significant (p=7.012e-08); trying LargeClust1

graph.numclust.lmer.lgclust <- lmer(LogError ~ LargeClust1 + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer.lgclust)

anova(graph.numclust.lmer.lgclust)

# LargeClust1 is significant (p=6.648e-09); trying Modularity

graph.numclust.lmer.mod <- lmer(LogError ~ Modularity + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer.mod)

anova(graph.numclust.lmer.mod)

# Modularity is significant (p=6.408e-05); trying NumClust

graph.numclust.lmer.numclust <- lmer(LogError ~ NumClust + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer.numclust)

anova(graph.numclust.lmer.numclust)

# NumClust is significant (p=5.251e-07); trying NumHighDegree

graph.numclust.lmer <- lmer(LogError ~ NumHighDegree + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# NumHighDegree is not significant; trying NumLinks

graph.numclust.lmer <- lmer(LogError ~ NumLinks + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# NumLinks is not quite significant; trying NumNodes

graph.numclust.lmer.numnodes <- lmer(LogError ~ NumNodes + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer.numnodes)

anova(graph.numclust.lmer.numnodes)

# NumNodes is significant (p=0.0009575); trying NumNodesClust1

graph.numclust.lmer <- lmer(LogError ~ NumNodesClust1 + (1|Demo.ResponseID), data=graphics_numclust, REML = T)

summary(graph.numclust.lmer)

anova(graph.numclust.lmer)

# NumNodesClust1 is not significant 


```

```{r}

# combining individual predictors

temp <- graphics_numclust %>% dplyr::select(Demo.ResponseID, LogError, Condition, ConditionPhrasing, ConditionGraphics, ConditionColor, Dataset, CorrectAnswer, Underestimated, Overestimated, Stats.OperatingSystemNumClust, StatsNumPixels, Demo.dailytech_SmartPhone, Demo.expreadnetvis, Demo.expreadnetvis.alot, Demo.expcreatenetvis, Demo.expcreatenetvis.alot, AvgDeg, Density, LargeClust1, Modularity, NumClust, NumNodes) %>% drop_na()

#temp <- temp%>% mutate(StatsNumPixels=scale(StatsNumPixels))

graph.numclust.lmer.full <- lmer(LogError ~ ConditionColor + Dataset + 
                                   Overestimated + 
                                   Stats.OperatingSystemNumClust + 
                                   Demo.dailytech_SmartPhone +
                                   Demo.expreadnetvis +
                                   (1|Demo.ResponseID), data=temp, REML = T)

summary(graph.numclust.lmer.full)

anova(graph.numclust.lmer.full)

```

```{r}

# adding interactions

graph.numclust.lmer.full.int <- lmer(LogError ~ ConditionColor + Dataset + 
                                       Overestimated + 
                                       Stats.OperatingSystemNumClust + 
                                       Demo.expreadnetvis +
                                       ConditionColor:Dataset +
                                       (1|Demo.ResponseID), data=temp, REML = T)

summary(graph.numclust.lmer.full.int)

anova(graph.numclust.lmer.full.int)




graph.numclust.lmer.full.int.2 <- lmer(LogError ~ ConditionColor + Dataset + 
                                       Overestimated + 
                                       Stats.OperatingSystemNumClust + 
                                       Demo.expreadnetvis +
                                       ConditionColor:Dataset +
                                       #Dataset:Overestimated + 
                                        Dataset:Demo.expreadnetvis + 
                                       (1|Demo.ResponseID), data=temp, REML = T)

# Note: Dataset5CorrectUnder is diff from Dataset1CorrectUnder?

summary(graph.numclust.lmer.full.int.2)

anova(graph.numclust.lmer.full.int.2)

anova(graph.numclust.lmer.full.int.2,graph.numclust.lmer.full.int)

# keep int.2

graph.numclust.lmer.full.int.3 <- lmer(LogError ~ ConditionColor + Dataset + 
                                       Overestimated + 
                                       Stats.OperatingSystemNumClust + 
                                       Demo.expreadnetvis +
                                       ConditionColor:Dataset +
                                       Dataset:Overestimated + 
                                        Dataset:Demo.expreadnetvis + 
                                       (1|Demo.ResponseID), data=temp, REML = T)

summary(graph.numclust.lmer.full.int.3)

anova(graph.numclust.lmer.full.int.3)

anova(graph.numclust.lmer.full.int.2,graph.numclust.lmer.full.int.3)

# barely significant, but can keep int.3

graph.numclust.lmer.full.int.4 <- lmer(LogError ~ ConditionColor + Dataset + 
                                       Overestimated + 
                                       Stats.OperatingSystemNumClust + 
                                       Demo.expreadnetvis +
                                       ConditionColor:Dataset +
                                       Overestimated:Stats.OperatingSystemNumClust + 
                                       (1|Demo.ResponseID), data=temp, REML = T)

summary(graph.numclust.lmer.full.int.4)

anova(graph.numclust.lmer.full.int.4)

anova(graph.numclust.lmer.full.int.3,graph.numclust.lmer.full.int.4)

# keep int.3

graph.numclust.lmer.full.int.5 <- lmer(LogError ~ ConditionColor + Dataset + 
                                       Overestimated + 
                                       Stats.OperatingSystemNumClust + 
                                       Demo.expreadnetvis +
                                       ConditionColor:Dataset +
                                       Overestimated:Stats.OperatingSystemNumClust + 
                                         Overestimated:Demo.expreadnetvis +
                                       (1|Demo.ResponseID), data=temp, REML = T)

summary(graph.numclust.lmer.full.int.5)

anova(graph.numclust.lmer.full.int.5)

anova(graph.numclust.lmer.full.int.3,graph.numclust.lmer.full.int.5)

# keep int.5

graph.numclust.lmer.full.int.6 <- lmer(LogError ~ ConditionColor + Dataset + 
                                       Overestimated + 
                                       Stats.OperatingSystemNumClust + 
                                       Demo.expreadnetvis +
                                       ConditionColor:Dataset +
                                       Overestimated:Stats.OperatingSystemNumClust + 
                                         Overestimated:Demo.expreadnetvis +
                                         Stats.OperatingSystemNumClust:Demo.expreadnetvis +
                                       (1|Demo.ResponseID), data=temp, REML = T)

summary(graph.numclust.lmer.full.int.6)

anova(graph.numclust.lmer.full.int.6)

anova(graph.numclust.lmer.full.int.5,graph.numclust.lmer.full.int.6)

# keep int.6

graph.numclust.lmer.full.int.7 <- lmer(LogError ~ ConditionColor + Dataset + 
                                       Overestimated + 
                                       Stats.OperatingSystemNumClust + 
                                       ConditionColor:Dataset +
                                       Overestimated:Stats.OperatingSystemNumClust + 
                                      (1|Demo.ResponseID), data=temp, REML = T)

summary(graph.numclust.lmer.full.int.7)

anova(graph.numclust.lmer.full.int.7)

anova(graph.numclust.lmer.full.int.7, graph.numclust.lmer.full.int.6)
# 6 is better, but need to avoid Demo.expreadnetvis

```

```{r}

#SAVE THE RESULTS
save(graph.numclust.lmer.full.int.7, 
     file = file.path(analysisDataDir,"fits/graph_numclust_lmer_int.RData"))

```


```{r, cache=TRUE}

rand(graph.numclust.lmer.full.int.7)

# result shows that random effects of participant are significant (p=8e-11)

#ranef(graph.avgdeg.lmer.SP)

# displays the random effects; not that useful

# unlike lme(), lmer() doesn't allow for heterogeneous error variance structures (the "weights")

(r2nsj = r2beta(graph.numclust.lmer.full.int.7, method = 'nsj', partial = TRUE))[1,'Rsq']

ggplot(graphics_numclust) + geom_histogram(aes(LogError), binwidth=.005) + labs(title="Distribution of LogError values for Number of Clusters task,\ngraphics conditions")


```

```{r}

plot(graph.numclust.lmer.full.int.7)

plot(graph.numclust.lmer.full.int.7, resid(., scaled=TRUE) ~ fitted(.), abline = 0)

plot(graph.numclust.lmer.full.int.7, resid(.) ~ fitted(.) | ConditionColor, abline = 0)

plot(graph.numclust.lmer.full.int.7, resid(., scaled=TRUE) ~ fitted(.) | Dataset, abline = 0)

plot(graph.numclust.lmer.full.int.7, LogError ~ fitted(.), abline = c(0,1))



```

```{r}

graph.numclust.lmer.full.int.7.f <- fortify(graph.numclust.lmer.full.int.7)

ggplot(graph.numclust.lmer.full.int.7.f, aes(.fitted,.resid)) + 
  geom_point() +
  #facet_grid(.~Sex) + 
  geom_hline(yintercept=0)

ggplot(graph.numclust.lmer.full.int.7.f, aes(.fitted,LogError)) + 
  geom_point() +
  geom_abline(aes(slope = 1, intercept = 0))

ggplot(graph.numclust.lmer.full.int.7.f, aes(LogError,.fitted)) +
geom_point() +
geom_abline(aes(slope = 1, intercept = 0)) +
scale_y_continuous(limits=c(0,0.3)) +
labs(title="Real vs. Predicted LogError values for Number of Clusters task,\ngraphics conditions")


```

```{r, eval=FALSE}

# TO DO: check out interpretation for these plots??

library(lattice)

prof <-  profile(graph.numclust.lmer.full.int.6, optimizer="Nelder_Mead", which="beta_")

prof.CI <- confint(prof)

#CI2 <- confint(graph.avgdeg.lmer.SP, maxpts = 8)

xyplot(prof)

xyplot(prof, absVal = TRUE)

xyplot(prof, conf = c(0.95, 0.99), main = "95% and 99% profile() intervals")

# can also apply logProf() and varianceProf() to profile object

densityplot(prof)

splom(prof)

```

#### Least Squares Means

Do for each categorical predictor. 
Final model (graph.numclust.lmer.full.int.7): LogError ~ ConditionColor + Dataset + Overestimated + Stats.OperatingSystemNumClust + ConditionColor:Dataset + Overestimated:Stats.OperatingSystemNumClust + (1|Demo.ResponseID)

##### ConditionColor

###### lsmeans (old)

```{r, eval=FALSE}

# doesn't make sense for continuous predictor???

lsm.condition <- lsmeansLT(graph.numclust.lmer.full.int.6, test.effs = "Condition")

plot(lsm.condition)

lsm.condition.df <- as_data_frame(lsm.condition$lsmeans.table)

lsm.condition.df

lsm.task.df$Task <- factor(lsm.task.df$Task, levels=lsm.task.df %>% arrange(desc(Estimate)) %>% select(Task) %>% unlist())

lsm.task.df %>% arrange(desc(Estimate))


ggplot(lsm.task.df) +
  geom_point(aes(x=Task,y=Estimate, color=`p-value`<.01)) +
  geom_errorbar(aes(x=Task,ymax=`Upper CI`,ymin=`Lower CI`), width=.2) +
  coord_flip()

# TO DO: add a color scale so TRUE/FALSE values are always same color across all plots


```



```{r, eval=FALSE}
# old code, used lmertest, but that is deprecated
# doesn't make sense for continuous predictor???

difflsm.task <- difflsmeans(graph.numclust.lmer.full.int.6, test.effs = "ConditionColor")

plot(difflsm.task)

difflsm.task.df <- as_data_frame(difflsm.task$diffs.lsmeans.table)

difflsm.task.df

difflsm.task.df <- difflsm.task.df %>% mutate(Pair=rownames(.)) %>% separate(Pair, c("del","Pair"), sep=5) %>% select(-del) %>% separate(Pair, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% select(-del)

difflsm.task.df$Pair <- factor(difflsm.task.df$Pair, levels=difflsm.task.df %>% arrange(desc(Estimate)) %>% select(Pair) %>% unlist())

difflsm.task.df %>% arrange(desc(Estimate))

ggplot(difflsm.task.df) +
  geom_point(aes(x=Pair,y=Estimate, color=`p-value`<.01)) +
  geom_errorbar(aes(x=Pair,ymax=`Upper CI`,ymin=`Lower CI`), width=.5) +
  geom_hline(aes(yintercept=0)) +
  coord_flip()

ggplot(difflsm.task.df) +
  geom_tile(aes(x=To,y=From,fill=Estimate)) +
    scale_fill_distiller(type="div", palette=4)

ggplot(difflsm.task.df) +
  geom_count(aes(x=To,y=From,size=abs(Estimate),fill=Estimate, color=`p-value`<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black"))
  



```

###### emmeans

```{r}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numhighdeg, table(Dataset,Overestimated))
# ref_grid(graph.numhd.lmer.full.int.4) @ grid; .wgt. is number of observations

graph.numclust.emm.cond <- emmeans(graph.numclust.lmer.full.int.7, "ConditionColor", nesting = NULL)
#graph.numhd.emm.condition <- emmeans(graph.numhd.lmer.full.int.4, "Condition", lmer.df = "satterthwaite")

#ref_grid(graph.numclust.lmer.full.int.7) @ grid

graph.numclust.emm.cond

graph.numclust.emm.cond.df <- dplyr::as_data_frame(graph.numclust.emm.cond)

graph.numclust.emm.cond.df


# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numhd.emm.condition)

graph.numclust.emm.cond.cld <- cld(graph.numclust.emm.cond,
                details=TRUE,
                #alpha=0.01,
                #by="Dataset",
                #Letters="|||||||||||||||||||",
                sort=TRUE
)

graph.numclust.emm.cond.cld.df <- graph.numclust.emm.cond.cld$emmeans

graph.numclust.emm.cond.cld.df %>% dplyr::select(ConditionColor,.group)

graph.numclust.emm.cond.cld.df

graph.numclust.emm.cond.cld.df$ConditionColor <- factor(graph.numclust.emm.cond.cld.df$ConditionColor, levels=graph.numclust.emm.cond.cld.df %>% arrange(desc(emmean)) %>% dplyr::select(ConditionColor) %>% unlist())


#emmip(graph.numlinks.lmer.full.int, ~Condition, CIs = TRUE)
emmip(graph.numclust.emm.cond, ~ConditionColor, CIs = TRUE)
plot(graph.numclust.emm.cond)
#plot(graph.numlinks.emm.cond, comparisons = TRUE)

graph.numclust.emm.cond.cld.df %>% arrange(desc(emmean))

ggplot(graph.numclust.emm.cond.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=ConditionColor,ymax=upper.CL,ymin=lower.CL), width=.2) +
  geom_point(aes(x=ConditionColor,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(labels=c("Blue","Black")) +
  coord_flip() +
  labs(title="Estimated Marginal Means for Node Color for Number of Clusters task,\ngraphics conditions",
       x="Node Color")


#plot(ref_grid(graph.numnodes.lmer.int.3), by="Condition") 
# try to figure this out? maybe only works on the interaction?
```

```{r}

graph.numclust.emm.cond.pairs <- dplyr::as_data_frame(pairs(graph.numclust.emm.cond)) 
graph.numclust.emm.cond.pairs
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

pairs.CI <- confint(pairs(graph.numclust.emm.cond))

graph.numclust.emm.cond.pairs <- full_join(graph.numclust.emm.cond.pairs, pairs.CI)

#graph.numhd.diffemm.condition <- emmeans(graph.numhd.lmer.full.int.4, pairwise ~ Condition)
#graph.numhd.diffemm.condition$contrasts
#contrast(graph.numhd.emm.condition)
#confint(graph.numhd.emm.condition)
#pairs(graph.numhd.emm.condition, details=TRUE)
#confint(contrast(graph.numhd.emm.condition))
#confint(pairs(graph.numhd.emm.condition))
#coef(pairs(graph.numhd.emm.condition))


plot(pairs(graph.numclust.emm.cond))
plot(pairs(graph.numclust.emm.cond), comparisons = TRUE)

graph.numclust.emm.cond.pairs$sig.levels <- 
  case_when(graph.numclust.emm.cond.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.numclust.emm.cond.pairs$p.value < .001 ~ sig.level.names[2],
            graph.numclust.emm.cond.pairs$p.value < .01 ~ sig.level.names[3],
            graph.numclust.emm.cond.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.numclust.emm.cond.pairs$sig.levels <- factor(graph.numclust.emm.cond.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)


graph.numclust.emm.cond.pairs$contrast <- factor(graph.numclust.emm.cond.pairs$contrast, levels=graph.numclust.emm.cond.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())

graph.numclust.emm.cond.pairs <- graph.numclust.emm.cond.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.numclust.emm.cond.pairs %>% arrange(estimate)

ggplot(graph.numclust.emm.cond.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.numclust.emm.cond.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

```

```{r}

copy <- graph.numclust.emm.cond.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         t.ratio=-t.ratio,
         lower.CL=-lower.CL,
         upper.CL=-upper.CL)

graph.numclust.emm.cond.pairs.compl <- bind_rows(graph.numclust.emm.cond.pairs,copy)


#cond.lev <- c("Ctrl","Phr","Col","Siz")

graph.numclust.emm.cond.pairs.compl$From <- factor(graph.numclust.emm.cond.pairs.compl$From, 
                                                   levels=rev(unique(graph.numclust.emm.cond.pairs.compl$From)))
#graph.numclust.emm.cond.pairs.compl$To <- factor(graph.numclust.emm.cond.pairs.compl$To, levels=cond.lev)

#graph.numlinks.emm.cond.pairs.compl %>% arrange(desc(estimate))
graph.numclust.emm.cond.pairs.compl %>% arrange(estimate)

ggplot(graph.numclust.emm.cond.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numclust.emm.cond.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numclust.emm.cond.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
    scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numclust.emm.cond.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")


```

###### networks

```{r, eval=FALSE}

# try a network of the pairwise significance values?  bleh...
# using igraph

graph <- graph_from_data_frame(graph.numclust.emm.cond.pairs %>% dplyr::select(-contrast), directed=TRUE)

E(graph)$width <- abs(E(graph)$estimate)*50
E(graph)$edge.color <- sig.colors[E(graph)$sig.levels]

graph

plot(graph, 
     edge.arrow.size=.5,
     vertex.frame.color="#555555")

```

```{r, eval=FALSE}

# using ggraph and tidygraph

graph <- graph_from_data_frame(graph.numclust.emm.cond.pairs %>% dplyr::select(-contrast), directed=TRUE)

# plot using ggraph
ggraph(graph, layout = 'kk') +
  geom_edge_link(aes(start_cap = label_rect(node1.name),
                       end_cap = label_rect(node2.name),
                     color=factor(sig.level.names[sig.levels]),
                     edge_width=.5/sig.levels
                     ), 
                   arrow = arrow(length = unit(4, 'mm')))+
  geom_node_text(label = vertex_attr(graph,"name")) +
  scale_edge_color_manual("Significance Levels", values=sig.colors) +
  scale_edge_width_continuous(labels=rev(sig.level.names)) +
  theme_graph()

```







##### Dataset

###### emmeans

```{r}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numhighdeg, table(Dataset,Overestimated))
# ref_grid(graph.numhd.lmer.full.int.4) @ grid; .wgt. is number of observations

graph.numclust.emm.data <- emmeans(graph.numclust.lmer.full.int.7, "Dataset", nesting = NULL)
#graph.numhd.emm.condition <- emmeans(graph.numhd.lmer.full.int.4, "Condition", lmer.df = "satterthwaite")

graph.numclust.emm.data

graph.numclust.emm.data.df <- dplyr::as_data_frame(graph.numclust.emm.data)

graph.numclust.emm.data.df


# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numhd.emm.condition)

graph.numclust.emm.data.cld <- cld(graph.numclust.emm.data,
                details=TRUE,
                #alpha=0.01,
                #by="Dataset",
                #Letters="|||||||||||||||||||",
                sort=TRUE
)

graph.numclust.emm.data.cld.df <- graph.numclust.emm.data.cld$emmeans

graph.numclust.emm.data.cld.df %>% dplyr::select(Dataset,.group)

graph.numclust.emm.data.cld.df

graph.numclust.emm.data.cld.df$Dataset <- factor(graph.numclust.emm.data.cld.df$Dataset, levels=graph.numclust.emm.data.cld.df %>% arrange(desc(emmean)) %>% dplyr::select(Dataset) %>% unlist())


#emmip(graph.numlinks.lmer.full.int, ~Condition, CIs = TRUE)
emmip(graph.numclust.emm.data, ~Dataset, CIs = TRUE)
plot(graph.numclust.emm.data)
#plot(graph.numlinks.emm.cond, comparisons = TRUE)

graph.numclust.emm.data.cld.df %>% arrange(desc(emmean))

ggplot(graph.numclust.emm.data.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Dataset,ymax=upper.CL,ymin=lower.CL), width=.2) +
  geom_point(aes(x=Dataset,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip() +
labs(title="Estimated Marginal Means for Dataset for Number of Clusters task,\ngraphics conditions")


#plot(ref_grid(graph.numnodes.lmer.int.3), by="Condition") 
# try to figure this out? maybe only works on the interaction?
```

```{r}

graph.numclust.emm.data.pairs <- dplyr::as_data_frame(pairs(graph.numclust.emm.data)) 
graph.numclust.emm.data.pairs
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

pairs.CI <- confint(pairs(graph.numclust.emm.data))

graph.numclust.emm.data.pairs <- full_join(graph.numclust.emm.data.pairs, pairs.CI)

#graph.numhd.diffemm.condition <- emmeans(graph.numhd.lmer.full.int.4, pairwise ~ Condition)
#graph.numhd.diffemm.condition$contrasts
#contrast(graph.numhd.emm.condition)
#confint(graph.numhd.emm.condition)
#pairs(graph.numhd.emm.condition, details=TRUE)
#confint(contrast(graph.numhd.emm.condition))
#confint(pairs(graph.numhd.emm.condition))
#coef(pairs(graph.numhd.emm.condition))


plot(pairs(graph.numclust.emm.data))
plot(pairs(graph.numclust.emm.data), comparisons = TRUE)

graph.numclust.emm.data.pairs$sig.levels <- 
  case_when(graph.numclust.emm.data.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.numclust.emm.data.pairs$p.value < .001 ~ sig.level.names[2],
            graph.numclust.emm.data.pairs$p.value < .01 ~ sig.level.names[3],
            graph.numclust.emm.data.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.numclust.emm.data.pairs$sig.levels <- factor(graph.numclust.emm.data.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)


graph.numclust.emm.data.pairs$contrast <- factor(graph.numclust.emm.data.pairs$contrast, levels=graph.numclust.emm.data.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())

graph.numclust.emm.data.pairs <- graph.numclust.emm.data.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.numclust.emm.data.pairs %>% arrange(estimate)

ggplot(graph.numclust.emm.data.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.numclust.emm.data.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

```

```{r}

data.copy <- graph.numclust.emm.data.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         t.ratio=-t.ratio,
         lower.CL=-lower.CL,
         upper.CL=-upper.CL)

graph.numclust.emm.data.pairs.compl <- bind_rows(graph.numclust.emm.data.pairs, data.copy)


#cond.lev <- c("Ctrl","Phr","Col","Siz")

#graph.numlinks.emm.data.pairs.compl$From <- factor(graph.numlinks.emm.data.pairs.compl$From, levels=cond.lev)
#graph.numlinks.emm.data.pairs.compl$To <- factor(graph.numlinks.emm.data.pairs.compl$To, levels=cond.lev)

graph.numclust.emm.data.pairs.compl$From <- factor(graph.numclust.emm.data.pairs.compl$From, levels=rev(unique(graph.numclust.emm.data.pairs.compl$From)))

#graph.numlinks.emm.cond.pairs.compl %>% arrange(desc(estimate))
graph.numclust.emm.data.pairs.compl %>% arrange(estimate)

ggplot(graph.numclust.emm.data.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numclust.emm.data.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numclust.emm.data.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
    scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numclust.emm.data.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")


```

##### Overestimated

###### emmeans

```{r}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numhighdeg, table(Dataset,Overestimated))
# ref_grid(graph.numhd.lmer.full.int.4) @ grid; .wgt. is number of observations

graph.numclust.emm.over <- emmeans(graph.numclust.lmer.full.int.7, "Overestimated", nesting = NULL)
#graph.numhd.emm.condition <- emmeans(graph.numhd.lmer.full.int.4, "Condition", lmer.df = "satterthwaite")

graph.numclust.emm.over

graph.numclust.emm.over.df <- dplyr::as_data_frame(graph.numclust.emm.over)

graph.numclust.emm.over.df


# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numhd.emm.condition)

graph.numclust.emm.over.cld <- cld(graph.numclust.emm.over,
                details=TRUE,
                #alpha=0.01,
                #by="Dataset",
                #Letters="|||||||||||||||||||",
                sort=TRUE
)

graph.numclust.emm.over.cld.df <- graph.numclust.emm.over.cld$emmeans

graph.numclust.emm.over.cld.df %>% dplyr::select(Overestimated,.group)

graph.numclust.emm.over.cld.df

graph.numclust.emm.over.cld.df$Overestimated <- factor(graph.numclust.emm.over.cld.df$Overestimated, levels=graph.numclust.emm.over.cld.df %>% arrange(desc(emmean)) %>% dplyr::select(Overestimated) %>% unlist())


#emmip(graph.numlinks.lmer.full.int, ~Condition, CIs = TRUE)
emmip(graph.numclust.emm.over, ~Overestimated, CIs = TRUE)
plot(graph.numclust.emm.over)
#plot(graph.numlinks.emm.cond, comparisons = TRUE)

graph.numlinks.emm.data.cld.df %>% arrange(desc(emmean))

ggplot(graph.numclust.emm.over.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Overestimated,ymax=upper.CL,ymin=lower.CL), width=.2) +
  geom_point(aes(x=Overestimated,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(labels=c("Overestimated","Correct or\nUnderestimated")) +
  coord_flip() +
labs(title="Estimated Marginal Means for Overestimated for Number of Clusters task,\ngraphics conditions")


#plot(ref_grid(graph.numnodes.lmer.int.3), by="Condition") 
# try to figure this out? maybe only works on the interaction?
```

```{r}

graph.numclust.emm.over.pairs <- dplyr::as_data_frame(pairs(graph.numclust.emm.over)) 
graph.numclust.emm.over.pairs
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

pairs.CI <- confint(pairs(graph.numclust.emm.over))

graph.numclust.emm.over.pairs <- full_join(graph.numclust.emm.over.pairs, pairs.CI)

#graph.numhd.diffemm.condition <- emmeans(graph.numhd.lmer.full.int.4, pairwise ~ Condition)
#graph.numhd.diffemm.condition$contrasts
#contrast(graph.numhd.emm.condition)
#confint(graph.numhd.emm.condition)
#pairs(graph.numhd.emm.condition, details=TRUE)
#confint(contrast(graph.numhd.emm.condition))
#confint(pairs(graph.numhd.emm.condition))
#coef(pairs(graph.numhd.emm.condition))


plot(pairs(graph.numclust.emm.over))
plot(pairs(graph.numclust.emm.over), comparisons = TRUE)

graph.numclust.emm.over.pairs$sig.levels <- 
  case_when(graph.numclust.emm.over.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.numclust.emm.over.pairs$p.value < .001 ~ sig.level.names[2],
            graph.numclust.emm.over.pairs$p.value < .01 ~ sig.level.names[3],
            graph.numclust.emm.over.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.numclust.emm.over.pairs$sig.levels <- factor(graph.numclust.emm.over.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)


graph.numclust.emm.over.pairs$contrast <- factor(graph.numclust.emm.over.pairs$contrast, levels=graph.numclust.emm.over.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())

graph.numclust.emm.over.pairs <- graph.numclust.emm.over.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.numclust.emm.over.pairs %>% arrange(estimate)

ggplot(graph.numclust.emm.over.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.numclust.emm.over.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

```

```{r}

over.copy <- graph.numclust.emm.over.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         t.ratio=-t.ratio,
         lower.CL=-lower.CL,
         upper.CL=-upper.CL)

graph.numclust.emm.over.pairs.compl <- bind_rows(graph.numclust.emm.over.pairs, over.copy)


#cond.lev <- c("Ctrl","Phr","Col","Siz")

#graph.numlinks.emm.data.pairs.compl$From <- factor(graph.numlinks.emm.data.pairs.compl$From, levels=cond.lev)
#graph.numlinks.emm.data.pairs.compl$To <- factor(graph.numlinks.emm.data.pairs.compl$To, levels=cond.lev)

graph.numclust.emm.over.pairs.compl$From <- factor(graph.numclust.emm.over.pairs.compl$From, levels=rev(unique(graph.numclust.emm.over.pairs.compl$From)))

#graph.numlinks.emm.cond.pairs.compl %>% arrange(desc(estimate))
graph.numclust.emm.over.pairs.compl %>% arrange(estimate)

ggplot(graph.numclust.emm.over.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numclust.emm.over.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numclust.emm.over.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
    scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numclust.emm.over.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")


```

##### Stats.OperatingSystemNumClust

###### emmeans

```{r}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numhighdeg, table(Dataset,Overestimated))
# ref_grid(graph.numhd.lmer.full.int.4) @ grid; .wgt. is number of observations

graph.numclust.emm.OS <- emmeans(graph.numclust.lmer.full.int.7, "Stats.OperatingSystemNumClust", nesting = NULL)
#graph.numhd.emm.condition <- emmeans(graph.numhd.lmer.full.int.4, "Condition", lmer.df = "satterthwaite")

graph.numclust.emm.OS

graph.numclust.emm.OS.df <- dplyr::as_data_frame(graph.numclust.emm.OS)

graph.numclust.emm.OS.df


# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numhd.emm.condition)

graph.numclust.emm.OS.cld <- cld(graph.numclust.emm.OS,
                details=TRUE,
                #alpha=0.01,
                #by="Dataset",
                #Letters="|||||||||||||||||||",
                sort=TRUE
)

graph.numclust.emm.OS.cld.df <- graph.numclust.emm.OS.cld$emmeans

graph.numclust.emm.OS.cld.df %>% dplyr::select(Stats.OperatingSystemNumClust,.group)

graph.numclust.emm.OS.cld.df

graph.numclust.emm.OS.cld.df$Stats.OperatingSystemNumClust <- factor(graph.numclust.emm.OS.cld.df$Stats.OperatingSystemNumClust, levels=graph.numclust.emm.OS.cld.df %>% arrange(desc(emmean)) %>% dplyr::select(Stats.OperatingSystemNumClust) %>% unlist())


#emmip(graph.numlinks.lmer.full.int, ~Condition, CIs = TRUE)
emmip(graph.numclust.emm.OS, ~Stats.OperatingSystemNumClust, CIs = TRUE)
plot(graph.numclust.emm.OS)
#plot(graph.numlinks.emm.cond, comparisons = TRUE)

graph.numclust.emm.OS.cld.df %>% arrange(desc(emmean))

ggplot(graph.numclust.emm.OS.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Stats.OperatingSystemNumClust,ymax=upper.CL,ymin=lower.CL), width=.2) +
  geom_point(aes(x=Stats.OperatingSystemNumClust,y=emmean), size=7) +
  scale_x_discrete(labels=c("High Error Group","Low Error Group")) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip() +
    labs(title="Estimated Marginal Means for Operating Systems for Number of Clusters task,\ngraphics conditions",
         x="Operating Systems")


#plot(ref_grid(graph.numnodes.lmer.int.3), by="Condition") 
# try to figure this out? maybe only works on the interaction?
```

```{r}

graph.numclust.emm.OS.pairs <- dplyr::as_data_frame(pairs(graph.numclust.emm.OS)) 
graph.numclust.emm.OS.pairs
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

pairs.CI <- confint(pairs(graph.numclust.emm.OS))

graph.numclust.emm.OS.pairs <- full_join(graph.numclust.emm.OS.pairs, pairs.CI)

#graph.numhd.diffemm.condition <- emmeans(graph.numhd.lmer.full.int.4, pairwise ~ Condition)
#graph.numhd.diffemm.condition$contrasts
#contrast(graph.numhd.emm.condition)
#confint(graph.numhd.emm.condition)
#pairs(graph.numhd.emm.condition, details=TRUE)
#confint(contrast(graph.numhd.emm.condition))
#confint(pairs(graph.numhd.emm.condition))
#coef(pairs(graph.numhd.emm.condition))


plot(pairs(graph.numclust.emm.OS))
plot(pairs(graph.numclust.emm.OS), comparisons = TRUE)

graph.numclust.emm.OS.pairs$sig.levels <- 
  case_when(graph.numclust.emm.OS.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.numclust.emm.OS.pairs$p.value < .001 ~ sig.level.names[2],
            graph.numclust.emm.OS.pairs$p.value < .01 ~ sig.level.names[3],
            graph.numclust.emm.OS.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.numclust.emm.OS.pairs$sig.levels <- factor(graph.numclust.emm.OS.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)


graph.numclust.emm.OS.pairs$contrast <- factor(graph.numclust.emm.OS.pairs$contrast, levels=graph.numclust.emm.OS.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())

graph.numclust.emm.OS.pairs <- graph.numclust.emm.OS.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.numclust.emm.OS.pairs %>% arrange(estimate)

ggplot(graph.numclust.emm.OS.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.numclust.emm.OS.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

```

```{r}

OS.copy <- graph.numclust.emm.OS.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         t.ratio=-t.ratio,
         lower.CL=-lower.CL,
         upper.CL=-upper.CL)

graph.numclust.emm.OS.pairs.compl <- bind_rows(graph.numclust.emm.OS.pairs, OS.copy)


#cond.lev <- c("Ctrl","Phr","Col","Siz")

#graph.numlinks.emm.data.pairs.compl$From <- factor(graph.numlinks.emm.data.pairs.compl$From, levels=cond.lev)
#graph.numlinks.emm.data.pairs.compl$To <- factor(graph.numlinks.emm.data.pairs.compl$To, levels=cond.lev)

graph.numclust.emm.OS.pairs.compl$From <- factor(graph.numclust.emm.OS.pairs.compl$From, levels=rev(unique(graph.numclust.emm.OS.pairs.compl$From)))

#graph.numlinks.emm.cond.pairs.compl %>% arrange(desc(estimate))
graph.numclust.emm.OS.pairs.compl %>% arrange(estimate)

ggplot(graph.numclust.emm.OS.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numclust.emm.OS.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numclust.emm.OS.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
    scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numclust.emm.OS.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")


```

##### ConditionColor:Dataset

###### emmeans 

```{r}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numnodes, table(Dataset,Underestimated))
# ref_grid(graph.numnodes.lmer.int.5) @ grid; .wgt. is number of observations

# See also: https://cran.r-project.org/web/packages/emmeans/vignettes/interactions.html

#graph.numnodes.emm.cond <- emmeans(graph.numnodes.lmer.int.3, "Condition", nesting = NULL)
graph.numclust.emm.conddata <- emmeans(graph.numclust.lmer.full.int.7, ~ Dataset | ConditionColor, nesting = NULL)
graph.numclust.emm.conddata.2 <- emmeans(graph.numclust.lmer.full.int.7, ~  ConditionColor | Dataset, nesting = NULL)

graph.numclust.emm.conddata

#graph.numnodes.diffemm.conddata <- emmeans(graph.numnodes.lmer.int.3, pairwise ~ Dataset | Condition, nesting = NULL)

#graph.numnodes.diffemm.conddata

graph.numclust.emm.conddata.df <- dplyr::as_data_frame(graph.numclust.emm.conddata)

graph.numclust.emm.conddata.df #%>% View()

# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numhd.emm.condition)

graph.numclust.emm.conddata.cld <- cld(graph.numclust.emm.conddata,
           details=TRUE,
           #alpha=0.01,
           #by="Dataset",
           #Letters="|||||||||||||||||||",
           sort=TRUE
           )

graph.numclust.emm.conddata.cld[["emmeans"]]


graph.numclust.emm.conddata.cld.df <- graph.numclust.emm.conddata.cld[["emmeans"]]

graph.numclust.emm.conddata.cld.df %>% dplyr::select(Dataset,ConditionColor,.group) %>% print()

cld(graph.numclust.emm.conddata.2, details=TRUE, sort=TRUE)[["emmeans"]] %>% dplyr::select(Dataset,ConditionColor,.group) %>% print()

# TO DO : get this to print as single table

#graph.numnodes.emm.conddata.cld.df$Condition <- factor(graph.numnodes.emm.conddata.cld.df$Condition, levels=graph.numnodes.emm.conddata.cld %>% arrange(desc(emmean)) %>% dplyr::select(Condition) %>% unlist())

#emmip(graph.numnodes.lmer.int.3, ~Condition, CIs = TRUE)
emmip(graph.numclust.emm.conddata, ~ConditionColor|Dataset, CIs = TRUE)
plot(graph.numclust.emm.conddata)
#plot(graph.numnodes.emm.conddata, comparisons = TRUE)

graph.numclust.emm.conddata.cld.df %>% arrange(desc(emmean))

ggplot(graph.numclust.emm.conddata.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=ConditionColor,ymax=upper.CL,ymin=lower.CL), width=.2) +
  #geom_point(aes(x=Condition,y=emmean), size=7) +
  geom_point(aes(x=ConditionColor,y=emmean)) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Dataset) + 
  coord_flip()

ggplot(graph.numclust.emm.conddata.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Dataset,ymax=upper.CL,ymin=lower.CL), width=.2) +
  #geom_point(aes(x=Condition,y=emmean), size=7) +
  geom_point(aes(x=Dataset,y=emmean)) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~ConditionColor)

ggplot(graph.numclust.emm.conddata.cld.df) +
  geom_errorbar(aes(x=Dataset,ymax=upper.CL,ymin=lower.CL, color=ConditionColor), width=.2, position=position_dodge(width=0.2)) +
  geom_point(aes(x=Dataset,y=emmean, color=ConditionColor), position=position_dodge(width=0.2)) +
  geom_line(aes(x=Dataset,y=emmean, color=ConditionColor, group=ConditionColor), position=position_dodge(width=0.2)) +
  scale_color_manual(labels=c("Blue","Black"),values=c("steelblue","black"), name="Node Color") +
  labs(title="Estimated Marginal Means for Node Color vs. Dataset for Number of Clusters task,\ngraphics conditions")


```

```{r}

graph.numclust.emm.conddata.pairs <- dplyr::as_data_frame(pairs(graph.numclust.emm.conddata)) 
graph.numclust.emm.conddata.pairs #%>% View()
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

conddata.pairs.CI <- confint(pairs(graph.numclust.emm.conddata))

graph.numclust.emm.conddata.pairs <- full_join(graph.numclust.emm.conddata.pairs, conddata.pairs.CI)

#graph.numnodes.diffemm.cond <- emmeans(graph.numnodes.lmer.int.3, pairwise ~ Condition)
#graph.numnodes.diffemm.cond$contrasts
#contrast(graph.numnodes.emm.cond)
#confint(graph.numnodes.emm.cond)
#pairs(graph.numnodes.emm.cond, details=TRUE)
#confint(contrast(graph.numnodes.emm.cond))
#confint(pairs(graph.numnodes.emm.cond))
#coef(pairs(graph.numnodes.emm.cond))

plot(pairs(graph.numclust.emm.conddata))
plot(pairs(graph.numclust.emm.conddata), comparisons = TRUE)

graph.numclust.emm.conddata.pairs$sig.levels <- 
  case_when(graph.numclust.emm.conddata.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.numclust.emm.conddata.pairs$p.value < .001 ~ sig.level.names[2],
            graph.numclust.emm.conddata.pairs$p.value < .01 ~ sig.level.names[3],
            graph.numclust.emm.conddata.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.numclust.emm.conddata.pairs$sig.levels <- factor(graph.numclust.emm.conddata.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)

graph.numclust.emm.conddata.pairs$contrast.cond <- paste0(graph.numclust.emm.conddata.pairs$contrast,graph.numclust.emm.conddata.pairs$Condition)

graph.numclust.emm.conddata.pairs$contrast.cond <- factor(graph.numclust.emm.conddata.pairs$contrast.cond, levels=graph.numclust.emm.conddata.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast.cond) %>% distinct() %>% unlist())

#graph.numnodes.emm.conddata.pairs %>% View()

graph.numclust.emm.conddata.pairs$contrast <- 
  factor(as.character(graph.numclust.emm.conddata.pairs$contrast), 
         levels=graph.numclust.emm.conddata.pairs %>% group_by(contrast) %>% summarise(avgEst = mean(estimate)) %>% arrange(desc(avgEst)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())


graph.numclust.emm.conddata.pairs <- graph.numclust.emm.conddata.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.numclust.emm.conddata.pairs %>% arrange(estimate)
#graph.numlinks.emm.conddata.pairs %>% View()

ggplot(graph.numclust.emm.conddata.pairs) +
  geom_errorbar(aes(x=contrast.cond,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast.cond,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~ConditionColor, scales="free_y") +
  coord_flip()

ggplot(graph.numclust.emm.conddata.pairs) +
  geom_errorbar(aes(x=contrast.cond,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast.cond,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~ConditionColor, scales="free_y") +
  coord_flip()


ggplot(graph.numclust.emm.conddata.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~ConditionColor, scales="free_y") +
  coord_flip()

ggplot(graph.numclust.emm.conddata.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~ConditionColor, scales="free_y") +
  coord_flip()


```


```{r}

conddata.copy <- graph.numclust.emm.conddata.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         t.ratio=-t.ratio,
         lower.CL=-lower.CL,
         upper.CL=-upper.CL)

graph.numclust.emm.conddata.pairs.compl <- bind_rows(graph.numclust.emm.conddata.pairs, conddata.copy)


#cond.lev <- c("Ctrl","Phr","Col","Siz")

#graph.numnodes.emm.conddata.pairs.compl$From <- factor(graph.numnodes.emm.conddata.pairs.compl$From, levels=cond.lev)
#graph.numnodes.emm.conddata.pairs.compl$To <- factor(graph.numnodes.emm.conddata.pairs.compl$To, levels=cond.lev)

graph.numclust.emm.conddata.pairs.compl$From <- factor(graph.numclust.emm.conddata.pairs.compl$From, levels=c(9,8,7,5,3,1))


#graph.numlinks.emm.conddata.pairs.compl %>% arrange(desc(estimate))
graph.numclust.emm.conddata.pairs.compl %>% arrange(estimate)

ggplot(graph.numclust.emm.conddata.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~ConditionColor)

ggplot(graph.numclust.emm.conddata.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~ConditionColor)

ggplot(graph.numclust.emm.conddata.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
    scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~ConditionColor)

ggplot(graph.numclust.emm.conddata.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~ConditionColor)


```



##### Overestimated:Stats.OperatingSystemNumClust

###### emmeans 

```{r}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numnodes, table(Dataset,Underestimated))
# ref_grid(graph.numnodes.lmer.int.5) @ grid; .wgt. is number of observations

# See also: https://cran.r-project.org/web/packages/emmeans/vignettes/interactions.html

#graph.numnodes.emm.cond <- emmeans(graph.numnodes.lmer.int.3, "Condition", nesting = NULL)
graph.numclust.emm.overnclust <- emmeans(graph.numclust.lmer.full.int.7, ~ Overestimated | Stats.OperatingSystemNumClust, nesting = NULL)
graph.numclust.emm.overnclust.2 <- emmeans(graph.numclust.lmer.full.int.7, ~ Stats.OperatingSystemNumClust | Overestimated, nesting = NULL)

graph.numclust.emm.overnclust

#graph.numnodes.diffemm.conddata <- emmeans(graph.numnodes.lmer.int.3, pairwise ~ Dataset | Condition, nesting = NULL)

#graph.numnodes.diffemm.conddata

graph.numclust.emm.overnclust.df <- dplyr::as_data_frame(graph.numclust.emm.overnclust)

graph.numclust.emm.overnclust.df #%>% View()

# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numhd.emm.condition)

graph.numclust.emm.overnclust.cld <- cld(graph.numclust.emm.overnclust,
           details=TRUE,
           #alpha=0.01,
           #by="Dataset",
           #Letters="|||||||||||||||||||",
           sort=TRUE
           )

graph.numclust.emm.overnclust.cld[["emmeans"]]


graph.numclust.emm.overnclust.cld.df <- graph.numclust.emm.overnclust.cld[["emmeans"]]

graph.numclust.emm.overnclust.cld.df %>% dplyr::select(Overestimated,Stats.OperatingSystemNumClust,.group) %>% print()

cld(graph.numclust.emm.overnclust.2, details=TRUE, sort=TRUE)[["emmeans"]] %>% dplyr::select(Overestimated,Stats.OperatingSystemNumClust,.group) %>% print()

# TO DO : get this to print as single table

#graph.numnodes.emm.conddata.cld.df$Condition <- factor(graph.numnodes.emm.conddata.cld.df$Condition, levels=graph.numnodes.emm.conddata.cld %>% arrange(desc(emmean)) %>% dplyr::select(Condition) %>% unlist())

#emmip(graph.numnodes.lmer.int.3, ~Condition, CIs = TRUE)
emmip(graph.numclust.emm.overnclust, ~Overestimated|Stats.OperatingSystemNumClust, CIs = TRUE)
plot(graph.numclust.emm.overnclust)
#plot(graph.numnodes.emm.conddata, comparisons = TRUE)

graph.numclust.emm.overnclust.cld.df %>% arrange(desc(emmean))

ggplot(graph.numclust.emm.overnclust.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Overestimated,ymax=upper.CL,ymin=lower.CL), width=.2) +
  #geom_point(aes(x=Condition,y=emmean), size=7) +
  geom_point(aes(x=Overestimated,y=emmean)) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Stats.OperatingSystemNumClust) + 
  coord_flip()

ggplot(graph.numclust.emm.overnclust.cld.df) +
  geom_errorbar(aes(x=Overestimated,ymax=upper.CL,ymin=lower.CL, color=Stats.OperatingSystemNumClust), width=.2) +
  geom_point(aes(x=Overestimated,y=emmean, color=Stats.OperatingSystemNumClust)) +
  geom_line(aes(x=Overestimated,y=emmean, color=Stats.OperatingSystemNumClust, group=Stats.OperatingSystemNumClust)) +
  scale_color_discrete(name="Operating\nSystems", labels=c("Low Error Group","High Error Group"))+
  scale_x_discrete(labels=c("Overestimated","Correct or\nUnderestimated")) +
labs(title="Estimated Marginal Means for Operating System vs. Overestimated for\nNumber of Clusters task, graphics conditions")

```

```{r}

graph.numclust.emm.overnclust.pairs <- dplyr::as_data_frame(pairs(graph.numclust.emm.overnclust)) 
graph.numclust.emm.overnclust.pairs #%>% View()
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

graph.numclust.emm.overnclust.2.pairs <- dplyr::as_data_frame(pairs(graph.numclust.emm.overnclust.2)) 
graph.numclust.emm.overnclust.2.pairs #%>% View()


overnclust.pairs.CI <- confint(pairs(graph.numclust.emm.overnclust))

graph.numclust.emm.overnclust.pairs <- full_join(graph.numclust.emm.overnclust.pairs, overnclust.pairs.CI)

#graph.numnodes.diffemm.cond <- emmeans(graph.numnodes.lmer.int.3, pairwise ~ Condition)
#graph.numnodes.diffemm.cond$contrasts
#contrast(graph.numnodes.emm.cond)
#confint(graph.numnodes.emm.cond)
#pairs(graph.numnodes.emm.cond, details=TRUE)
#confint(contrast(graph.numnodes.emm.cond))
#confint(pairs(graph.numnodes.emm.cond))
#coef(pairs(graph.numnodes.emm.cond))

plot(pairs(graph.numclust.emm.overnclust))
plot(pairs(graph.numclust.emm.overnclust), comparisons = TRUE)

graph.numclust.emm.overnclust.pairs$sig.levels <- 
  case_when(graph.numclust.emm.overnclust.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.numclust.emm.overnclust.pairs$p.value < .001 ~ sig.level.names[2],
            graph.numclust.emm.overnclust.pairs$p.value < .01 ~ sig.level.names[3],
            graph.numclust.emm.overnclust.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.numclust.emm.overnclust.pairs$sig.levels <- factor(graph.numclust.emm.overnclust.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)

graph.numclust.emm.overnclust.pairs$contrast.cond <- paste0(graph.numclust.emm.overnclust.pairs$contrast,graph.numclust.emm.overnclust.pairs$Stats.OperatingSystemNumClust)

graph.numclust.emm.overnclust.pairs$contrast.cond <- factor(graph.numclust.emm.overnclust.pairs$contrast.cond, levels=graph.numclust.emm.overnclust.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast.cond) %>% distinct() %>% unlist())

#graph.numnodes.emm.conddata.pairs %>% View()

graph.numclust.emm.overnclust.pairs$contrast <- 
  factor(as.character(graph.numclust.emm.overnclust.pairs$contrast), 
         levels=graph.numclust.emm.overnclust.pairs %>% group_by(contrast) %>% summarise(avgEst = mean(estimate)) %>% arrange(desc(avgEst)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())


graph.numclust.emm.overnclust.pairs <- graph.numclust.emm.overnclust.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.numclust.emm.overnclust.pairs %>% arrange(estimate)
#graph.numlinks.emm.conddata.pairs %>% View()

ggplot(graph.numclust.emm.overnclust.pairs) +
  geom_errorbar(aes(x=contrast.cond,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast.cond,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Stats.OperatingSystemNumClust, scales="free_y") +
  coord_flip()

ggplot(graph.numclust.emm.overnclust.pairs) +
  geom_errorbar(aes(x=contrast.cond,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast.cond,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Stats.OperatingSystemNumClust, scales="free_y") +
  coord_flip()


ggplot(graph.numclust.emm.overnclust.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Stats.OperatingSystemNumClust, scales="free_y") +
  coord_flip()

ggplot(graph.numclust.emm.overnclust.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Stats.OperatingSystemNumClust, scales="free_y") +
  coord_flip()


```


```{r}

overnclust.copy <- graph.numclust.emm.overnclust.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         t.ratio=-t.ratio,
         lower.CL=-lower.CL,
         upper.CL=-upper.CL)

graph.numclust.emm.overnclust.pairs.compl <- bind_rows(graph.numclust.emm.overnclust.pairs, overnclust.copy)


#cond.lev <- c("Ctrl","Phr","Col","Siz")

#graph.numnodes.emm.conddata.pairs.compl$From <- factor(graph.numnodes.emm.conddata.pairs.compl$From, levels=cond.lev)
#graph.numnodes.emm.conddata.pairs.compl$To <- factor(graph.numnodes.emm.conddata.pairs.compl$To, levels=cond.lev)

graph.numclust.emm.overnclust.pairs.compl$From <- factor(graph.numclust.emm.overnclust.pairs.compl$From, levels=rev(unique(graph.numclust.emm.overnclust.pairs.compl$From)))


#graph.numlinks.emm.conddata.pairs.compl %>% arrange(desc(estimate))
graph.numclust.emm.overnclust.pairs.compl %>% arrange(estimate)

ggplot(graph.numclust.emm.overnclust.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Stats.OperatingSystemNumClust)

ggplot(graph.numclust.emm.overnclust.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Stats.OperatingSystemNumClust)

ggplot(graph.numclust.emm.overnclust.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
    scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Stats.OperatingSystemNumClust)

ggplot(graph.numclust.emm.overnclust.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Stats.OperatingSystemNumClust)


```



### Degree of Highest Degree Node

#### lme4

```{r, cache=TRUE}

# Condition

graph.numhd.lmer.cond <- lmer(LogError ~ Condition + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer.cond) # Color and Phrasing very significant, Size not at all

anova(graph.numhd.lmer.cond)

# Condition is significant (p=2.557e-06); trying Ctrl_dummy

graph.numhd.lmer.ctrldummy <- lmer(LogError ~ Ctrl_dummy + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer.ctrldummy)

anova(graph.numhd.lmer.ctrldummy)

# Ctrl_dummy is significant (p=0.000624)

graph.numhd.lmer.condphr <- lmer(LogError ~ ConditionPhrasing + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer.condphr) 

anova(graph.numhd.lmer.condphr)

# ConditionPhrasing is significant (p=0.003696)

graph.numhd.lmer.condgr <- lmer(LogError ~ ConditionGraphics + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer.condgr) 

anova(graph.numhd.lmer.condgr)

# ConditionGraphics is significant (p=0.001828)

graph.numhd.lmer.condcol <- lmer(LogError ~ ConditionColor + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer.condcol) 

anova(graph.numhd.lmer.condcol)

# ConditionColor is significant (p=0.002186)


graph.numhd.lmer.dataset <- lmer(LogError ~ Dataset + (1|Demo.ResponseID), data = graphics_numhighdeg, REML = T)

lmsum <- summary(graph.numhd.lmer.dataset)
lmsum
#names(lmsum)

anova(graph.numhd.lmer.dataset)

# Dataset is significant (p < 1.3e-12); trying QuestionOrder

graph.numhd.lmer <- lmer(LogError ~ QuestionOrder + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer)

anova(graph.numhd.lmer)

# QuestionOrder is not significant; trying DatasetOrder

graph.numhd.lmer.dataord <- lmer(LogError ~ DatasetOrder + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer.dataord)

anova(graph.numhd.lmer.dataord)

# DatasetOrder is significant (p=0.005725); trying DatasetDuration

graph.numhd.lmer <- lmer(LogError ~ DatasetDuration + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer)

anova(graph.numhd.lmer)

# DatasetDuration is barely not significant (p=0.05675); trying DatasetStartTime

graph.numhd.lmer <- lmer(LogError ~ DatasetStartTime + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer)

anova(graph.numhd.lmer)

# DatasetStartTime is not significant; trying TaskOrder

graph.numhd.lmer <- lmer(LogError ~ TaskOrder + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer)

anova(graph.numhd.lmer)

# TaskOrder is not significant; trying CorrectAnswer

graph.numhd.lmer <- lmer(LogError ~ CorrectAnswer + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer)

anova(graph.numhd.lmer)

# CorrectAnswer is barely not significant (p = 0.05447); trying Underestimated

graph.numhd.lmer.underest <- lmer(LogError ~ Underestimated + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer.underest)

anova(graph.numhd.lmer.underest)

# Underestimated is highly significant (p = 6.661e-16); trying Overestimated

graph.numhd.lmer.overest <- lmer(LogError ~ Overestimated + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer.overest)

anova(graph.numhd.lmer.overest)

# Overestimated is highly significant (p = 1.165e); trying Stats.Q_TotalDuration

graph.numhd.lmer <- lmer(LogError ~ Stats.Q_TotalDuration + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer)

anova(graph.numhd.lmer)

# Stats.Q_TotalDuration is not significant; trying Stats.dataset_count

graph.numhd.lmer <- lmer(LogError ~ Stats.dataset_count + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer)

anova(graph.numhd.lmer)

# Stats.dataset_count is not significant; trying Stats.OperatingSystem

graph.numhd.lmer <- lmer(LogError ~ Stats.OperatingSystem + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer) # nothing significant

anova(graph.numhd.lmer)

# Stats.OperatingSystem is not significant (skipping combinations); trying StatsNumPixels

graph.numhd.lmer.pixels <- lmer(LogError ~ StatsNumPixels + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer.pixels)

anova(graph.numhd.lmer.pixels)

# StatsNumPixels is barely significant (p=0.02101); trying Demo.age

graph.numhd.lmer.age <- lmer(LogError ~ Demo.age + (1|Demo.ResponseID), data=graphics_numhighdeg %>% filter(!(is.na(Demo.age))), REML = T)

summary(graph.numhd.lmer.age)

anova(graph.numhd.lmer.age)

# Demo.age is significant (p=0.0159); trying Demo.gender

graph.numhd.lmer <- lmer(LogError ~ Demo.gender + (1|Demo.ResponseID), data=graphics_numhighdeg %>% filter(!(is.na(Demo.gender))), REML = T)

summary(graph.numhd.lmer)

anova(graph.numhd.lmer)

# Demo.gender is not significant; trying Demo.lang

graph.numhd.lmer <- lmer(LogError ~ Demo.lang + (1|Demo.ResponseID), data=graphics_numhighdeg %>% filter(!(is.na(Demo.lang))), REML = T)

summary(graph.numhd.lmer)

anova(graph.numhd.lmer)

# Demo.lang is not significant; trying Demo.educ

graph.numhd.lmer <- lmer(LogError ~ Demo.educ + (1|Demo.ResponseID), data=graphics_numhighdeg %>% filter(!(is.na(Demo.educ))), REML = T)

summary(graph.numhd.lmer)

anova(graph.numhd.lmer)

# Demo.educ is not significant; trying Demo.acfield

graph.numhd.lmer <- lmer(LogError ~ Demo.acfield + (1|Demo.ResponseID), data=graphics_numhighdeg %>% filter(!(is.na(Demo.acfield))), REML = T)

summary(graph.numhd.lmer) # nothing significant

anova(graph.numhd.lmer)

# Demo.acfield is not significant (skipping groups); trying Demo.dailytech_Computer

graph.numhd.lmer <- lmer(LogError ~ Demo.dailytech_Computer + (1|Demo.ResponseID), data=graphics_numhighdeg %>% filter(!(is.na(Demo.dailytech_Computer))), REML = T)

summary(graph.numhd.lmer)

anova(graph.numhd.lmer)

# Demo.dailytech_Computer is not significant; trying Demo.dailytech_Tablet

graph.numhd.lmer <- lmer(LogError ~ Demo.dailytech_Tablet + (1|Demo.ResponseID), data=graphics_numhighdeg %>% filter(!(is.na(Demo.dailytech_Tablet))), REML = T)

summary(graph.numhd.lmer)

anova(graph.numhd.lmer)

# Demo.dailytech_Computer is not significant; trying Demo.dailytech_SmartPhone

graph.numhd.lmer <- lmer(LogError ~ Demo.dailytech_SmartPhone + (1|Demo.ResponseID), data=graphics_numhighdeg %>% filter(!(is.na(Demo.dailytech_SmartPhone))), REML = T)

summary(graph.numhd.lmer)

anova(graph.numhd.lmer)

# Demo.dailytech_SmartPhone is not significant; trying Demo.weeklygaming

graph.numhd.lmer <- lmer(LogError ~ Demo.weeklygaming + (1|Demo.ResponseID), data=graphics_numhighdeg %>% filter(!(is.na(Demo.weeklygaming))), REML = T)

summary(graph.numhd.lmer)

anova(graph.numhd.lmer)

# Demo.weeklygaming is not significant; trying Demo.expdataanal

graph.numhd.lmer <- lmer(LogError ~ Demo.expdataanal + (1|Demo.ResponseID), data=graphics_numhighdeg %>% filter(!(is.na(Demo.expdataanal))), REML = T)

summary(graph.numhd.lmer)

anova(graph.numhd.lmer)

# Demo.expdataanal is not significant; trying Demo.expdatavis

graph.numhd.lmer <- lmer(LogError ~ Demo.expdatavis + (1|Demo.ResponseID), data=graphics_numhighdeg %>% filter(!(is.na(Demo.expdatavis))), REML = T)

summary(graph.numhd.lmer)

anova(graph.numhd.lmer)

# Demo.expdatavis is not significant; trying Demo.expreadnetvis

graph.numhd.lmer <- lmer(LogError ~ Demo.expreadnetvis + (1|Demo.ResponseID), data=graphics_numhighdeg %>% filter(!(is.na(Demo.expreadnetvis))), REML = T)

summary(graph.numhd.lmer)

anova(graph.numhd.lmer)

# Demo.expreadnetvis is not significant; trying Demo.expreadnetvis.alot

graph.numhd.lmer <- lmer(LogError ~ Demo.expreadnetvis.alot + (1|Demo.ResponseID), data=graphics_numhighdeg %>% filter(!(is.na(Demo.expreadnetvis.alot))), REML = T)

summary(graph.numhd.lmer)

anova(graph.numhd.lmer)

# Demo.expreadnetvis.alot is not significant; trying Demo.expcreatenetvis

graph.numhd.lmer <- lmer(LogError ~ Demo.expcreatenetvis + (1|Demo.ResponseID), data=graphics_numhighdeg %>% filter(!(is.na(Demo.expcreatenetvis))), REML = T)

summary(graph.numhd.lmer)

anova(graph.numhd.lmer)

# Demo.expcreatenetvis is not significant; trying Demo.expcreatenetvis.alot

graph.numhd.lmer <- lmer(LogError ~ Demo.expcreatenetvis.alot + (1|Demo.ResponseID), data=graphics_numhighdeg %>% filter(!(is.na(Demo.expcreatenetvis.alot))), REML = T)

summary(graph.numhd.lmer) # doesn't reach significance

anova(graph.numhd.lmer)

# Demo.expcreatenetvis.alot is not significant; trying AvgDeg

graph.numhd.lmer.avgdeg <- lmer(LogError ~ AvgDeg + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer.avgdeg)

anova(graph.numhd.lmer.avgdeg)

# AvgDeg is significant (p=6.871e-08); trying Density

graph.numhd.lmer.dens <- lmer(LogError ~ Density + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer.dens)

anova(graph.numhd.lmer.dens)

# Density is significant (p=1.913e-07); trying LargeClust1

graph.numhd.lmer.lgclust <- lmer(LogError ~ LargeClust1 + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer.lgclust)

anova(graph.numhd.lmer.lgclust)

# LargeClust1 is significant (p=5.644e-08); trying Modularity

graph.numhd.lmer.mod <- lmer(LogError ~ Modularity + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer.mod)

anova(graph.numhd.lmer.mod)

# Modularity is significant (p=0.000103); trying NumClust

graph.numhd.lmer.numclust <- lmer(LogError ~ NumClust + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer.numclust)

anova(graph.numhd.lmer.numclust)

# NumClust is significant (p=0.0008824); trying NumHighDegree

graph.numhd.lmer <- lmer(LogError ~ NumHighDegree + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer)

anova(graph.numhd.lmer)

# NumHighDegree is not quite significant (p=0.05447); trying NumLinks

graph.numhd.lmer <- lmer(LogError ~ NumLinks + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer)

anova(graph.numhd.lmer)

# NumLinks is not significant; trying NumNodes

graph.numhd.lmer.numnodes <- lmer(LogError ~ NumNodes + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer.numnodes)

anova(graph.numhd.lmer.numnodes)

# NumNodes is significant (p=0.0009184); trying NumNodesClust1

graph.numhd.lmer <- lmer(LogError ~ NumNodesClust1 + (1|Demo.ResponseID), data=graphics_numhighdeg, REML = T)

summary(graph.numhd.lmer)

anova(graph.numhd.lmer)

# NumNodesClust1 is not quite significant (p=0.05285); 


```

```{r}

# combinations of individual predictors

temp <- graphics_numhighdeg %>% dplyr::select(
  Demo.ResponseID, LogError, Condition, Ctrl_dummy, ConditionPhrasing, ConditionGraphics, ConditionColor, Dataset, DatasetOrder, Underestimated, Overestimated, StatsNumPixels, Demo.age, AvgDeg, Density, LargeClust1, Modularity, NumClust, NumNodes) %>% drop_na()

temp <- temp %>% mutate(StatsNumPixels=scale(StatsNumPixels))

graph.numhd.lmer.full <- lmer(LogError ~ Condition + 
                                Dataset +
                                DatasetOrder +
                                Overestimated +
                                StatsNumPixels +
                                (1|Demo.ResponseID), 
                              data=temp, REML = T)

summary(graph.numhd.lmer.full)

anova(graph.numhd.lmer.full)

```

```{r}

# interactions

graph.numhd.lmer.full.int <- lmer(LogError ~ Condition + 
                                    Dataset +
                                    DatasetOrder +
                                    Overestimated +
                                    StatsNumPixels +
                                    Condition:Dataset +
                                    (1|Demo.ResponseID), 
                                  data=temp, REML = T)

summary(graph.numhd.lmer.full.int)

anova(graph.numhd.lmer.full.int)

anova(graph.numhd.lmer.full.int,graph.numhd.lmer.full)

# definitely keep the interaction

graph.numhd.lmer.full.int.2 <- lmer(LogError ~ Condition + 
                                    Dataset +
                                    DatasetOrder +
                                    Overestimated +
                                    StatsNumPixels +
                                    Condition:Dataset +
                                      Dataset:Overestimated +
                                    (1|Demo.ResponseID), 
                                  data=temp, REML = T)

summary(graph.numhd.lmer.full.int.2)

anova(graph.numhd.lmer.full.int.2)

anova(graph.numhd.lmer.full.int.2,graph.numhd.lmer.full.int)

graph.numhd.lmer.full.int.3 <- lmer(LogError ~ Condition + 
                                    Dataset +
                                    DatasetOrder +
                                    Overestimated +
                                    StatsNumPixels +
                                    Condition:Dataset +
                                      Dataset:Overestimated +
                                      DatasetOrder:Overestimated +
                                    (1|Demo.ResponseID), 
                                  data=temp, REML = T)

summary(graph.numhd.lmer.full.int.3)

anova(graph.numhd.lmer.full.int.3)

anova(graph.numhd.lmer.full.int.3,graph.numhd.lmer.full.int.2)

# keeping graph.numhd.lmer.full.int.3

graph.numhd.lmer.full.int.4 <- lmer(LogError ~ Condition + 
                                    Dataset +
                                    Condition:Dataset +
                                      Dataset:Overestimated +
                                      DatasetOrder:Overestimated +
                                    (1|Demo.ResponseID), 
                                  data=temp, REML = T)

summary(graph.numhd.lmer.full.int.4)

anova(graph.numhd.lmer.full.int.4)

anova(graph.numhd.lmer.full.int.4, graph.numhd.lmer.full.int.3)

# no significant difference and 4 is way simpler, so keeping 4

graph.numhd.lmer.full.int.5 <- lmer(LogError ~ Condition + 
                                    Dataset +
                                    Condition:Dataset +
                                      Dataset:Overestimated +
                                      factor(DatasetOrder):Overestimated +
                                    (1|Demo.ResponseID), 
                                  data=temp, REML = T)

summary(graph.numhd.lmer.full.int.5)

anova(graph.numhd.lmer.full.int.5)

anova(graph.numhd.lmer.full.int.4)

anova(graph.numhd.lmer.full.int.4, graph.numhd.lmer.full.int.5)

# should keep 5, where datasetorder is treated as a factor; only a slight difference between 4 and 5

# redoing 5 with factor in the dataset

temp.numhd.gr <- temp %>% mutate(DatasetOrder=factor(DatasetOrder))

graph.numhd.lmer.full.int.6 <- lmer(LogError ~ Condition + 
                                    Dataset +
                                    Condition:Dataset +
                                      Dataset:Overestimated +
                                      DatasetOrder:Overestimated +
                                    (1|Demo.ResponseID), 
                                  data=temp.numhd.gr, REML = T)

summary(graph.numhd.lmer.full.int.6)

anova(graph.numhd.lmer.full.int.6)

```

```{r}

#SAVE THE RESULTS
save(graph.numhd.lmer.full.int.6, 
     file = file.path(analysisDataDir,"fits/graph_numhd_lmer_int.RData"))

```


```{r, cache=TRUE}

rand(graph.numhd.lmer.full.int.6)

# result shows that random effects of participant are *not* significant (p=1)

#ranef(graph.numhd.lmer.full.int.4)

# displays the random effects; not that useful

# unlike lme(), lmer() doesn't allow for heterogeneous error variance structures (the "weights")

(r2nsj = r2beta(graph.numhd.lmer.full.int.6, method = 'nsj', partial = TRUE))[1,'Rsq']

ggplot(graphics_numhighdeg) + geom_histogram(aes(LogError), binwidth=.005) + labs(title="Distribution of LogError values for Degree of Highest Degree Node task,\ngraphics conditions")



```

```{r}

plot(graph.numhd.lmer.full.int.6)

plot(graph.numhd.lmer.full.int.6, resid(., scaled=TRUE) ~ fitted(.), abline = 0)

plot(graph.numhd.lmer.full.int.6, resid(.) ~ fitted(.) | Condition, abline = 0)

plot(graph.numhd.lmer.full.int.6, resid(., scaled=TRUE) ~ fitted(.) | Condition, abline = 0)

plot(graph.numhd.lmer.full.int.6, LogError ~ fitted(.), abline = c(0,1))



```

```{r}

graph.numhd.lmer.full.int.6.f <- fortify(graph.numhd.lmer.full.int.6)

ggplot(graph.numhd.lmer.full.int.6.f, aes(.fitted,.resid)) + 
  geom_point() +
  #facet_grid(.~Sex) + 
  geom_hline(yintercept=0)

ggplot(graph.numhd.lmer.full.int.6.f, aes(.fitted,LogError)) + 
  geom_point() +
  geom_abline(aes(slope = 1, intercept = 0))

ggplot(graph.numhd.lmer.full.int.6.f, aes(LogError,.fitted)) +
geom_point() +
geom_abline(aes(slope = 1, intercept = 0)) +
#scale_y_continuous(limits=c(0,0.3)) +
labs(title="Real vs. Predicted LogError values for Degree of Highest Degree Node task,\ngraphics conditions")


```

```{r, eval=FALSE}

# TO DO: check out interpretation for these plots??

prof <-  profile(graph.numhd.lmer.full.int.4, optimizer="Nelder_Mead", which="beta_")

prof.CI <- confint(prof)

CI2 <- confint(graph.numhd.lmer.full.int.4, maxpts = 8)

xyplot(prof)

xyplot(prof, absVal = TRUE)

xyplot(prof, conf = c(0.95, 0.99), main = "95% and 99% profile() intervals")

# can also apply logProf() and varianceProf() to profile object

densityplot(prof)

splom(prof)

```

#### Least Squares Means

Do for each categorical predictor. 

Final model:
LogError ~ Condition + Dataset + Condition:Dataset + Dataset:Overestimated + DatasetOrder:Overestimated + (1|Demo.ResponseID)

##### Condition

###### lsmeans - older than, e.g., numnodes
```{r}

# trying lmerTest::lsmeansLT

# note = lmerTest::lsmeans will only report lsmeans for factor variables and is deprecated

graph.numhd.lsmlt.cond.2 <- lsmeansLT(graph.numhd.lmer.full.int.4, test.effs = "Condition")

plot(graph.numhd.lsmlt.cond.2) # not a completely terrible style, but not sorted properly

graph.numhd.lsmlt.cond.2.df <- as_data_frame(graph.numhd.lsmlt.cond.2$lsmeans.table)

graph.numhd.lsmlt.cond.2.df

graph.numhd.lsmlt.cond.2.df$Condition <- factor(graph.numhd.lsmlt.cond.2.df$Condition, levels=graph.numhd.lsmlt.cond.2.df %>% arrange(desc(Estimate)) %>% dplyr::select(Condition) %>% unlist())

graph.numhd.lsmlt.cond.2.df %>% arrange(desc(Estimate))

graph.numhd.lsmlt.cond.2.df <- graph.numhd.lsmlt.cond.2.df %>% 
  mutate(sig.levels = factor(case_when(
    `p-value` < .0001 ~ sig.level.names[1],
    `p-value` < .001 ~ sig.level.names[2],
    `p-value` < .01 ~ sig.level.names[3],
    `p-value` < .05 ~ sig.level.names[4],
    TRUE ~ sig.level.names[5]
    )
  ,levels=sig.level.names,ordered=TRUE))

graph.numhd.lsmlt.cond.2.df

ggplot(graph.numhd.lsmlt.cond.2.df) +
  geom_errorbar(aes(x=Condition,ymax=`Upper CI`,ymin=`Lower CI`), width=.2) +
  geom_point(aes(x=Condition,y=Estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

```

```{r}

# LSMeans Difference data

graph.numhd.difflsmlt.cond <- difflsmeans(graph.numhd.lmer.full.int.4, test.effs = "Condition")

plot(graph.numhd.difflsmlt.cond)

graph.numhd.difflsmlt.cond.df <- as_data_frame(graph.numhd.difflsmlt.cond$diffs.lsmeans.table, rownames="Pair")

graph.numhd.difflsmlt.cond.df

graph.numhd.difflsmlt.cond.df <- graph.numhd.difflsmlt.cond.df %>% mutate(Pair=sub("Condition ","",Pair)) %>% separate(Pair, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

copy <- graph.numhd.difflsmlt.cond.df %>% rename(From=To,To=From)

graph.numhd.difflsmlt.cond.df <- bind_rows(graph.numhd.difflsmlt.cond.df,copy)

graph.numhd.difflsmlt.cond.df$Pair <- factor(graph.numhd.difflsmlt.cond.df$Pair, levels=graph.numhd.difflsmlt.cond.df %>% arrange(desc(Estimate)) %>% dplyr::select(Pair) %>% distinct() %>% unlist())

cond.lev <- c("Ctrl","Phr","Col","Siz")

graph.numhd.difflsmlt.cond.df$From <- factor(graph.numhd.difflsmlt.cond.df$From, levels=cond.lev)
graph.numhd.difflsmlt.cond.df$To <- factor(graph.numhd.difflsmlt.cond.df$To, levels=cond.lev)

graph.numhd.difflsmlt.cond.df %>% arrange(desc(Estimate))

graph.numhd.difflsmlt.cond.df <- graph.numhd.difflsmlt.cond.df %>% 
  mutate(sig.levels = factor(case_when(
    `p-value` < .0001 ~ sig.level.names[1],
    `p-value` < .001 ~ sig.level.names[2],
    `p-value` < .01 ~ sig.level.names[3],
    `p-value` < .05 ~ sig.level.names[4],
    TRUE ~ sig.level.names[5]
    )
  ,levels=sig.level.names,ordered=TRUE))

ggplot(graph.numhd.difflsmlt.cond.df) +
  geom_errorbar(aes(x=Pair,ymax=`Upper CI`,ymin=`Lower CI`), width=.5) +
  geom_point(aes(x=Pair,y=Estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.numhd.difflsmlt.cond.df) +
  geom_errorbar(aes(x=Pair,ymax=`Upper CI`,ymin=`Lower CI`), width=.5) +
  geom_point(aes(x=Pair,y=Estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.numhd.difflsmlt.cond.df) +
  geom_tile(aes(x=To,y=ordered(From,levels=rev(cond.lev)),fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numhd.difflsmlt.cond.df) +
  geom_count(aes(x=To,y=ordered(From,levels=rev(cond.lev)),size=abs(Estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")
  
```

###### emmeans

```{r}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numhighdeg, table(Dataset,Overestimated))
# ref_grid(graph.numhd.lmer.full.int.4) @ grid; .wgt. is number of observations

graph.numhd.emm.cond <- emmeans(graph.numhd.lmer.full.int.6, "Condition", nesting = NULL)
#graph.numhd.emm.condition <- emmeans(graph.numhd.lmer.full.int.4, "Condition", lmer.df = "satterthwaite")

graph.numhd.emm.cond

graph.numhd.emm.cond.df <- dplyr::as_data_frame(graph.numhd.emm.cond)

graph.numhd.emm.cond.df

graph.numhd.emm.cond.cld <- cld(graph.numhd.emm.cond,
                                   details=TRUE,
                                   #alpha=0.01,
                                   #by="Dataset",
                                   #Letters="|||||||||||||||||||",
                                   sort=TRUE
)

graph.numhd.emm.cond.cld.df <- graph.numhd.emm.cond.cld$emmeans

graph.numhd.emm.cond.cld.df %>% dplyr::select(Condition,.group)

graph.numhd.emm.cond.cld.df

graph.numhd.emm.cond.cld.df$Condition <- factor(graph.numhd.emm.cond.cld.df$Condition, levels=graph.numhd.emm.cond.cld.df %>% arrange(desc(emmean)) %>% dplyr::select(Condition) %>% unlist())


#emmip(graph.numhd.lmer.full.int.4, ~Condition, CIs = TRUE)
emmip(graph.numhd.emm.cond, ~Condition, CIs = TRUE)
plot(graph.numhd.emm.cond)
#plot(graph.numhd.emm.cond, comparisons = TRUE)

graph.numhd.emm.cond.cld.df %>% arrange(desc(emmean))

ggplot(graph.numhd.emm.cond.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Condition,ymax=upper.CL,ymin=lower.CL), width=.2) +
  geom_point(aes(x=Condition,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip() +
labs(title="Estimated Marginal Means for Condition for Degree of\nHighest Degree Node task, graphics conditions")

#plot(ref_grid(graph.numhd.lmer.full.int.4), by="Condition") 
# try to figure this out? maybe only works on the interaction?

```

```{r}

graph.numhd.emm.cond.pairs <- dplyr::as_data_frame(pairs(graph.numhd.emm.cond)) 
graph.numhd.emm.cond.pairs
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

cond.pairs.CI <- confint(pairs(graph.numhd.emm.cond))

graph.numhd.emm.cond.pairs <- full_join(graph.numhd.emm.cond.pairs, cond.pairs.CI)

#graph.numhd.diffemm.condition <- emmeans(graph.numhd.lmer.full.int.4, pairwise ~ Condition)
#graph.numhd.diffemm.condition$contrasts
#contrast(graph.numhd.emm.condition)
#confint(graph.numhd.emm.condition)
#pairs(graph.numhd.emm.condition, details=TRUE)
#confint(contrast(graph.numhd.emm.condition))
#confint(pairs(graph.numhd.emm.condition))
#coef(pairs(graph.numhd.emm.condition))


plot(pairs(graph.numhd.emm.cond))
plot(pairs(graph.numhd.emm.cond), comparisons = TRUE)


graph.numhd.emm.cond.pairs$sig.levels <- 
  case_when(graph.numhd.emm.cond.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.numhd.emm.cond.pairs$p.value < .001 ~ sig.level.names[2],
            graph.numhd.emm.cond.pairs$p.value < .01 ~ sig.level.names[3],
            graph.numhd.emm.cond.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.numhd.emm.cond.pairs$sig.levels <- factor(graph.numhd.emm.cond.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)

graph.numhd.emm.cond.pairs$contrast <- factor(graph.numhd.emm.cond.pairs$contrast, levels=graph.numhd.emm.cond.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())

graph.numhd.emm.cond.pairs <- graph.numhd.emm.cond.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

ggplot(graph.numhd.emm.cond.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.numhd.emm.cond.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

```

```{r}

cond.copy <- graph.numhd.emm.cond.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         t.ratio=-t.ratio,
         lower.CL=-lower.CL,
         upper.CL=-upper.CL)

graph.numhd.emm.cond.pairs.compl <- bind_rows(graph.numhd.emm.cond.pairs, cond.copy)


cond.lev <- c("Ctrl","Phr","Col","Siz")

graph.numhd.emm.cond.pairs.compl$From <- factor(graph.numhd.emm.cond.pairs.compl$From, levels=cond.lev)
graph.numhd.emm.cond.pairs.compl$To <- factor(graph.numhd.emm.cond.pairs.compl$To, levels=cond.lev)

#graph.numlinks.emm.cond.pairs.compl %>% arrange(desc(estimate))
graph.numhd.emm.cond.pairs.compl %>% arrange(estimate)

ggplot(graph.numhd.emm.cond.pairs.compl) +
  geom_tile(aes(x=To,y=ordered(From,levels=rev(cond.lev)),fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numhd.emm.cond.pairs.compl) +
  geom_count(aes(x=To,y=ordered(From,levels=rev(cond.lev)),size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numhd.emm.cond.pairs.compl) +
  geom_tile(aes(x=To,y=ordered(From,levels=rev(cond.lev)),fill=estimate)) +
  scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numhd.emm.cond.pairs.compl) +
  geom_count(aes(x=To,y=ordered(From,levels=rev(cond.lev)),size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

```

###### networks

```{r, eval=FALSE}

# try a network of the pairwise significance values?  bleh...
# using igraph

graph <- graph_from_data_frame(graph.numhd.emm.cond.pairs %>% dplyr::select(-contrast), directed=TRUE)

E(graph)$width <- abs(E(graph)$estimate)*50
E(graph)$edge.color <- sig.colors[E(graph)$sig.levels]

graph

plot(graph, 
     edge.arrow.size=.5,
     vertex.frame.color="#555555")

```

```{r}

# using ggraph and tidygraph

graph <- graph_from_data_frame(graph.numhd.emm.cond.pairs %>% dplyr::select(-contrast), directed=TRUE)

# plot using ggraph
ggraph(graph, layout = 'kk') +
  geom_edge_link(aes(start_cap = label_rect(node1.name),
                       end_cap = label_rect(node2.name),
                     color=factor(sig.level.names[sig.levels]),
                     edge_width=.5/sig.levels
                     ), 
                   arrow = arrow(length = unit(4, 'mm')))+
  geom_node_text(label = vertex_attr(graph,"name")) +
  scale_edge_color_manual("Significance Levels", values=sig.colors) +
  scale_edge_width_continuous(labels=rev(sig.level.names)) +
  theme_graph()

```

##### Dataset

###### emmeans

```{r}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numhighdeg, table(Dataset,Overestimated))
# ref_grid(graph.numhd.lmer.full.int.4) @ grid; .wgt. is number of observations

graph.numhd.emm.data <- emmeans(graph.numhd.lmer.full.int.6, "Dataset", nesting = NULL)
#graph.numhd.emm.condition <- emmeans(graph.numhd.lmer.full.int.4, "Condition", lmer.df = "satterthwaite")

graph.numhd.emm.data

graph.numhd.emm.data.df <- dplyr::as_data_frame(graph.numhd.emm.data)

graph.numhd.emm.data.df


# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numhd.emm.condition)

graph.numhd.emm.data.cld <- cld(graph.numhd.emm.data,
                details=TRUE,
                #alpha=0.01,
                #by="Dataset",
                #Letters="|||||||||||||||||||",
                sort=TRUE
)

graph.numhd.emm.data.cld.df <- graph.numhd.emm.data.cld$emmeans

graph.numhd.emm.data.cld.df %>% dplyr::select(Dataset,.group)

graph.numhd.emm.data.cld.df

graph.numhd.emm.data.cld.df$Dataset <- factor(graph.numhd.emm.data.cld.df$Dataset, levels=graph.numhd.emm.data.cld.df %>% arrange(desc(emmean)) %>% dplyr::select(Dataset) %>% unlist())


#emmip(graph.numlinks.lmer.full.int, ~Condition, CIs = TRUE)
emmip(graph.numhd.emm.data, ~Dataset, CIs = TRUE)
plot(graph.numhd.emm.data)
#plot(graph.numlinks.emm.cond, comparisons = TRUE)

graph.numhd.emm.data.cld.df %>% arrange(desc(emmean))

ggplot(graph.numhd.emm.data.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Dataset,ymax=upper.CL,ymin=lower.CL), width=.2) +
  geom_point(aes(x=Dataset,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip() +
  labs(title="Estimated Marginal Means for Dataset for Degree of\nHighest Degree Node task, graphics conditions")



#plot(ref_grid(graph.numnodes.lmer.int.3), by="Condition") 
# try to figure this out? maybe only works on the interaction?
```

```{r}

graph.numhd.emm.data.pairs <- dplyr::as_data_frame(pairs(graph.numhd.emm.data)) 
graph.numhd.emm.data.pairs
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

pairs.CI <- confint(pairs(graph.numhd.emm.data))

graph.numhd.emm.data.pairs <- full_join(graph.numhd.emm.data.pairs, pairs.CI)

#graph.numhd.diffemm.condition <- emmeans(graph.numhd.lmer.full.int.4, pairwise ~ Condition)
#graph.numhd.diffemm.condition$contrasts
#contrast(graph.numhd.emm.condition)
#confint(graph.numhd.emm.condition)
#pairs(graph.numhd.emm.condition, details=TRUE)
#confint(contrast(graph.numhd.emm.condition))
#confint(pairs(graph.numhd.emm.condition))
#coef(pairs(graph.numhd.emm.condition))


plot(pairs(graph.numhd.emm.data))
plot(pairs(graph.numhd.emm.data), comparisons = TRUE)

graph.numhd.emm.data.pairs$sig.levels <- 
  case_when(graph.numhd.emm.data.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.numhd.emm.data.pairs$p.value < .001 ~ sig.level.names[2],
            graph.numhd.emm.data.pairs$p.value < .01 ~ sig.level.names[3],
            graph.numhd.emm.data.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.numhd.emm.data.pairs$sig.levels <- factor(graph.numhd.emm.data.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)


graph.numhd.emm.data.pairs$contrast <- factor(graph.numhd.emm.data.pairs$contrast, levels=graph.numhd.emm.data.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())

graph.numhd.emm.data.pairs <- graph.numhd.emm.data.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.numhd.emm.data.pairs %>% arrange(estimate)

ggplot(graph.numhd.emm.data.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.numhd.emm.data.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

```

```{r}

data.copy <- graph.numhd.emm.data.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         t.ratio=-t.ratio,
         lower.CL=-lower.CL,
         upper.CL=-upper.CL)

graph.numhd.emm.data.pairs.compl <- bind_rows(graph.numhd.emm.data.pairs, data.copy)


#cond.lev <- c("Ctrl","Phr","Col","Siz")

#graph.numlinks.emm.data.pairs.compl$From <- factor(graph.numlinks.emm.data.pairs.compl$From, levels=cond.lev)
#graph.numlinks.emm.data.pairs.compl$To <- factor(graph.numlinks.emm.data.pairs.compl$To, levels=cond.lev)

graph.numhd.emm.data.pairs.compl$From <- factor(graph.numhd.emm.data.pairs.compl$From, levels=rev(unique(graph.numhd.emm.data.pairs.compl$From)))

#graph.numhd.emm.data.pairs.compl %>% arrange(desc(estimate))
graph.numhd.emm.data.pairs.compl %>% arrange(estimate)

ggplot(graph.numhd.emm.data.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numhd.emm.data.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numhd.emm.data.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
    scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numhd.emm.data.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")


```

###### networks

```{r, eval=FALSE}

# try a network of the pairwise significance values?  bleh...
# using igraph

graph <- graph_from_data_frame(graph.numhd.emm.data.pairs %>% dplyr::select(-contrast), directed=TRUE)

E(graph)$width <- abs(E(graph)$estimate)*50
E(graph)$edge.color <- sig.colors[E(graph)$sig.levels]

graph

plot(graph, 
     edge.arrow.size=.5,
     vertex.frame.color="#555555")

```

```{r}

# using ggraph and tidygraph

graph <- graph_from_data_frame(graph.numhd.emm.data.pairs %>% dplyr::select(-contrast), directed=TRUE)

# plot using ggraph
ggraph(graph, layout = 'kk') +
  geom_edge_link(aes(start_cap = label_rect(node1.name),
                       end_cap = label_rect(node2.name),
                     color=factor(sig.level.names[sig.levels]),
                     edge_width=.5/sig.levels
                     ), 
                   arrow = arrow(length = unit(4, 'mm')))+
  geom_node_text(label = vertex_attr(graph,"name")) +
  scale_edge_color_manual("Significance Levels", values=sig.colors) +
  scale_edge_width_continuous(labels=rev(sig.level.names)) +
  theme_graph()

```

##### Condition:Dataset

###### emmeans

```{r}

# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numnodes, table(Dataset,Underestimated))
# ref_grid(graph.numnodes.lmer.int.5) @ grid; .wgt. is number of observations

# See also: https://cran.r-project.org/web/packages/emmeans/vignettes/interactions.html

#graph.numnodes.emm.cond <- emmeans(graph.numnodes.lmer.int.3, "Condition", nesting = NULL)
graph.numhd.emm.conddata <- emmeans(graph.numhd.lmer.full.int.6, ~ Dataset | Condition, nesting = NULL)
graph.numhd.emm.conddata.2 <- emmeans(graph.numhd.lmer.full.int.6, ~ Condition | Dataset, nesting = NULL)

graph.numhd.emm.conddata

#graph.numnodes.diffemm.conddata <- emmeans(graph.numnodes.lmer.int.3, pairwise ~ Dataset | Condition, nesting = NULL)

#graph.numnodes.diffemm.conddata

graph.numhd.emm.conddata.df <- dplyr::as_data_frame(graph.numhd.emm.conddata)

graph.numhd.emm.conddata.df #%>% View()

# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numhd.emm.condition)

graph.numhd.emm.conddata.cld <- cld(graph.numhd.emm.conddata,
                                       details=TRUE,
                                       #alpha=0.01,
                                       #by="Dataset",
                                       #Letters="|||||||||||||||||||",
                                       sort=TRUE
)

graph.numhd.emm.conddata.cld[["emmeans"]]


graph.numhd.emm.conddata.cld.df <- graph.numhd.emm.conddata.cld[["emmeans"]]

graph.numhd.emm.conddata.cld.df %>% dplyr::select(Dataset,Condition,.group) %>% print()

cld(graph.numhd.emm.conddata.2, details=TRUE, sort=TRUE)[["emmeans"]] %>% dplyr::select(Dataset,Condition,.group) %>% print()

# TO DO : get this to print as single table

#graph.numnodes.emm.conddata.cld.df$Condition <- factor(graph.numnodes.emm.conddata.cld.df$Condition, levels=graph.numnodes.emm.conddata.cld %>% arrange(desc(emmean)) %>% dplyr::select(Condition) %>% unlist())

#emmip(graph.numnodes.lmer.int.3, ~Condition, CIs = TRUE)
emmip(graph.numhd.emm.conddata, ~Condition|Dataset, CIs = TRUE)
plot(graph.numhd.emm.conddata)
#plot(graph.numnodes.emm.conddata, comparisons = TRUE)

graph.numhd.emm.conddata.cld.df %>% arrange(desc(emmean))

ggplot(graph.numhd.emm.conddata.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Condition,ymax=upper.CL,ymin=lower.CL), width=.2) +
  #geom_point(aes(x=Condition,y=emmean), size=7) +
  geom_point(aes(x=Condition,y=emmean)) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Dataset) + 
  coord_flip()

ggplot(graph.numhd.emm.conddata.cld.df) +
  geom_errorbar(aes(x=Dataset,ymax=upper.CL,ymin=lower.CL, color=Condition), width=.2, position=position_dodge(width=0.2)) +
  geom_point(aes(x=Dataset,y=emmean, color=Condition), position=position_dodge(width=0.2)) +
  geom_line(aes(x=Dataset,y=emmean, color=Condition, group=Condition), position=position_dodge(width=0.2)) +
  #scale_color_manual(labels=c("Blue","Black"),values=c("steelblue","black"), name="Node Color") +
  scale_color_discrete(labels=c("Control","Color","Phrasing","Size")) +
  labs(title="Estimated Marginal Means for Condition vs. Dataset for\nDegree of Highest Degree Node task, graphics conditions")

```

```{r}

graph.numhd.emm.conddata.pairs <- dplyr::as_data_frame(pairs(graph.numhd.emm.conddata)) 
graph.numhd.emm.conddata.pairs #%>% View()
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

conddata.pairs.CI <- confint(pairs(graph.numhd.emm.conddata))

graph.numhd.emm.conddata.pairs <- full_join(graph.numhd.emm.conddata.pairs, conddata.pairs.CI)

#graph.numnodes.diffemm.cond <- emmeans(graph.numnodes.lmer.int.3, pairwise ~ Condition)
#graph.numnodes.diffemm.cond$contrasts
#contrast(graph.numnodes.emm.cond)
#confint(graph.numnodes.emm.cond)
#pairs(graph.numnodes.emm.cond, details=TRUE)
#confint(contrast(graph.numnodes.emm.cond))
#confint(pairs(graph.numnodes.emm.cond))
#coef(pairs(graph.numnodes.emm.cond))

plot(pairs(graph.numhd.emm.conddata))
plot(pairs(graph.numhd.emm.conddata), comparisons = TRUE)

graph.numhd.emm.conddata.pairs$sig.levels <- 
  case_when(graph.numhd.emm.conddata.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.numhd.emm.conddata.pairs$p.value < .001 ~ sig.level.names[2],
            graph.numhd.emm.conddata.pairs$p.value < .01 ~ sig.level.names[3],
            graph.numhd.emm.conddata.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.numhd.emm.conddata.pairs$sig.levels <- factor(graph.numhd.emm.conddata.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)

graph.numhd.emm.conddata.pairs$contrast.cond <- paste0(graph.numhd.emm.conddata.pairs$contrast,graph.numhd.emm.conddata.pairs$Condition)

graph.numhd.emm.conddata.pairs$contrast.cond <- factor(graph.numhd.emm.conddata.pairs$contrast.cond, levels=graph.numhd.emm.conddata.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast.cond) %>% distinct() %>% unlist())

#graph.numhd.emm.conddata.pairs %>% View()

graph.numhd.emm.conddata.pairs$contrast <- 
  factor(as.character(graph.numhd.emm.conddata.pairs$contrast), 
         levels=graph.numhd.emm.conddata.pairs %>% group_by(contrast) %>% summarise(avgEst = mean(estimate)) %>% arrange(desc(avgEst)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())


graph.numhd.emm.conddata.pairs <- graph.numhd.emm.conddata.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.numhd.emm.conddata.pairs %>% arrange(estimate)
#graph.numlinks.emm.conddata.pairs %>% View()

ggplot(graph.numhd.emm.conddata.pairs) +
  geom_errorbar(aes(x=contrast.cond,ymax=upper.CL,ymin=lower.CL), width=.5) +
  #geom_point(aes(x=contrast.cond,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_point(aes(x=contrast.cond,y=estimate, fill=sig.levels), shape=21) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Condition, scales="free_y") +
  coord_flip()

ggplot(graph.numhd.emm.conddata.pairs) +
  geom_errorbar(aes(x=contrast.cond,ymax=upper.CL,ymin=lower.CL), width=.5) +
  #geom_point(aes(x=contrast.cond,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_point(aes(x=contrast.cond,y=estimate, fill=sig.levels), shape=21) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Condition, scales="free_y") +
  coord_flip()


ggplot(graph.numhd.emm.conddata.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  #geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Condition, scales="free_y") +
  coord_flip()

ggplot(graph.numhd.emm.conddata.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  #geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Condition, scales="free_y") +
  coord_flip()

```

```{r}

conddata.copy <- graph.numhd.emm.conddata.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         t.ratio=-t.ratio,
         lower.CL=-lower.CL,
         upper.CL=-upper.CL)

graph.numhd.emm.conddata.pairs.compl <- bind_rows(graph.numhd.emm.conddata.pairs, conddata.copy)


#cond.lev <- c("Ctrl","Phr","Col","Siz")

#graph.numnodes.emm.conddata.pairs.compl$From <- factor(graph.numnodes.emm.conddata.pairs.compl$From, levels=cond.lev)
#graph.numnodes.emm.conddata.pairs.compl$To <- factor(graph.numnodes.emm.conddata.pairs.compl$To, levels=cond.lev)

graph.numhd.emm.conddata.pairs.compl$From <- factor(graph.numhd.emm.conddata.pairs.compl$From, levels=c(9,8,7,5,3,1))


#graph.numlinks.emm.conddata.pairs.compl %>% arrange(desc(estimate))
graph.numhd.emm.conddata.pairs.compl %>% arrange(estimate)

ggplot(graph.numhd.emm.conddata.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Condition)

ggplot(graph.numhd.emm.conddata.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Condition)

ggplot(graph.numhd.emm.conddata.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
  scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Condition)

ggplot(graph.numhd.emm.conddata.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Condition)


```

##### Dataset:Overestimated

###### emmeans


```{r}

# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numnodes, table(Dataset,Underestimated))
# ref_grid(graph.numnodes.lmer.int.5) @ grid; .wgt. is number of observations

# See also: https://cran.r-project.org/web/packages/emmeans/vignettes/interactions.html

#graph.numnodes.emm.cond <- emmeans(graph.numnodes.lmer.int.3, "Condition", nesting = NULL)
graph.numhd.emm.dataover <- emmeans(graph.numhd.lmer.full.int.6, ~ Dataset | Overestimated, nesting = NULL)
graph.numhd.emm.dataover.2 <- emmeans(graph.numhd.lmer.full.int.6, ~ Overestimated | Dataset, nesting = NULL)

graph.numhd.emm.dataover

#graph.numnodes.diffemm.conddata <- emmeans(graph.numnodes.lmer.int.3, pairwise ~ Dataset | Condition, nesting = NULL)

#graph.numnodes.diffemm.conddata

graph.numhd.emm.dataover.df <- dplyr::as_data_frame(graph.numhd.emm.dataover)

graph.numhd.emm.dataover.df #%>% View()

# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numhd.emm.condition)

graph.numhd.emm.dataover.cld <- cld(graph.numhd.emm.dataover,
                                       details=TRUE,
                                       #alpha=0.01,
                                       #by="Dataset",
                                       #Letters="|||||||||||||||||||",
                                       sort=TRUE
)

graph.numhd.emm.dataover.cld[["emmeans"]]


graph.numhd.emm.dataover.cld.df <- graph.numhd.emm.dataover.cld[["emmeans"]]

graph.numhd.emm.dataover.cld.df %>% dplyr::select(Dataset,Overestimated,.group) %>% print()
cld(graph.numhd.emm.dataover.2, details=TRUE, sort=TRUE)[["emmeans"]] %>% dplyr::select(Dataset,Overestimated,.group) %>% print()

# TO DO : get this to print as single table

#graph.numnodes.emm.conddata.cld.df$Condition <- factor(graph.numnodes.emm.conddata.cld.df$Condition, levels=graph.numnodes.emm.conddata.cld %>% arrange(desc(emmean)) %>% dplyr::select(Condition) %>% unlist())

#emmip(graph.numnodes.lmer.int.3, ~Condition, CIs = TRUE)
emmip(graph.numhd.emm.dataover, ~Dataset|Overestimated, CIs = TRUE)
plot(graph.numhd.emm.dataover)
#plot(graph.numnodes.emm.conddata, comparisons = TRUE)

graph.numhd.emm.dataover.cld.df %>% arrange(desc(emmean))

ggplot(graph.numhd.emm.dataover.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Dataset,ymax=upper.CL,ymin=lower.CL), width=.2) +
  #geom_point(aes(x=Condition,y=emmean), size=7) +
  geom_point(aes(x=Dataset,y=emmean)) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Overestimated) + 
  coord_flip()

ggplot(graph.numhd.emm.dataover.cld.df) +
  geom_errorbar(aes(x=Dataset,ymax=upper.CL,ymin=lower.CL, color=Overestimated), width=.2, position=position_dodge(width=0.2)) +
  geom_point(aes(x=Dataset,y=emmean, color=Overestimated), position=position_dodge(width=0.2)) +
  geom_line(aes(x=Dataset,y=emmean, color=Overestimated, group=Overestimated), position=position_dodge(width=0.2)) +
  #scale_color_manual(labels=c("Blue","Black"),values=c("steelblue","black"), name="Node Color") +
  scale_color_discrete(labels=c("Overestimated","Correct or\nUnderestimated")) +
  labs(title="Estimated Marginal Means for Dataset vs. Overestimated for\nDegree of Highest Degree Node task, graphics conditions")



```

```{r}

graph.numhd.emm.dataover.pairs <- dplyr::as_data_frame(pairs(graph.numhd.emm.dataover)) 
graph.numhd.emm.dataover.pairs #%>% View()
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

dataover.pairs.CI <- confint(pairs(graph.numhd.emm.dataover))

graph.numhd.emm.dataover.pairs <- full_join(graph.numhd.emm.dataover.pairs, dataover.pairs.CI)

#graph.numnodes.diffemm.cond <- emmeans(graph.numnodes.lmer.int.3, pairwise ~ Condition)
#graph.numnodes.diffemm.cond$contrasts
#contrast(graph.numnodes.emm.cond)
#confint(graph.numnodes.emm.cond)
#pairs(graph.numnodes.emm.cond, details=TRUE)
#confint(contrast(graph.numnodes.emm.cond))
#confint(pairs(graph.numnodes.emm.cond))
#coef(pairs(graph.numnodes.emm.cond))

plot(pairs(graph.numhd.emm.dataover))
plot(pairs(graph.numhd.emm.dataover), comparisons = TRUE)

graph.numhd.emm.dataover.pairs$sig.levels <- 
  case_when(graph.numhd.emm.dataover.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.numhd.emm.dataover.pairs$p.value < .001 ~ sig.level.names[2],
            graph.numhd.emm.dataover.pairs$p.value < .01 ~ sig.level.names[3],
            graph.numhd.emm.dataover.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.numhd.emm.dataover.pairs$sig.levels <- factor(graph.numhd.emm.dataover.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)

graph.numhd.emm.dataover.pairs$contrast.all <- paste0(graph.numhd.emm.dataover.pairs$contrast,graph.numhd.emm.dataover.pairs$Overestimated)

graph.numhd.emm.dataover.pairs$contrast.all <- factor(graph.numhd.emm.dataover.pairs$contrast.all, levels=graph.numhd.emm.dataover.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast.all) %>% distinct() %>% unlist())

#graph.numhd.emm.conddata.pairs %>% View()

graph.numhd.emm.dataover.pairs$contrast <- 
  factor(as.character(graph.numhd.emm.dataover.pairs$contrast), 
         levels=graph.numhd.emm.dataover.pairs %>% group_by(contrast) %>% summarise(avgEst = mean(estimate)) %>% arrange(desc(avgEst)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())


graph.numhd.emm.dataover.pairs <- graph.numhd.emm.dataover.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.numhd.emm.dataover.pairs %>% arrange(estimate)
#graph.numlinks.emm.conddata.pairs %>% View()

ggplot(graph.numhd.emm.dataover.pairs) +
  geom_errorbar(aes(x=contrast.all,ymax=upper.CL,ymin=lower.CL), width=.5) +
  #geom_point(aes(x=contrast.cond,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_point(aes(x=contrast.all,y=estimate, fill=sig.levels), shape=21) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Overestimated, scales="free_y") +
  coord_flip()

ggplot(graph.numhd.emm.dataover.pairs) +
  geom_errorbar(aes(x=contrast.all,ymax=upper.CL,ymin=lower.CL), width=.5) +
  #geom_point(aes(x=contrast.cond,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_point(aes(x=contrast.all,y=estimate, fill=sig.levels), shape=21) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Overestimated, scales="free_y") +
  coord_flip()


ggplot(graph.numhd.emm.dataover.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  #geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Overestimated, scales="free_y") +
  coord_flip()

ggplot(graph.numhd.emm.dataover.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  #geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Overestimated, scales="free_y") +
  coord_flip()

```

```{r}

dataover.copy <- graph.numhd.emm.dataover.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         t.ratio=-t.ratio,
         lower.CL=-lower.CL,
         upper.CL=-upper.CL)

graph.numhd.emm.dataover.pairs.compl <- bind_rows(graph.numhd.emm.dataover.pairs, dataover.copy)


#cond.lev <- c("Ctrl","Phr","Col","Siz")

#graph.numnodes.emm.conddata.pairs.compl$From <- factor(graph.numnodes.emm.conddata.pairs.compl$From, levels=cond.lev)
#graph.numnodes.emm.conddata.pairs.compl$To <- factor(graph.numnodes.emm.conddata.pairs.compl$To, levels=cond.lev)

graph.numhd.emm.dataover.pairs.compl$From <- factor(graph.numhd.emm.dataover.pairs.compl$From, levels=c(9,8,7,5,3,1))


#graph.numlinks.emm.conddata.pairs.compl %>% arrange(desc(estimate))
graph.numhd.emm.dataover.pairs.compl %>% arrange(estimate)

ggplot(graph.numhd.emm.dataover.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Overestimated)

ggplot(graph.numhd.emm.dataover.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Overestimated)

ggplot(graph.numhd.emm.dataover.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
  scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Overestimated)

ggplot(graph.numhd.emm.dataover.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Overestimated)


```


##### DatasetOrder:Overestimated

TO DO : add factor to DatasetOrder at beginning

###### emmeans

```{r}

# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numnodes, table(Dataset,Underestimated))
# ref_grid(graph.numnodes.lmer.int.5) @ grid; .wgt. is number of observations

# See also: https://cran.r-project.org/web/packages/emmeans/vignettes/interactions.html

#graph.numnodes.emm.cond <- emmeans(graph.numnodes.lmer.int.3, "Condition", nesting = NULL)
graph.numhd.emm.dorderover <- emmeans(graph.numhd.lmer.full.int.6, ~ DatasetOrder | Overestimated, nesting = NULL)
graph.numhd.emm.dorderover.2 <- emmeans(graph.numhd.lmer.full.int.6, ~ Overestimated | DatasetOrder, nesting = NULL)

graph.numhd.emm.dorderover

#graph.numnodes.diffemm.conddata <- emmeans(graph.numnodes.lmer.int.3, pairwise ~ Dataset | Condition, nesting = NULL)

#graph.numnodes.diffemm.conddata

graph.numhd.emm.dorderover.df <- dplyr::as_data_frame(graph.numhd.emm.dorderover)

graph.numhd.emm.dorderover.df #%>% View()

# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numhd.emm.condition)

graph.numhd.emm.dorderover.cld <- cld(graph.numhd.emm.dorderover,
                                       details=TRUE,
                                       #alpha=0.01,
                                       #by="Dataset",
                                       #Letters="|||||||||||||||||||",
                                       sort=TRUE
)

graph.numhd.emm.dorderover.cld[["emmeans"]]


graph.numhd.emm.dorderover.cld.df <- graph.numhd.emm.dorderover.cld[["emmeans"]]

graph.numhd.emm.dorderover.cld.df %>% dplyr::select(DatasetOrder,Overestimated,.group) %>% print()
cld(graph.numhd.emm.dorderover.2, details=TRUE, sort=TRUE)[["emmeans"]] %>% dplyr::select(DatasetOrder,Overestimated,.group) %>% print()


# TO DO : get this to print as single table

#graph.numnodes.emm.conddata.cld.df$Condition <- factor(graph.numnodes.emm.conddata.cld.df$Condition, levels=graph.numnodes.emm.conddata.cld %>% arrange(desc(emmean)) %>% dplyr::select(Condition) %>% unlist())

#emmip(graph.numnodes.lmer.int.3, ~Condition, CIs = TRUE)
emmip(graph.numhd.emm.dorderover, ~DatasetOrder|Overestimated, CIs = TRUE)
plot(graph.numhd.emm.dorderover)
#plot(graph.numnodes.emm.conddata, comparisons = TRUE)

graph.numhd.emm.dorderover.cld.df %>% arrange(desc(emmean))

ggplot(graph.numhd.emm.dorderover.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=DatasetOrder,ymax=upper.CL,ymin=lower.CL), width=.2) +
  #geom_point(aes(x=Condition,y=emmean), size=7) +
  geom_point(aes(x=DatasetOrder,y=emmean)) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Overestimated) + 
  coord_flip()

ggplot(graph.numhd.emm.dorderover.cld.df) +
  geom_errorbar(aes(x=DatasetOrder,ymax=upper.CL,ymin=lower.CL, color=Overestimated), width=.2, position=position_dodge(width=0.2)) +
  geom_point(aes(x=DatasetOrder,y=emmean, color=Overestimated), position=position_dodge(width=0.2)) +
  geom_line(aes(x=DatasetOrder,y=emmean, color=Overestimated, group=Overestimated), position=position_dodge(width=0.2)) +
  #scale_color_manual(labels=c("Blue","Black"),values=c("steelblue","black"), name="Node Color") +
  scale_color_discrete(labels=c("Overestimated","Correct or\nUnderestimated")) +
  labs(title="Estimated Marginal Means for Dataset Order vs. Overestimated for\nDegree of Highest Degree Node task, graphics conditions", x="Dataset Order")


```

```{r, eval=FALSE}

graph.numhd.emm.dorderover.pairs <- dplyr::as_data_frame(pairs(graph.numhd.emm.dorderover)) 
graph.numhd.emm.dorderover.pairs #%>% View()
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

dorderover.pairs.CI <- confint(pairs(graph.numhd.emm.dorderover))

graph.numhd.emm.dorderover.pairs <- full_join(graph.numhd.emm.dorderover.pairs, dorderover.pairs.CI)

#graph.numnodes.diffemm.cond <- emmeans(graph.numnodes.lmer.int.3, pairwise ~ Condition)
#graph.numnodes.diffemm.cond$contrasts
#contrast(graph.numnodes.emm.cond)
#confint(graph.numnodes.emm.cond)
#pairs(graph.numnodes.emm.cond, details=TRUE)
#confint(contrast(graph.numnodes.emm.cond))
#confint(pairs(graph.numnodes.emm.cond))
#coef(pairs(graph.numnodes.emm.cond))

plot(pairs(graph.numhd.emm.dorderover))
plot(pairs(graph.numhd.emm.dorderover), comparisons = TRUE)

graph.numhd.emm.dorderover.pairs$sig.levels <- 
  case_when(graph.numhd.emm.dorderover.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.numhd.emm.dorderover.pairs$p.value < .001 ~ sig.level.names[2],
            graph.numhd.emm.dorderover.pairs$p.value < .01 ~ sig.level.names[3],
            graph.numhd.emm.dorderover.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.numhd.emm.dorderover.pairs$sig.levels <- factor(graph.numhd.emm.dorderover.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)

graph.numhd.emm.dorderover.pairs$contrast.all <- paste0(graph.numhd.emm.dorderover.pairs$contrast,graph.numhd.emm.dorderover.pairs$Overestimated)

graph.numhd.emm.dorderover.pairs$contrast.all <- factor(graph.numhd.emm.dorderover.pairs$contrast.all, levels=graph.numhd.emm.dorderover.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast.all) %>% distinct() %>% unlist())

#graph.numhd.emm.conddata.pairs %>% View()

graph.numhd.emm.dorderover.pairs$contrast <- 
  factor(as.character(graph.numhd.emm.dorderover.pairs$contrast), 
         levels=graph.numhd.emm.dorderover.pairs %>% group_by(contrast) %>% summarise(avgEst = mean(estimate)) %>% arrange(desc(avgEst)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())


graph.numhd.emm.dorderover.pairs <- graph.numhd.emm.dorderover.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.numhd.emm.dorderover.pairs %>% arrange(estimate)
#graph.numlinks.emm.conddata.pairs %>% View()

ggplot(graph.numhd.emm.dorderover.pairs) +
  geom_errorbar(aes(x=contrast.all,ymax=upper.CL,ymin=lower.CL), width=.5) +
  #geom_point(aes(x=contrast.cond,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_point(aes(x=contrast.all,y=estimate, fill=sig.levels), shape=21) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Overestimated, scales="free_y") +
  coord_flip()

ggplot(graph.numhd.emm.dorderover.pairs) +
  geom_errorbar(aes(x=contrast.all,ymax=upper.CL,ymin=lower.CL), width=.5) +
  #geom_point(aes(x=contrast.cond,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_point(aes(x=contrast.all,y=estimate, fill=sig.levels), shape=21) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Overestimated, scales="free_y") +
  coord_flip()


ggplot(graph.numhd.emm.dorderover.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  #geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Overestimated, scales="free_y") +
  coord_flip()

ggplot(graph.numhd.emm.dorderover.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  #geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Overestimated, scales="free_y") +
  coord_flip()

```

```{r, eval=FALSE}

dataover.copy <- graph.numhd.emm.dataover.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         t.ratio=-t.ratio,
         lower.CL=-lower.CL,
         upper.CL=-upper.CL)

graph.numhd.emm.dataover.pairs.compl <- bind_rows(graph.numhd.emm.dataover.pairs, dataover.copy)


#cond.lev <- c("Ctrl","Phr","Col","Siz")

#graph.numnodes.emm.conddata.pairs.compl$From <- factor(graph.numnodes.emm.conddata.pairs.compl$From, levels=cond.lev)
#graph.numnodes.emm.conddata.pairs.compl$To <- factor(graph.numnodes.emm.conddata.pairs.compl$To, levels=cond.lev)

graph.numhd.emm.dataover.pairs.compl$From <- factor(graph.numhd.emm.dataover.pairs.compl$From, levels=c(9,8,7,5,3,1))


#graph.numlinks.emm.conddata.pairs.compl %>% arrange(desc(estimate))
graph.numhd.emm.dataover.pairs.compl %>% arrange(estimate)

ggplot(graph.numhd.emm.dataover.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Overestimated)

ggplot(graph.numhd.emm.dataover.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Overestimated)

ggplot(graph.numhd.emm.dataover.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
  scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Overestimated)

ggplot(graph.numhd.emm.dataover.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Overestimated)


```


### Number of Links

#### lme4

```{r, cache=TRUE}

# Condition

graph.numlinks.lmer.cond <- lmer(LogError ~ Condition + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer.cond) # Size extremely significant

anova(graph.numlinks.lmer.cond)

# Condition is significant (p=1.665e-15); trying Ctrl_dummy

graph.numlinks.lmer.ctrldum <- lmer(LogError ~ Ctrl_dummy + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer.ctrldum)

anova(graph.numlinks.lmer.ctrldum)

# Ctrl_dummy is significant (p=0.02258)

graph.numlinks.lmer <- lmer(LogError ~ ConditionPhrasing + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer)

anova(graph.numlinks.lmer)

# ConditionPhrasing is not significanT

graph.numlinks.lmer.condgr <- lmer(LogError ~ ConditionGraphics + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer.condgr)

anova(graph.numlinks.lmer.condgr)

# ConditionGraphics is significant (p=5.218e-15)

graph.numlinks.lmer.condcol <- lmer(LogError ~ ConditionColor + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer.condcol)

anova(graph.numlinks.lmer.condcol)

# ConditionColor is significant (p=4.49e-10)

graph.numlinks.lmer.dataset <- lmer(LogError ~ Dataset + (1|Demo.ResponseID), data = graphics_numlinks, REML = T)

lmsum <- summary(graph.numlinks.lmer.dataset)
lmsum # all significantly different from 1 except 7
#names(lmsum)

anova(graph.numlinks.lmer.dataset)

# Dataset is significant (p < 2.2e-16); trying QuestionOrder

graph.numlinks.lmer <- lmer(LogError ~ QuestionOrder + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer)

anova(graph.numlinks.lmer)

# QuestionOrder is not significant; trying DatasetOrder

graph.numlinks.lmer <- lmer(LogError ~ DatasetOrder + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer)

anova(graph.numlinks.lmer)

# DatasetOrder is not significant; trying DatasetDuration

graph.numlinks.lmer.datadur <- lmer(LogError ~ DatasetDuration + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer.datadur)

anova(graph.numlinks.lmer.datadur)

# DatasetDuration is slightly significant (p=0.0222); trying DatasetStartTime

graph.numlinks.lmer <- lmer(LogError ~ DatasetStartTime + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer)

anova(graph.numlinks.lmer)

# DatasetStartTime is not significant; trying TaskOrder

graph.numlinks.lmer <- lmer(LogError ~ TaskOrder + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer)

anova(graph.numlinks.lmer)

# TaskOrder is not significant; trying CorrectAnswer

graph.numlinks.lmer.correct <- lmer(LogError ~ CorrectAnswer + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer.correct)

anova(graph.numlinks.lmer.correct)

# CorrectAnswer is highly significant (p = 2.2e-16); trying Underestimated

graph.numlinks.lmer.underest <- lmer(LogError ~ Underestimated + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer.underest)

anova(graph.numlinks.lmer.underest)

# Underestimated is significant (p = 9.057e-06); trying Overestimated

graph.numlinks.lmer.overest <- lmer(LogError ~ Overestimated + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer.overest)

anova(graph.numlinks.lmer.overest)

# Overestimated is significant (p = 3.747e-06); trying Stats.Q_TotalDuration

graph.numlinks.lmer <- lmer(LogError ~ Stats.Q_TotalDuration + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer)

anova(graph.numlinks.lmer)

# Stats.Q_TotalDuration is not significant; trying Stats.dataset_count

graph.numlinks.lmer <- lmer(LogError ~ Stats.dataset_count + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer)

anova(graph.numlinks.lmer)

# Stats.dataset_count is not signficant; trying Stats.OperatingSystem

graph.numlinks.lmer <- lmer(LogError ~ Stats.OperatingSystem + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer) # no categories significant

anova(graph.numlinks.lmer)

# Stats.OperatingSystem is not signficant; skipping combinations

#graph.numlinks.lmer <- lmer(LogError ~ StatsNumPixels + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

graphics_numlinks.CS <- graphics_numlinks %>% mutate(StatsNumPixels=scale(StatsNumPixels))

graph.numlinks.lmer <- lmer(LogError ~ StatsNumPixels + (1|Demo.ResponseID), data=graphics_numlinks.CS, REML = T)

summary(graph.numlinks.lmer)

anova(graph.numlinks.lmer)

# StatsNumPixels is not signficant; trying Demo.age

graph.numlinks.lmer <- lmer(LogError ~ Demo.age + (1|Demo.ResponseID), data=graphics_numlinks %>% filter(!(is.na(Demo.age))), REML = T)

summary(graph.numlinks.lmer)

anova(graph.numlinks.lmer)

# Demo.age is not signficant; trying Demo.gender

graph.numlinks.lmer <- lmer(LogError ~ Demo.gender + (1|Demo.ResponseID), data=graphics_numlinks %>% filter(!(is.na(Demo.gender))), REML = T)

summary(graph.numlinks.lmer)

anova(graph.numlinks.lmer)

# Demo.gender is barely signficant - nonbinary different from female (not interested in pursuing this); trying Demo.lang

graph.numlinks.lmer <- lmer(LogError ~ Demo.lang + (1|Demo.ResponseID), data=graphics_numlinks %>% filter(!(is.na(Demo.lang))), REML = T)

summary(graph.numlinks.lmer)

anova(graph.numlinks.lmer)

# Demo.lang is not signficant; trying Demo.educ

graph.numlinks.lmer <- lmer(LogError ~ Demo.educ + (1|Demo.ResponseID), data=graphics_numlinks %>% filter(!(is.na(Demo.educ))), REML = T)

summary(graph.numlinks.lmer)

anova(graph.numlinks.lmer)

# Demo.educ is not signficant; trying Demo.acfield

graph.numlinks.lmer <- lmer(LogError ~ Demo.acfield + (1|Demo.ResponseID), data=graphics_numlinks %>% filter(!(is.na(Demo.acfield))), REML = T)

summary(graph.numlinks.lmer) # only a couple of categories significant

anova(graph.numlinks.lmer)

# Demo.acfield is barely not signficant; trying Demo.acfieldGrouped

graph.numlinks.lmer <- lmer(LogError ~ Demo.acfieldGrouped + (1|Demo.ResponseID), data=graphics_numlinks %>% filter(!(is.na(Demo.acfieldGrouped))), REML = T)

summary(graph.numlinks.lmer)

anova(graph.numlinks.lmer)

# Demo.acfieldGrouped is less signficant

graph.numlinks.lmer <- lmer(LogError ~ Demo.acfieldGrouped2 + (1|Demo.ResponseID), data=graphics_numlinks %>% filter(!(is.na(Demo.acfieldGrouped2))), REML = T)

summary(graph.numlinks.lmer)

anova(graph.numlinks.lmer)

# Demo.acfieldGrouped2 is absolutely not signficant

graph.numlinks.lmer <- lmer(LogError ~ Demo.acfieldGrouped3 + (1|Demo.ResponseID), data=graphics_numlinks %>% filter(!(is.na(Demo.acfieldGrouped3))), REML = T)

summary(graph.numlinks.lmer)

anova(graph.numlinks.lmer)

# Demo.acfieldGrouped3 is just barely not signficant

graph.numlinks.lmer <- lmer(LogError ~ Demo.dailytech_Computer + (1|Demo.ResponseID), data=graphics_numlinks %>% filter(!(is.na(Demo.dailytech_Computer))), REML = T)

summary(graph.numlinks.lmer)

anova(graph.numlinks.lmer)

# Demo.dailytech_Computer is not significant; trying Demo.dailytech_Tablet

graph.numlinks.lmer <- lmer(LogError ~ Demo.dailytech_Tablet + (1|Demo.ResponseID), data=graphics_numlinks %>% filter(!(is.na(Demo.dailytech_Tablet))), REML = T)

summary(graph.numlinks.lmer)

anova(graph.numlinks.lmer)

# Demo.dailytech_Computer is not significant; trying Demo.dailytech_SmartPhone

graph.numlinks.lmer <- lmer(LogError ~ Demo.dailytech_SmartPhone + (1|Demo.ResponseID), data=graphics_numlinks %>% filter(!(is.na(Demo.dailytech_SmartPhone))), REML = T)

summary(graph.numlinks.lmer)

anova(graph.numlinks.lmer)

# Demo.dailytech_SmartPhone is barely significant; trying Demo.weeklygaming

graph.numlinks.lmer <- lmer(LogError ~ Demo.weeklygaming + (1|Demo.ResponseID), data=graphics_numlinks %>% filter(!(is.na(Demo.weeklygaming))), REML = T)

summary(graph.numlinks.lmer)

anova(graph.numlinks.lmer)

# Demo.weeklygaming is not significant; trying Demo.expdataanal

graph.numlinks.lmer <- lmer(LogError ~ Demo.expdataanal + (1|Demo.ResponseID), data=graphics_numlinks %>% filter(!(is.na(Demo.expdataanal))), REML = T)

summary(graph.numlinks.lmer)

anova(graph.numlinks.lmer)

# Demo.expdataanal is not significant; trying Demo.expdatavis

graph.numlinks.lmer <- lmer(LogError ~ Demo.expdatavis + (1|Demo.ResponseID), data=graphics_numlinks %>% filter(!(is.na(Demo.expdatavis))), REML = T)

summary(graph.numlinks.lmer)

anova(graph.numlinks.lmer)

# Demo.expdatavis is not significant; trying Demo.expreadnetvis

graph.numlinks.lmer <- lmer(LogError ~ Demo.expreadnetvis + (1|Demo.ResponseID), data=graphics_numlinks %>% filter(!(is.na(Demo.expreadnetvis))), REML = T)

summary(graph.numlinks.lmer) 

anova(graph.numlinks.lmer)

# Demo.expreadnetvis is not significant; trying Demo.expreadnetvis.alot

graph.numlinks.lmer <- lmer(LogError ~ Demo.expreadnetvis.alot + (1|Demo.ResponseID), data=graphics_numlinks %>% filter(!(is.na(Demo.expreadnetvis.alot))), REML = T)

summary(graph.numlinks.lmer)

anova(graph.numlinks.lmer)

# Demo.expreadnetvis.alot is not significant; trying Demo.expcreatenetvis

graph.numlinks.lmer <- lmer(LogError ~ Demo.expcreatenetvis + (1|Demo.ResponseID), data=graphics_numlinks %>% filter(!(is.na(Demo.expcreatenetvis))), REML = T)

summary(graph.numlinks.lmer) 

anova(graph.numlinks.lmer)

# Demo.expcreatenetvis is not significant; trying Demo.expcreatenetvis.alot

graph.numlinks.lmer <- lmer(LogError ~ Demo.expcreatenetvis.alot + (1|Demo.ResponseID), data=graphics_numlinks %>% filter(!(is.na(Demo.expcreatenetvis.alot))), REML = T)

summary(graph.numlinks.lmer) 

anova(graph.numlinks.lmer)

# Demo.expcreatenetvis.alot is not significant; trying AvgDeg

graph.numlinks.lmer.avgdeg <- lmer(LogError ~ AvgDeg + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer.avgdeg)

anova(graph.numlinks.lmer.avgdeg)

# AvgDeg is significant (p=2.871e-09); trying Density

graph.numlinks.lmer.dens <- lmer(LogError ~ Density + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer.dens)

anova(graph.numlinks.lmer.dens)

# Density is significant (p=2.629e-13); trying LargeClust1

graph.numlinks.lmer.lgclust <- lmer(LogError ~ LargeClust1 + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer.lgclust)

anova(graph.numlinks.lmer.lgclust)

# LargeClust1 is significant (p=3.531e-14); trying Modularity

graph.numlinks.lmer.mod <- lmer(LogError ~ Modularity + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer.mod)

anova(graph.numlinks.lmer.mod)

# Modularity is significant (p<2.2e-16); trying NumClust

graph.numlinks.lmer.numclust <- lmer(LogError ~ NumClust + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer.numclust)

anova(graph.numlinks.lmer.numclust)

# NumClust is significant (p<2.2e-16); trying NumHighDegree

graph.numlinks.lmer <- lmer(LogError ~ NumHighDegree + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer)

anova(graph.numlinks.lmer)

# NumHighDegree is not significant; trying NumLinks

graph.numlinks.lmer.numlinks <- lmer(LogError ~ NumLinks + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer.numlinks)

anova(graph.numlinks.lmer.numlinks)

# NumLinks is significant (p<2.2e-16); trying NumNodes

graph.numlinks.lmer.numnodes <- lmer(LogError ~ NumNodes + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer.numnodes)

anova(graph.numlinks.lmer.numnodes)

# NumNodes is significant (p<2.2e-16); trying NumNodesClust1

graph.numlinks.lmer.sizeclust1 <- lmer(LogError ~ NumNodesClust1 + (1|Demo.ResponseID), data=graphics_numlinks, REML = T)

summary(graph.numlinks.lmer.sizeclust1)

anova(graph.numlinks.lmer.sizeclust1)

# NumNodesClust1 is significant (p<2.2e-16); 


```

```{r}

temp <- graphics_numlinks %>% 
  dplyr::select(Demo.ResponseID,LogError,Condition,Ctrl_dummy,ConditionGraphics,
                ConditionColor,Dataset,DatasetDuration,CorrectAnswer,Underestimated,
                Overestimated,AvgDeg,Density,LargeClust1,Modularity,NumClust,NumLinks,
                NumNodes,NumNodesClust1) %>% drop_na()

graph.numlinks.lmer.full <- lmer(LogError ~ Condition + 
                                   Dataset +
                                   DatasetDuration +
                                   (1|Demo.ResponseID), 
                                 data=temp, REML = T)

summary(graph.numlinks.lmer.full)

anova(graph.numlinks.lmer.full)

```

```{r}


graph.numlinks.lmer.full.int <- lmer(LogError ~ Condition + 
                                   Dataset +
                                     Condition:Dataset +
                                   (1|Demo.ResponseID), 
                                 data=temp, REML = T)

summary(graph.numlinks.lmer.full.int)

anova(graph.numlinks.lmer.full.int)

anova(graph.numlinks.lmer.full,graph.numlinks.lmer.full.int)
# keep interaction

```

```{r}

#SAVE THE RESULTS
save(graph.numlinks.lmer.full.int, 
     file = file.path(analysisDataDir,"fits/graph_numlinks_lmer_int.RData"))

```


```{r, cache=TRUE}

rand(graph.numlinks.lmer.full.int)

# result shows that random effects of participant are significant (p=0.004)

anova(graph.numlinks.lmer.full.int)

# SmartPhone significant, < 0.01

#ranef(graph.avgdeg.lmer.SP)

# displays the random effects; not that useful

# unlike lme(), lmer() doesn't allow for heterogeneous error variance structures (the "weights")

(r2nsj = r2beta(graph.numlinks.lmer.full.int, method = 'nsj', partial = TRUE))[1,'Rsq']

ggplot(graphics_numlinks) + geom_histogram(aes(LogError), binwidth=.005) + labs(title="Distribution of LogError values for Number of Links task,\ngraphics conditions")


```

```{r}

plot(graph.numlinks.lmer.full.int)

plot(graph.numlinks.lmer.full.int, resid(., scaled=TRUE) ~ fitted(.), abline = 0)

plot(graph.numlinks.lmer.full.int, resid(.) ~ fitted(.) | Condition, abline = 0)

plot(graph.numlinks.lmer.full.int, resid(., scaled=TRUE) ~ fitted(.) | Condition, abline = 0)

plot(graph.numlinks.lmer.full.int, LogError ~ fitted(.), abline = c(0,1))



```

```{r}

graph.numlinks.lmer.full.int.f <- fortify(graph.numlinks.lmer.full.int)

ggplot(graph.numlinks.lmer.full.int.f, aes(.fitted,.resid)) + 
  geom_point() +
  #facet_grid(.~Sex) + 
  geom_hline(yintercept=0)

ggplot(graph.numlinks.lmer.full.int.f, aes(.fitted,LogError)) + 
  geom_point() +
  geom_abline(aes(slope = 1, intercept = 0))

ggplot(graph.numlinks.lmer.full.int.f, aes(LogError,.fitted)) +
geom_point() +
geom_abline(aes(slope = 1, intercept = 0)) +
#scale_y_continuous(limits=c(0,0.3)) +
labs(title="Real vs. Predicted LogError values for Number of Links task,\ngraphics conditions")

```

```{r, eval=FALSE}

# TO DO: check out interpretation for these plots??

library(lattice)

prof <-  profile(graph.avgdeg.lmer.SP, optimizer="Nelder_Mead", which="beta_")

prof.CI <- confint(prof)

#CI2 <- confint(graph.avgdeg.lmer.SP, maxpts = 8)

xyplot(prof)

xyplot(prof, absVal = TRUE)

xyplot(prof, conf = c(0.95, 0.99), main = "95% and 99% profile() intervals")

# can also apply logProf() and varianceProf() to profile object

densityplot(prof)

splom(prof)

```

#### brms/tidybayes

```{r, eval=FALSE}

# graph.numlinks.lmer.full.int <- lmer(LogError ~ Condition + Dataset + Condition:Dataset + (1|Demo.ResponseID), data=temp, REML = T)

#library(rstan)

theme_set(theme_grey())

#avgd.fit <- brm(LogError~Underestimated + Demo.dailytech_SmartPhone + (1|Demo.ResponseID), data = temp, REML=T)
numlinks.fit <- brm(LogError ~ Condition + Dataset + Condition:Dataset + (1|Demo.ResponseID), data = temp)

summary(numlinks.fit, waic = TRUE) 

#plot(numlinks.fit)

numlinks.fit$formula

#numlinks.fit %<>% recover_types(temp)

#tidybayes::parameters(numlinks.fit)


```

```{r}

#plot(fit, ask=FALSE) 
#plot(marginal_effects(fit, probs = c(0.05, 0.95)),points=TRUE, ask=FALSE)
#plot(marginal_effects(fit, probs = c(0.05, 0.95)),ask=FALSE)
plot(marginal_effects(numlinks.fit, effects="Dataset", probs = c(0.05, 0.95)),ask=FALSE)

```


```{r}

# all pairs

numlinks.pairs.2 <- c("Dataset.L = 0", # 3 vs. 1
         "Dataset.Q = 0",
         "Dataset.C = 0",
         "DatasetE4 = 0",
         "DatasetE5 = 0",
         "Dataset.Q - Dataset.L = 0", # 5 vs. 3
         "Dataset.C - Dataset.L = 0",
         "DatasetE4 - Dataset.L = 0",
         "DatasetE5 - Dataset.L = 0",
         "Dataset.C - Dataset.Q = 0", # 7 vs. 5
         "DatasetE4 - Dataset.Q = 0",
         "DatasetE5 - Dataset.Q = 0",
         "DatasetE4 - Dataset.C = 0", # 8 vs. 7
         "DatasetE5 - Dataset.C = 0",
         "DatasetE5 - DatasetE4 = 0")


(numlinks.pairs.2.res <- hypothesis(numlinks.fit, numlinks.pairs.2))

#plot(numlinks.pairs.2.res, chars = NULL, ask=FALSE)

numlinks.pairs.2.res.df <- numlinks.pairs.2.res$hypothesis

numlinks.pairs.2.res.df$contrast <- c("3-1","5-1","7-1","8-1","9-1","5-3","7-3","8-3","9-3","7-5","8-5","9-5","8-7","9-7","9-8")

numlinks.pairs.2.res.df$contrast <- factor(numlinks.pairs.2.res.df$contrast,
                                    levels=numlinks.pairs.2.res.df %>% arrange(desc(Estimate)) %>%
                                      dplyr::select(contrast) %>% unlist())

ggplot(numlinks.pairs.2.res.df, aes(contrast,Estimate)) + 
  geom_errorbar(aes(ymin=`l-95% CI`,ymax=`u-95% CI`)) +
  geom_point(aes(fill=Star=="*"), size=7, shape=21) +
  geom_hline(yintercept = 0) +
  scale_fill_manual(values=star.colors,name="Outside 95% CI") +
  coord_flip()

```

```{r}

numlinks.pairs.2.res.df <- numlinks.pairs.2.res.df %>% separate(contrast, c("From", "To"), sep="[-]", remove=FALSE)

copy <- numlinks.pairs.2.res.df %>% rename(From=To,To=From) %>% 
  mutate(Estimate=-Estimate,
         `l-95% CI`=-`l-95% CI`,
         `u-95% CI`=-`u-95% CI`)

pairs.compl <- bind_rows(numlinks.pairs.2.res.df, copy)


#cond.lev <- c("Ctrl","Phr","Col","Siz")

#graph.numnodes.emm.conddata.pairs.compl$From <- factor(graph.numnodes.emm.conddata.pairs.compl$From, levels=cond.lev)
#graph.numnodes.emm.conddata.pairs.compl$To <- factor(graph.numnodes.emm.conddata.pairs.compl$To, levels=cond.lev)

pairs.compl$From <- factor(pairs.compl$From, levels=c(9,8,7,5,3,1))
pairs.compl$To <- factor(pairs.compl$To, levels=c(1,3,5,7,8,9))

#graph.numlinks.emm.conddata.pairs.compl %>% arrange(desc(estimate))
pairs.compl %>% arrange(Estimate)

# can't get color to go the right direction
ggplot(pairs.compl %>% filter(Estimate >= 0)) +
  geom_tile(aes(x=To,y=From,fill=Estimate), color="black") +
  scale_fill_distiller(palette="Greys", direction=1) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(Estimate),fill=Star=="*"),shape=21, color="black") +
  scale_fill_manual(values=star.colors, name="Outside 95% CI") +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=Estimate)) +
  scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(Estimate),fill=Estimate, color=Star=="*"), shape=21,stroke=1) +
  scale_fill_distiller(type="div", palette=4, limits=c(-max(abs(pairs.compl$Estimate)),max(abs(pairs.compl$Estimate)))) +
  scale_color_manual(values=c("grey90","black"), name="Outside 95% CI") +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

numlinks.pairs.2.res.df$From <- factor(numlinks.pairs.2.res.df$From, levels=c(9,8,7,5,3,1))
numlinks.pairs.2.res.df$To <- factor(numlinks.pairs.2.res.df$To, levels=c(1,3,5,7,8,9))


ggplot(numlinks.pairs.2.res.df) +
  geom_count(aes(x=To,y=From,size=abs(Estimate),fill=Estimate, color=Star=="*"), shape=21,stroke=1) +
  scale_fill_distiller(type="div", palette=4, limits=c(-max(abs(pairs.compl$Estimate)),max(abs(pairs.compl$Estimate)))) +
  scale_color_manual(values=c("grey90","black"), name="Outside 95% CI") +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")




```


#### Least Squares Means

Do for each categorical predictor. 
Final model: LogError ~ Condition + Dataset + Condition:Dataset + (1 | Demo.ResponseID)

##### Condition

###### lsmeans

```{r}

# trying lmerTest::lsmeansLT

# note = lmerTest::lsmeans will only report lsmeans for factor variables and is deprecated

graph.numlinks.lsmlt.cond <- lsmeansLT(graph.numlinks.lmer.full.int, test.effs = "Condition")

plot(graph.numlinks.lsmlt.cond) # not a completely terrible style, but not sorted properly

graph.numlinks.lsmlt.cond.df <- dplyr::as_data_frame(graph.numlinks.lsmlt.cond$lsmeans.table)

graph.numlinks.lsmlt.cond.df

graph.numlinks.lsmlt.cond.df$Condition <- factor(graph.numlinks.lsmlt.cond.df$Condition, levels=graph.numlinks.lsmlt.cond.df %>% arrange(desc(Estimate)) %>% dplyr::select(Condition) %>% unlist())

graph.numlinks.lsmlt.cond.df %>% arrange(desc(Estimate))

graph.numlinks.lsmlt.cond.df <- graph.numlinks.lsmlt.cond.df %>% 
  mutate(sig.levels = factor(case_when(
    `p-value` < .0001 ~ sig.level.names[1],
    `p-value` < .001 ~ sig.level.names[2],
    `p-value` < .01 ~ sig.level.names[3],
    `p-value` < .05 ~ sig.level.names[4],
    TRUE ~ sig.level.names[5]
    )
  ,levels=sig.level.names,ordered=TRUE))

graph.numlinks.lsmlt.cond.df

ggplot(graph.numlinks.lsmlt.cond.df) +
  geom_errorbar(aes(x=Condition,ymax=`Upper CI`,ymin=`Lower CI`), width=.2) +
  geom_point(aes(x=Condition,y=Estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

```

```{r}

# LSMeans Difference data

graph.numlinks.difflsmlt.cond <- difflsmeans(graph.numlinks.lmer.full.int, test.effs = "Condition")

plot(graph.numlinks.difflsmlt.cond)

graph.numlinks.difflsmlt.cond.df <- dplyr::as_data_frame(graph.numlinks.difflsmlt.cond$diffs.lsmeans.table, rownames="Pair")

graph.numlinks.difflsmlt.cond.df

graph.numlinks.difflsmlt.cond.df <- graph.numlinks.difflsmlt.cond.df %>% mutate(Pair=sub("Condition ","",Pair)) %>% separate(Pair, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.numlinks.difflsmlt.cond.df$sig.levels <- 
  case_when(graph.numlinks.difflsmlt.cond.df$`p-value` < .0001 ~ sig.level.names[1],
            graph.numlinks.difflsmlt.cond.df$`p-value` < .001 ~ sig.level.names[2],
            graph.numlinks.difflsmlt.cond.df$`p-value` < .01 ~ sig.level.names[3],
            graph.numlinks.difflsmlt.cond.df$`p-value` < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.numlinks.difflsmlt.cond.df$sig.levels <- factor(graph.numlinks.difflsmlt.cond.df$sig.levels, levels=sig.level.names,ordered=TRUE)

graph.numlinks.difflsmlt.cond.df$Pair <- factor(graph.numlinks.difflsmlt.cond.df$Pair, levels=graph.numlinks.difflsmlt.cond.df %>% arrange(desc(Estimate)) %>% dplyr::select(Pair) %>% distinct() %>% unlist())

#graph.numlinks.difflsmlt.cond.df %>% arrange(desc(Estimate))
graph.numlinks.difflsmlt.cond.df %>% arrange(Estimate)

ggplot(graph.numlinks.difflsmlt.cond.df) +
  geom_errorbar(aes(x=Pair,ymax=`Upper CI`,ymin=`Lower CI`), width=.5) +
  geom_point(aes(x=Pair,y=Estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.numlinks.difflsmlt.cond.df) +
  geom_errorbar(aes(x=Pair,ymax=`Upper CI`,ymin=`Lower CI`), width=.5) +
  geom_point(aes(x=Pair,y=Estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()




cond.copy <- graph.numlinks.difflsmlt.cond.df %>% rename(From=To,To=From) %>%
    mutate(Estimate=-Estimate,
         `t-value`=-`t-value`,
         `Lower CI`=-`Lower CI`,
         `Upper CI`=-`Upper CI`)

graph.numlinks.difflsmlt.cond.df.full <- bind_rows(graph.numlinks.difflsmlt.cond.df, cond.copy)

cond.lev <- c("Ctrl","Phr","Col","Siz")

graph.numlinks.difflsmlt.cond.df.full$From <- factor(graph.numlinks.difflsmlt.cond.df.full$From, levels=cond.lev)
graph.numlinks.difflsmlt.cond.df.full$To <- factor(graph.numlinks.difflsmlt.cond.df.full$To, levels=cond.lev)


ggplot(graph.numlinks.difflsmlt.cond.df.full) +
  geom_tile(aes(x=To,y=ordered(From,levels=rev(cond.lev)),fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numlinks.difflsmlt.cond.df.full) +
  geom_count(aes(x=To,y=ordered(From,levels=rev(cond.lev)),size=abs(Estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")
  
```

###### emmeans

```{r}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numhighdeg, table(Dataset,Overestimated))
# ref_grid(graph.numhd.lmer.full.int.4) @ grid; .wgt. is number of observations

graph.numlinks.emm.cond <- emmeans(graph.numlinks.lmer.full.int, "Condition", nesting = NULL)
#graph.numhd.emm.condition <- emmeans(graph.numhd.lmer.full.int.4, "Condition", lmer.df = "satterthwaite")

graph.numlinks.emm.cond

graph.numlinks.emm.cond.df <- dplyr::as_data_frame(graph.numlinks.emm.cond)

graph.numlinks.emm.cond.df


# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numhd.emm.condition)

graph.numlinks.emm.cond.cld <- cld(graph.numlinks.emm.cond,
                details=TRUE,
                #alpha=0.01,
                #by="Dataset",
                #Letters="|||||||||||||||||||",
                sort=TRUE
)

graph.numlinks.emm.cond.cld.df <- graph.numlinks.emm.cond.cld$emmeans

graph.numlinks.emm.cond.cld.df %>% dplyr::select(Condition,.group)

graph.numlinks.emm.cond.cld.df

graph.numlinks.emm.cond.cld.df$Condition <- factor(graph.numlinks.emm.cond.cld.df$Condition, levels=graph.numlinks.emm.cond.cld.df %>% arrange(desc(emmean)) %>% dplyr::select(Condition) %>% unlist())


#emmip(graph.numlinks.lmer.full.int, ~Condition, CIs = TRUE)
emmip(graph.numlinks.emm.cond, ~Condition, CIs = TRUE)
plot(graph.numlinks.emm.cond)
#plot(graph.numlinks.emm.cond, comparisons = TRUE)

graph.numlinks.emm.cond.cld.df %>% arrange(desc(emmean))

ggplot(graph.numlinks.emm.cond.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Condition,ymax=upper.CL,ymin=lower.CL), width=.2) +
  geom_point(aes(x=Condition,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.numlinks.emm.cond.cld.df) +
  geom_errorbar(aes(x=Condition,ymax=upper.CL,ymin=lower.CL), width=.2) +
  geom_point(aes(x=Condition,y=emmean), size=7) +
  coord_flip() +
labs(title="Estimated Marginal Means for Condition for Number of Links task,\ngraphics conditions")


#plot(ref_grid(graph.numnodes.lmer.int.3), by="Condition") 
# try to figure this out? maybe only works on the interaction?
```

```{r}

graph.numlinks.emm.cond.pairs <- dplyr::as_data_frame(pairs(graph.numlinks.emm.cond)) 
graph.numlinks.emm.cond.pairs
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

pairs.CI <- confint(pairs(graph.numlinks.emm.cond))

graph.numlinks.emm.cond.pairs <- full_join(graph.numlinks.emm.cond.pairs, pairs.CI)

#graph.numhd.diffemm.condition <- emmeans(graph.numhd.lmer.full.int.4, pairwise ~ Condition)
#graph.numhd.diffemm.condition$contrasts
#contrast(graph.numhd.emm.condition)
#confint(graph.numhd.emm.condition)
#pairs(graph.numhd.emm.condition, details=TRUE)
#confint(contrast(graph.numhd.emm.condition))
#confint(pairs(graph.numhd.emm.condition))
#coef(pairs(graph.numhd.emm.condition))


plot(pairs(graph.numlinks.emm.cond))
plot(pairs(graph.numlinks.emm.cond), comparisons = TRUE)

graph.numlinks.emm.cond.pairs$sig.levels <- 
  case_when(graph.numlinks.emm.cond.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.numlinks.emm.cond.pairs$p.value < .001 ~ sig.level.names[2],
            graph.numlinks.emm.cond.pairs$p.value < .01 ~ sig.level.names[3],
            graph.numlinks.emm.cond.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.numlinks.emm.cond.pairs$sig.levels <- factor(graph.numlinks.emm.cond.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)


graph.numlinks.emm.cond.pairs$contrast <- factor(graph.numlinks.emm.cond.pairs$contrast, levels=graph.numlinks.emm.cond.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())

graph.numlinks.emm.cond.pairs <- graph.numlinks.emm.cond.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.numnodes.emm.cond.pairs %>% arrange(estimate)

ggplot(graph.numlinks.emm.cond.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.numlinks.emm.cond.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

```

```{r}

copy <- graph.numlinks.emm.cond.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         t.ratio=-t.ratio,
         lower.CL=-lower.CL,
         upper.CL=-upper.CL)

graph.numlinks.emm.cond.pairs.compl <- bind_rows(graph.numlinks.emm.cond.pairs,copy)


cond.lev <- c("Ctrl","Phr","Col","Siz")

graph.numlinks.emm.cond.pairs.compl$From <- factor(graph.numlinks.emm.cond.pairs.compl$From, levels=cond.lev)
graph.numlinks.emm.cond.pairs.compl$To <- factor(graph.numlinks.emm.cond.pairs.compl$To, levels=cond.lev)

#graph.numlinks.emm.cond.pairs.compl %>% arrange(desc(estimate))
graph.numlinks.emm.cond.pairs.compl %>% arrange(estimate)

ggplot(graph.numlinks.emm.cond.pairs.compl) +
  geom_tile(aes(x=To,y=ordered(From,levels=rev(cond.lev)),fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numlinks.emm.cond.pairs.compl) +
  geom_count(aes(x=To,y=ordered(From,levels=rev(cond.lev)),size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numlinks.emm.cond.pairs.compl) +
  geom_tile(aes(x=To,y=ordered(From,levels=rev(cond.lev)),fill=estimate)) +
    scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numlinks.emm.cond.pairs.compl) +
  geom_count(aes(x=To,y=ordered(From,levels=rev(cond.lev)),size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")


```

###### networks

```{r, eval=FALSE}

# try a network of the pairwise significance values?  bleh...
# using igraph

graph <- graph_from_data_frame(graph.numlinks.emm.cond.pairs %>% dplyr::select(-contrast), directed=TRUE)

E(graph)$width <- abs(E(graph)$estimate)*50
E(graph)$edge.color <- sig.colors[E(graph)$sig.levels]

graph

plot(graph, 
     edge.arrow.size=.5,
     vertex.frame.color="#555555")

```

```{r}

# using ggraph and tidygraph

graph <- graph_from_data_frame(graph.numlinks.emm.cond.pairs %>% dplyr::select(-contrast), directed=TRUE)

# plot using ggraph
ggraph(graph, layout = 'kk') +
  geom_edge_link(aes(start_cap = label_rect(node1.name),
                       end_cap = label_rect(node2.name),
                     color=factor(sig.level.names[sig.levels]),
                     edge_width=.5/sig.levels
                     ), 
                   arrow = arrow(length = unit(4, 'mm')))+
  geom_node_text(label = vertex_attr(graph,"name")) +
  scale_edge_color_manual("Significance Levels", values=sig.colors) +
  scale_edge_width_continuous(labels=rev(sig.level.names)) +
  theme_graph()

```




##### Dataset

###### emmeans

```{r}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numhighdeg, table(Dataset,Overestimated))
# ref_grid(graph.numhd.lmer.full.int.4) @ grid; .wgt. is number of observations

graph.numlinks.emm.data <- emmeans(graph.numlinks.lmer.full.int, "Dataset", nesting = NULL)
#graph.numhd.emm.condition <- emmeans(graph.numhd.lmer.full.int.4, "Condition", lmer.df = "satterthwaite")

graph.numlinks.emm.data

graph.numlinks.emm.data.df <- dplyr::as_data_frame(graph.numlinks.emm.data)

graph.numlinks.emm.data.df


# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numhd.emm.condition)

graph.numlinks.emm.data.cld <- cld(graph.numlinks.emm.data,
                details=TRUE,
                #alpha=0.01,
                #by="Dataset",
                #Letters="|||||||||||||||||||",
                sort=TRUE
)

graph.numlinks.emm.data.cld.df <- graph.numlinks.emm.data.cld$emmeans

graph.numlinks.emm.data.cld.df %>% dplyr::select(Dataset,.group)

graph.numlinks.emm.data.cld.df

ggplot(graph.numlinks.emm.data.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Dataset,ymax=upper.CL,ymin=lower.CL), width=.2) +
  geom_point(aes(x=Dataset,y=emmean), size=7) 

graph.numlinks.emm.data.cld.df$Dataset <- factor(graph.numlinks.emm.data.cld.df$Dataset, levels=graph.numlinks.emm.data.cld.df %>% arrange(desc(emmean)) %>% dplyr::select(Dataset) %>% unlist())


#emmip(graph.numlinks.lmer.full.int, ~Condition, CIs = TRUE)
emmip(graph.numlinks.emm.data, ~Dataset, CIs = TRUE)
plot(graph.numlinks.emm.data)
#plot(graph.numlinks.emm.cond, comparisons = TRUE)

graph.numlinks.emm.data.cld.df %>% arrange(desc(emmean))

ggplot(graph.numlinks.emm.data.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Dataset,ymax=upper.CL,ymin=lower.CL), width=.2) +
  geom_point(aes(x=Dataset,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.numlinks.emm.data.cld.df) +
  geom_errorbar(aes(x=Dataset,ymax=upper.CL,ymin=lower.CL), width=.2) +
  geom_point(aes(x=Dataset,y=emmean), size=7) +
  coord_flip() +
labs(title="Estimated Marginal Means for Dataset for Number of Links task,\ngraphics conditions")


#plot(ref_grid(graph.numnodes.lmer.int.3), by="Condition") 
# try to figure this out? maybe only works on the interaction?
```

```{r}

graph.numlinks.emm.data.pairs <- dplyr::as_data_frame(pairs(graph.numlinks.emm.data)) 
graph.numlinks.emm.data.pairs
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

pairs.CI <- confint(pairs(graph.numlinks.emm.data))

graph.numlinks.emm.data.pairs <- full_join(graph.numlinks.emm.data.pairs, pairs.CI)

#graph.numhd.diffemm.condition <- emmeans(graph.numhd.lmer.full.int.4, pairwise ~ Condition)
#graph.numhd.diffemm.condition$contrasts
#contrast(graph.numhd.emm.condition)
#confint(graph.numhd.emm.condition)
#pairs(graph.numhd.emm.condition, details=TRUE)
#confint(contrast(graph.numhd.emm.condition))
#confint(pairs(graph.numhd.emm.condition))
#coef(pairs(graph.numhd.emm.condition))


plot(pairs(graph.numlinks.emm.data))
plot(pairs(graph.numlinks.emm.data), comparisons = TRUE)

graph.numlinks.emm.data.pairs$sig.levels <- 
  case_when(graph.numlinks.emm.data.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.numlinks.emm.data.pairs$p.value < .001 ~ sig.level.names[2],
            graph.numlinks.emm.data.pairs$p.value < .01 ~ sig.level.names[3],
            graph.numlinks.emm.data.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.numlinks.emm.data.pairs$sig.levels <- factor(graph.numlinks.emm.data.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)


graph.numlinks.emm.data.pairs$contrast <- factor(graph.numlinks.emm.data.pairs$contrast, levels=graph.numlinks.emm.data.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())

graph.numlinks.emm.data.pairs <- graph.numlinks.emm.data.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.numlinks.emm.data.pairs %>% arrange(estimate)

ggplot(graph.numlinks.emm.data.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.numlinks.emm.data.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

```

```{r}

data.copy <- graph.numlinks.emm.data.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         t.ratio=-t.ratio,
         lower.CL=-lower.CL,
         upper.CL=-upper.CL)

graph.numlinks.emm.data.pairs.compl <- bind_rows(graph.numlinks.emm.data.pairs, data.copy)


#cond.lev <- c("Ctrl","Phr","Col","Siz")

#graph.numlinks.emm.data.pairs.compl$From <- factor(graph.numlinks.emm.data.pairs.compl$From, levels=cond.lev)
#graph.numlinks.emm.data.pairs.compl$To <- factor(graph.numlinks.emm.data.pairs.compl$To, levels=cond.lev)

graph.numlinks.emm.data.pairs.compl$From <- factor(graph.numlinks.emm.data.pairs.compl$From, levels=rev(unique(graph.numlinks.emm.data.pairs.compl$From)))

#graph.numlinks.emm.cond.pairs.compl %>% arrange(desc(estimate))
graph.numlinks.emm.data.pairs.compl %>% arrange(estimate)

ggplot(graph.numlinks.emm.data.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numlinks.emm.data.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numlinks.emm.data.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
    scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numlinks.emm.data.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")


```

##### Condition:Dataset

###### emmeans 

```{r}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numnodes, table(Dataset,Underestimated))
# ref_grid(graph.numnodes.lmer.int.5) @ grid; .wgt. is number of observations

# See also: https://cran.r-project.org/web/packages/emmeans/vignettes/interactions.html

#graph.numnodes.emm.cond <- emmeans(graph.numnodes.lmer.int.3, "Condition", nesting = NULL)
graph.numlinks.emm.conddata <- emmeans(graph.numlinks.lmer.full.int, ~ Dataset | Condition, nesting = NULL)
graph.numlinks.emm.conddata.2 <- emmeans(graph.numlinks.lmer.full.int, ~ Condition | Dataset, nesting = NULL)

graph.numlinks.emm.conddata

#graph.numnodes.diffemm.conddata <- emmeans(graph.numnodes.lmer.int.3, pairwise ~ Dataset | Condition, nesting = NULL)

#graph.numnodes.diffemm.conddata

graph.numlinks.emm.conddata.df <- dplyr::as_data_frame(graph.numlinks.emm.conddata)

graph.numlinks.emm.conddata.df %>% View()

# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numhd.emm.condition)

graph.numlinks.emm.conddata.cld <- cld(graph.numlinks.emm.conddata,
           details=TRUE,
           #alpha=0.01,
           #by="Dataset",
           #Letters="|||||||||||||||||||",
           sort=TRUE
           )

graph.numlinks.emm.conddata.cld[["emmeans"]]


graph.numlinks.emm.conddata.cld.df <- graph.numlinks.emm.conddata.cld[["emmeans"]]

graph.numlinks.emm.conddata.cld.df %>% dplyr::select(Dataset,Condition,.group) %>% print()
cld(graph.numlinks.emm.conddata.2,details=TRUE,sort=TRUE)[["emmeans"]] %>% dplyr::select(Dataset,Condition,.group) %>% print()

# TO DO : get this to print as single table

#graph.numnodes.emm.conddata.cld.df$Condition <- factor(graph.numnodes.emm.conddata.cld.df$Condition, levels=graph.numnodes.emm.conddata.cld %>% arrange(desc(emmean)) %>% dplyr::select(Condition) %>% unlist())

#emmip(graph.numnodes.lmer.int.3, ~Condition, CIs = TRUE)
emmip(graph.numlinks.emm.conddata, ~Condition|Dataset, CIs = TRUE)
plot(graph.numlinks.emm.conddata)
#plot(graph.numnodes.emm.conddata, comparisons = TRUE)

graph.numlinks.emm.conddata.cld.df %>% arrange(desc(emmean))

ggplot(graph.numlinks.emm.conddata.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Condition,ymax=upper.CL,ymin=lower.CL), width=.2) +
  #geom_point(aes(x=Condition,y=emmean), size=7) +
  geom_point(aes(x=Condition,y=emmean)) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Dataset) + 
  coord_flip()

ggplot(graph.numlinks.emm.conddata.cld.df) +
  geom_errorbar(aes(x=Dataset,ymax=upper.CL,ymin=lower.CL, color=Condition), width=.2, position=position_dodge(width=0.2)) +
  geom_point(aes(x=Dataset,y=emmean, color=Condition), position=position_dodge(width=0.2)) +
  geom_line(aes(x=Dataset,y=emmean, color=Condition, group=Condition), position=position_dodge(width=0.2)) +
  #scale_color_manual(labels=c("Blue","Black"),values=c("steelblue","black"), name="Node Color") +
  scale_color_discrete(labels=c("Control","Color","Phrasing","Size")) +
  labs(title="Estimated Marginal Means for Condition vs. Dataset for\nNumber of Links task, graphics conditions")

```

```{r}

graph.numlinks.emm.conddata.pairs <- dplyr::as_data_frame(pairs(graph.numlinks.emm.conddata)) 
graph.numlinks.emm.conddata.pairs %>% View()
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

conddata.pairs.CI <- confint(pairs(graph.numlinks.emm.conddata))

graph.numlinks.emm.conddata.pairs <- full_join(graph.numlinks.emm.conddata.pairs, conddata.pairs.CI)

#graph.numnodes.diffemm.cond <- emmeans(graph.numnodes.lmer.int.3, pairwise ~ Condition)
#graph.numnodes.diffemm.cond$contrasts
#contrast(graph.numnodes.emm.cond)
#confint(graph.numnodes.emm.cond)
#pairs(graph.numnodes.emm.cond, details=TRUE)
#confint(contrast(graph.numnodes.emm.cond))
#confint(pairs(graph.numnodes.emm.cond))
#coef(pairs(graph.numnodes.emm.cond))

plot(pairs(graph.numlinks.emm.conddata))
plot(pairs(graph.numlinks.emm.conddata), comparisons = TRUE)

graph.numlinks.emm.conddata.pairs$sig.levels <- 
  case_when(graph.numlinks.emm.conddata.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.numlinks.emm.conddata.pairs$p.value < .001 ~ sig.level.names[2],
            graph.numlinks.emm.conddata.pairs$p.value < .01 ~ sig.level.names[3],
            graph.numlinks.emm.conddata.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.numlinks.emm.conddata.pairs$sig.levels <- factor(graph.numlinks.emm.conddata.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)

graph.numlinks.emm.conddata.pairs$contrast.cond <- paste0(graph.numlinks.emm.conddata.pairs$contrast,graph.numlinks.emm.conddata.pairs$Condition)

graph.numlinks.emm.conddata.pairs$contrast.cond <- factor(graph.numlinks.emm.conddata.pairs$contrast.cond, levels=graph.numlinks.emm.conddata.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast.cond) %>% distinct() %>% unlist())

#graph.numnodes.emm.conddata.pairs %>% View()

graph.numlinks.emm.conddata.pairs$contrast <- 
  factor(as.character(graph.numlinks.emm.conddata.pairs$contrast), 
         levels=graph.numlinks.emm.conddata.pairs %>% group_by(contrast) %>% summarise(avgEst = mean(estimate)) %>% arrange(desc(avgEst)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())


graph.numlinks.emm.conddata.pairs <- graph.numlinks.emm.conddata.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.numlinks.emm.conddata.pairs %>% arrange(estimate)
#graph.numlinks.emm.conddata.pairs %>% View()

ggplot(graph.numlinks.emm.conddata.pairs) +
  geom_errorbar(aes(x=contrast.cond,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast.cond,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Condition, scales="free_y") +
  coord_flip()

ggplot(graph.numlinks.emm.conddata.pairs) +
  geom_errorbar(aes(x=contrast.cond,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast.cond,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Condition, scales="free_y") +
  coord_flip()


ggplot(graph.numlinks.emm.conddata.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Condition, scales="free_y") +
  coord_flip()

ggplot(graph.numlinks.emm.conddata.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Condition, scales="free_y") +
  coord_flip()


```


```{r}

conddata.copy <- graph.numlinks.emm.conddata.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         t.ratio=-t.ratio,
         lower.CL=-lower.CL,
         upper.CL=-upper.CL)

graph.numlinks.emm.conddata.pairs.compl <- bind_rows(graph.numlinks.emm.conddata.pairs, conddata.copy)


#cond.lev <- c("Ctrl","Phr","Col","Siz")

#graph.numnodes.emm.conddata.pairs.compl$From <- factor(graph.numnodes.emm.conddata.pairs.compl$From, levels=cond.lev)
#graph.numnodes.emm.conddata.pairs.compl$To <- factor(graph.numnodes.emm.conddata.pairs.compl$To, levels=cond.lev)

graph.numlinks.emm.conddata.pairs.compl$From <- factor(graph.numlinks.emm.conddata.pairs.compl$From, levels=c(9,8,7,5,3,1))


#graph.numlinks.emm.conddata.pairs.compl %>% arrange(desc(estimate))
graph.numlinks.emm.conddata.pairs.compl %>% arrange(estimate)

ggplot(graph.numlinks.emm.conddata.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Condition)

ggplot(graph.numlinks.emm.conddata.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Condition)

ggplot(graph.numlinks.emm.conddata.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
    scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Condition)

ggplot(graph.numlinks.emm.conddata.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Condition)


```



### Number of Nodes

#### lme4

```{r, cache=TRUE}

# Condition

graph.numnodes.lmer.cond <- lmer(LogError ~ Condition + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer.cond)

anova(graph.numnodes.lmer.cond)

# Condition is significant (p<2.2e-16); trying Ctrl_dummy

graph.numnodes.lmer.ctrldum <- lmer(LogError ~ Ctrl_dummy + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer.ctrldum)

anova(graph.numnodes.lmer.ctrldum)

# Ctrl_dummy is significant (p=6.466e-08); trying ConditionPhrasing

graph.numnodes.lmer.condphr <- lmer(LogError ~ ConditionPhrasing + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer.condphr)

anova(graph.numnodes.lmer.condphr)

# ConditionPhrasing is significant (p=0.000114); 

graph.numnodes.lmer.condgr <- lmer(LogError ~ ConditionGraphics + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer.condgr)

anova(graph.numnodes.lmer.condgr)

# ConditionGraphics is significant (p=7.639e-10)

graph.numnodes.lmer.condcol <- lmer(LogError ~ ConditionColor + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer.condcol)

anova(graph.numnodes.lmer.condcol)

# ConditionColor is significant (p=5.3e-09)

# trying Dataset

graph.numnodes.lmer.dataset <- lmer(LogError ~ Dataset + (1|Demo.ResponseID), data = graphics_numnodes, REML = T)

lmsum <- summary(graph.numnodes.lmer.dataset)
lmsum
#names(lmsum)

anova(graph.numnodes.lmer.dataset)

# Dataset is significant (p < 2.2e-16); trying QuestionOrder

graph.numnodes.lmer.qorder <- lmer(LogError ~ QuestionOrder + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer.qorder)

anova(graph.numnodes.lmer.qorder)

# QuestionOrder is significant (p=0.0225); trying DatasetOrder

graph.numnodes.lmer.dorder <- lmer(LogError ~ DatasetOrder + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer.dorder)

anova(graph.numnodes.lmer.dorder)

# DatasetOrder is significant (p=0.03128); trying DatasetDuration

graph.numnodes.lmer <- lmer(LogError ~ DatasetDuration + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# DatasetDuration is not significant; trying DatasetStartTime

graph.numnodes.lmer <- lmer(LogError ~ DatasetStartTime + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# DatasetStartTime is not significant; trying TaskOrder

graph.numnodes.lmer <- lmer(LogError ~ TaskOrder + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# TaskOrder is not significant; trying CorrectAnswer

graph.numnodes.lmer.correct <- lmer(LogError ~ CorrectAnswer + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer.correct)

anova(graph.numnodes.lmer.correct)

# CorrectAnswer is highly significant (p < 2.2e-16); trying Underestimated

graph.numnodes.lmer.underest <- lmer(LogError ~ Underestimated + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer.underest)

anova(graph.numnodes.lmer.underest)

# Underestimated is highly significant (p < 2.2e-16); trying Overestimated

graph.numnodes.lmer.overest <- lmer(LogError ~ Overestimated + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer.overest)

anova(graph.numnodes.lmer.overest)

# Overestimated is somewhat significant (p = 0.01932); 

graph.numnodes.lmer.underdum <- lmer(LogError ~ UnderestDummy + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer.underdum)

anova(graph.numnodes.lmer.underdum)

# UnderestDummy is highly significant (p < 2.2e-16); trying Stats.Q_TotalDuration

graph.numnodes.lmer <- lmer(LogError ~ Stats.Q_TotalDuration + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# Stats.Q_TotalDuration is not significant; trying Stats.dataset_count

graph.numnodes.lmer <- lmer(LogError ~ Stats.dataset_count + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# Stats.dataset_count is not signficant; trying Stats.OperatingSystem

graph.numnodes.lmer <- lmer(LogError ~ Stats.OperatingSystem + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# Stats.OperatingSystem is not signficant; skipping combined

graphics_numnodes.CS <- graphics_numnodes %>% mutate(StatsNumPixels=scale(StatsNumPixels))

graph.numnodes.lmer <- lmer(LogError ~ StatsNumPixels + (1|Demo.ResponseID), data=graphics_numnodes.CS, REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# StatsNumPixels is not signficant; trying Demo.age

graph.numnodes.lmer <- lmer(LogError ~ Demo.age + (1|Demo.ResponseID), data=graphics_numnodes %>% filter(!(is.na(Demo.age))), REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# Demo.age is not signficant; trying Demo.gender

graph.numnodes.lmer <- lmer(LogError ~ Demo.gender + (1|Demo.ResponseID), data=graphics_numnodes %>% filter(!(is.na(Demo.gender))), REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# Demo.gender is not signficant; trying Demo.lang

graph.numnodes.lmer <- lmer(LogError ~ Demo.lang + (1|Demo.ResponseID), data=graphics_numnodes %>% filter(!(is.na(Demo.lang))), REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# Demo.lang is not signficant; trying Demo.educ

graph.numnodes.lmer <- lmer(LogError ~ Demo.educ + (1|Demo.ResponseID), data=graphics_numnodes %>% filter(!(is.na(Demo.educ))), REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# Demo.educ is not signficant; trying Demo.acfield

graph.numnodes.lmer <- lmer(LogError ~ Demo.acfield + (1|Demo.ResponseID), data=graphics_numnodes %>% filter(!(is.na(Demo.acfield))), REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# Demo.acfield is not signficant overall; trying Demo.acfieldGrouped

graph.numnodes.lmer.acfieldgr <- lmer(LogError ~ Demo.acfieldGrouped + (1|Demo.ResponseID), data=graphics_numnodes %>% filter(!(is.na(Demo.acfieldGrouped))), REML = T)

summary(graph.numnodes.lmer.acfieldgr)

anova(graph.numnodes.lmer.acfieldgr)

# Demo.acfieldGrouped is slightly signficant (p=0.02863)

graph.numnodes.lmer <- lmer(LogError ~ Demo.acfieldGrouped2 + (1|Demo.ResponseID), data=graphics_numnodes %>% filter(!(is.na(Demo.acfieldGrouped2))), REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# Demo.acfieldGrouped2 is not signficant

graph.numnodes.lmer <- lmer(LogError ~ Demo.acfieldGrouped3 + (1|Demo.ResponseID), data=graphics_numnodes %>% filter(!(is.na(Demo.acfieldGrouped3))), REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# Demo.acfieldGrouped3 is not signficant

graph.numnodes.lmer <- lmer(LogError ~ Demo.dailytech_Computer + (1|Demo.ResponseID), data=graphics_numnodes %>% filter(!(is.na(Demo.dailytech_Computer))), REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# Demo.dailytech_Computer is not significant; trying Demo.dailytech_Tablet

graph.numnodes.lmer <- lmer(LogError ~ Demo.dailytech_Tablet + (1|Demo.ResponseID), data=graphics_numnodes %>% filter(!(is.na(Demo.dailytech_Tablet))), REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# Demo.dailytech_Computer is not significant (p=0.08993)

graph.numnodes.lmer <- lmer(LogError ~ Demo.dailytech_SmartPhone + (1|Demo.ResponseID), data=graphics_numnodes %>% filter(!(is.na(Demo.dailytech_SmartPhone))), REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# Demo.dailytech_SmartPhone is not significant; trying Demo.weeklygaming

graph.numnodes.lmer <- lmer(LogError ~ Demo.weeklygaming + (1|Demo.ResponseID), data=graphics_numnodes %>% filter(!(is.na(Demo.weeklygaming))), REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# Demo.weeklygaming is not significant; trying Demo.expdataanal

graph.numnodes.lmer <- lmer(LogError ~ Demo.expdataanal + (1|Demo.ResponseID), data=graphics_numnodes %>% filter(!(is.na(Demo.expdataanal))), REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# Demo.expdataanal is not significant; trying Demo.expdatavis

graph.numnodes.lmer <- lmer(LogError ~ Demo.expdatavis + (1|Demo.ResponseID), data=graphics_numnodes %>% filter(!(is.na(Demo.expdatavis))), REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# Demo.expdatavis is not significant; trying Demo.expreadnetvis

graph.numnodes.lmer <- lmer(LogError ~ Demo.expreadnetvis + (1|Demo.ResponseID), data=graphics_numnodes %>% filter(!(is.na(Demo.expreadnetvis))), REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# Demo.expreadnetvis is not significant; trying Demo.expreadnetvis.alot

graph.numnodes.lmer <- lmer(LogError ~ Demo.expreadnetvis.alot + (1|Demo.ResponseID), data=graphics_numnodes %>% filter(!(is.na(Demo.expreadnetvis.alot))), REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# Demo.expreadnetvis.alot is not significant; trying Demo.expcreatenetvis

graph.numnodes.lmer <- lmer(LogError ~ Demo.expcreatenetvis + (1|Demo.ResponseID), data=graphics_numnodes %>% filter(!(is.na(Demo.expcreatenetvis))), REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# Demo.expcreatenetvis is not significant; trying Demo.expcreatenetvis.alot

graph.numnodes.lmer <- lmer(LogError ~ Demo.expcreatenetvis.alot + (1|Demo.ResponseID), data=graphics_numnodes %>% filter(!(is.na(Demo.expcreatenetvis.alot))), REML = T)

summary(graph.numnodes.lmer)

anova(graph.numnodes.lmer)

# Demo.expcreatenetvis.alot is not significant; trying AvgDeg

graph.numnodes.lmer.avgdeg <- lmer(LogError ~ AvgDeg + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer.avgdeg)

anova(graph.numnodes.lmer.avgdeg)

# AvgDeg is significant (p < 2.2e-16); trying Density

graph.numnodes.lmer.dens <- lmer(LogError ~ Density + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer.dens)

anova(graph.numnodes.lmer.dens)

# Density is significant (p < 2.2e-16); trying LargeClust1

graph.numnodes.lmer.lgclust <- lmer(LogError ~ LargeClust1 + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer.lgclust)

anova(graph.numnodes.lmer.lgclust)

# LargeClust1 is significant (p < 2.2e-16); trying Modularity

graph.numnodes.lmer.mod <- lmer(LogError ~ Modularity + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer.mod)

anova(graph.numnodes.lmer.mod)

# Modularity is significant (p < 2.2e-16); trying NumClust

graph.numnodes.lmer.numclust <- lmer(LogError ~ NumClust + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer.numclust)

anova(graph.numnodes.lmer.numclust)

# NumClust is significant (p < 2.2e-16); trying NumHighDegree

graph.numnodes.lmer.numhighdeg <- lmer(LogError ~ NumHighDegree + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer.numhighdeg)

anova(graph.numnodes.lmer.numhighdeg)

# NumHighDegree is significant (p=1.098e-07); trying NumLinks

graph.numnodes.lmer.numlinks <- lmer(LogError ~ NumLinks + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer.numlinks)

anova(graph.numnodes.lmer.numlinks)

# NumLinks is significant (p=0.0136); trying NumNodes

graph.numnodes.lmer.numnodes <- lmer(LogError ~ NumNodes + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer.numnodes)

anova(graph.numnodes.lmer.numnodes)

# NumNodes is significant (p < 2.2e-16); trying NumNodesClust1

graph.numnodes.lmer.sizeclust1 <- lmer(LogError ~ NumNodesClust1 + (1|Demo.ResponseID), data=graphics_numnodes, REML = T)

summary(graph.numnodes.lmer.sizeclust1)

anova(graph.numnodes.lmer.sizeclust1)

# NumNodesClust1 is significant (p < 2.2e-16); 


```

```{r}

temp.numnodes <- graphics_numnodes %>% dplyr::select(Demo.ResponseID, LogError, Condition, Ctrl_dummy, ConditionPhrasing, ConditionGraphics, ConditionColor, Dataset, QuestionOrder, DatasetOrder, CorrectAnswer, Underestimated, Overestimated, UnderestDummy, Demo.acfieldGrouped, AvgDeg, Density, LargeClust1, Modularity, NumClust, NumHighDegree, NumLinks, NumNodes, NumNodesClust1) %>% drop_na() %>% mutate(QuestionOrderSc=scale(QuestionOrder))

graph.numnodes.lmer.full <- lmer(LogError ~ Condition + Dataset +
                                   QuestionOrderSc +
                                   DatasetOrder +
                                   UnderestDummy +
                                   Demo.acfieldGrouped +
                                   (1|Demo.ResponseID), data=temp.numnodes, REML = T)

summary(graph.numnodes.lmer.full)

anova(graph.numnodes.lmer.full)


```

```{r}

graph.numnodes.lmer.int <- lmer(LogError ~ Condition + Dataset +
                                  Condition:Dataset +
                                   QuestionOrderSc +
                                   DatasetOrder +
                                   UnderestDummy +
                                   Demo.acfieldGrouped +
                                   (1|Demo.ResponseID), data=temp.numnodes, REML = T)

summary(graph.numnodes.lmer.int)

anova(graph.numnodes.lmer.int)

anova(graph.numnodes.lmer.full, graph.numnodes.lmer.int)

graph.numnodes.lmer.int.2 <- lmer(LogError ~ Condition + Dataset +
                                  Condition:Dataset +
                                   QuestionOrderSc +
                                   UnderestDummy +
                                   Demo.acfieldGrouped +
                                   (1|Demo.ResponseID), data=temp.numnodes, REML = T)

summary(graph.numnodes.lmer.int.2)

anova(graph.numnodes.lmer.int.2)

anova(graph.numnodes.lmer.int, graph.numnodes.lmer.int.2) 
# not a significant difference; maybe keep the simpler one (2)

graph.numnodes.lmer.int.3 <- lmer(LogError ~ Condition + Dataset +
                                   QuestionOrderSc +
                                   UnderestDummy +
                                   Demo.acfieldGrouped +
                                  Condition:Dataset +
                                    Condition:UnderestDummy + 
                                   (1|Demo.ResponseID), data=temp.numnodes, REML = T)

summary(graph.numnodes.lmer.int.3)

anova(graph.numnodes.lmer.int.3)

anova(graph.numnodes.lmer.int.2, graph.numnodes.lmer.int.3) 
# keep 3

graph.numnodes.lmer.int.4 <- lmer(LogError ~ Condition + Dataset +
                                   QuestionOrderSc +
                                   UnderestDummy +
                                   Demo.acfieldGrouped +
                                  Condition:Dataset +
                                    Condition:UnderestDummy + 
                                    Dataset:UnderestDummy +
                                   (1|Demo.ResponseID), data=temp.numnodes, REML = T)

summary(graph.numnodes.lmer.int.4)

anova(graph.numnodes.lmer.int.4)

anova(graph.numnodes.lmer.int.3, graph.numnodes.lmer.int.4) 

# keep 3

graph.numnodes.lmer.int.5 <- lmer(LogError ~ Condition + Dataset +
                                   UnderestDummy +
                                   Demo.acfieldGrouped +
                                  Condition:Dataset +
                                    Condition:UnderestDummy + 
                                   (1|Demo.ResponseID), data=temp.numnodes, REML = T)

summary(graph.numnodes.lmer.int.5)

anova(graph.numnodes.lmer.int.5)

anova(graph.numnodes.lmer.int.3,graph.numnodes.lmer.int.5)

# keep 3


```

```{r}

#SAVE THE RESULTS
save(graph.numnodes.lmer.int.3, 
     file = file.path(analysisDataDir,"fits/graph_numnodes_lmer_int.RData"))

```

```{r, cache=TRUE}

rand(graph.numnodes.lmer.int.3)

# result shows that random effects of participant are significant (p<2e-16)

anova(graph.numnodes.lmer.int.3)

# SmartPhone significant, < 0.01

#ranef(graph.avgdeg.lmer.SP)

# displays the random effects; not that useful

# unlike lme(), lmer() doesn't allow for heterogeneous error variance structures (the "weights")

(r2nsj = r2beta(graph.numnodes.lmer.int.3, method = 'nsj', partial = TRUE))[1,'Rsq']

ggplot(graphics_numnodes) + geom_histogram(aes(LogError), binwidth=.005) + labs(title="Distribution of LogError values for Number of Nodes task,\ngraphics conditions")


```

```{r}

plot(graph.numnodes.lmer.int.3)

plot(graph.numnodes.lmer.int.3, resid(., scaled=TRUE) ~ fitted(.), abline = 0)

plot(graph.numnodes.lmer.int.3, resid(.) ~ fitted(.) | Condition, abline = 0)

plot(graph.numnodes.lmer.int.3, resid(., scaled=TRUE) ~ fitted(.) | Condition, abline = 0)

plot(graph.numnodes.lmer.int.3, LogError ~ fitted(.), abline = c(0,1))



```

```{r}

graph.numnodes.lmer.int.3.f <- fortify(graph.numnodes.lmer.int.3)

ggplot(graph.numnodes.lmer.int.3.f, aes(.fitted,.resid)) + 
  geom_point() +
  #facet_grid(.~Sex) + 
  geom_hline(yintercept=0)

ggplot(graph.numnodes.lmer.int.3.f, aes(.fitted,LogError)) + 
  geom_point() +
  geom_abline(aes(slope = 1, intercept = 0))

ggplot(graph.numnodes.lmer.int.3.f, aes(LogError,.fitted)) +
geom_point() +
geom_abline(aes(slope = 1, intercept = 0)) +
#scale_y_continuous(limits=c(0,0.3)) +
labs(title="Real vs. Predicted LogError values for Number of Nodes task,\ngraphics conditions")


```

```{r, eval=FALSE}

# TO DO: check out interpretation for these plots??

library(lattice)

prof <-  profile(graph.numnodes.lmer.int.3, optimizer="Nelder_Mead", which="beta_")

prof.CI <- confint(prof)

#CI2 <- confint(graph.numnodes.lmer.int.3, maxpts = 8)

xyplot(prof)

xyplot(prof, absVal = TRUE)

xyplot(prof, conf = c(0.95, 0.99), main = "95% and 99% profile() intervals")

# can also apply logProf() and varianceProf() to profile object

densityplot(prof)

splom(prof)

```


#### Least Squares Means

Do for each categorical predictor and interaction. 
Final model: LogError ~ Condition + Dataset + QuestionOrderSc + UnderestDummy +  
    Demo.acfieldGrouped + Condition:Dataset + Condition:UnderestDummy + (1 | Demo.ResponseID)

##### Condition

###### lsmeans

```{r}

# trying lmerTest::lsmeansLT

# note = lmerTest::lsmeans will only report lsmeans for factor variables and is deprecated

#graph.numnodes.lsmlt.cond <- lsmeansLT(graph.numnodes.lmer.int.3, test.effs = "Condition")
#Error in eval(predvars, data, env) : object 'QuestionOrderSc' not found

graph.numnodes.lsmlt.cond <- lsmeansLT(graph.numnodes.lmer.int.5, test.effs = "Condition")

# model 3 not working, some problem with QuestionOrderSc

plot(graph.numnodes.lmer.int.5) 

graph.numnodes.lsmlt.cond.df <- dplyr::as_data_frame(graph.numnodes.lsmlt.cond$lsmeans.table)

graph.numnodes.lsmlt.cond.df

graph.numnodes.lsmlt.cond.df$Condition <- factor(graph.numnodes.lsmlt.cond.df$Condition, levels=graph.numnodes.lsmlt.cond.df %>% arrange(desc(Estimate)) %>% dplyr::select(Condition) %>% unlist())

graph.numnodes.lsmlt.cond.df %>% arrange(desc(Estimate))

graph.numnodes.lsmlt.cond.df <- graph.numnodes.lsmlt.cond.df %>% 
  mutate(sig.levels = factor(case_when(
    `p-value` < .0001 ~ sig.level.names[1],
    `p-value` < .001 ~ sig.level.names[2],
    `p-value` < .01 ~ sig.level.names[3],
    `p-value` < .05 ~ sig.level.names[4],
    TRUE ~ sig.level.names[5]
    )
  ,levels=sig.level.names,ordered=TRUE))

graph.numnodes.lsmlt.cond.df

ggplot(graph.numnodes.lsmlt.cond.df) +
  geom_errorbar(aes(x=Condition,ymax=`Upper CI`,ymin=`Lower CI`), width=.2) +
  geom_point(aes(x=Condition,y=Estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

```

```{r}

# LSMeans Difference data

#graph.numnodes.difflsmlt.cond <- difflsmeans(graph.numnodes.lmer.int.3, test.effs = "Condition")
#Error in eval(predvars, data, env) : object 'QuestionOrderSc' not found
graph.numnodes.difflsmlt.cond <- difflsmeans(graph.numnodes.lmer.int.5, test.effs = "Condition")

plot(graph.numnodes.difflsmlt.cond)

graph.numnodes.difflsmlt.cond.df <- dplyr::as_data_frame(graph.numnodes.difflsmlt.cond$diffs.lsmeans.table, rownames="Pair")

graph.numnodes.difflsmlt.cond.df <- graph.numnodes.difflsmlt.cond.df %>% mutate(Pair=sub("Condition ","",Pair)) %>% separate(Pair, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.numnodes.difflsmlt.cond.df$sig.levels <- 
  case_when(graph.numnodes.difflsmlt.cond.df$`p-value` < .0001 ~ sig.level.names[1],
            graph.numnodes.difflsmlt.cond.df$`p-value` < .001 ~ sig.level.names[2],
            graph.numnodes.difflsmlt.cond.df$`p-value` < .01 ~ sig.level.names[3],
            graph.numnodes.difflsmlt.cond.df$`p-value` < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.numnodes.difflsmlt.cond.df$sig.levels <- factor(graph.numnodes.difflsmlt.cond.df$sig.levels, levels=sig.level.names,ordered=TRUE)

graph.numnodes.difflsmlt.cond.df$Pair <- factor(graph.numnodes.difflsmlt.cond.df$Pair, levels=graph.numnodes.difflsmlt.cond.df %>% arrange(desc(Estimate)) %>% dplyr::select(Pair) %>% distinct() %>% unlist())

#graph.numnodes.difflsmlt.cond.df %>% arrange(desc(Estimate))
graph.numnodes.difflsmlt.cond.df %>% arrange(Estimate)

ggplot(graph.numnodes.difflsmlt.cond.df) +
  geom_errorbar(aes(x=Pair,ymax=`Upper CI`,ymin=`Lower CI`), width=.5) +
  geom_point(aes(x=Pair,y=Estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.numnodes.difflsmlt.cond.df) +
  geom_errorbar(aes(x=Pair,ymax=`Upper CI`,ymin=`Lower CI`), width=.5) +
  geom_point(aes(x=Pair,y=Estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()




copy <- graph.numnodes.difflsmlt.cond.df %>% rename(From=To,To=From) %>% 
  mutate(Estimate=-Estimate,
         `t-value`=-`t-value`,
         `Lower CI`=-`Lower CI`,
         `Upper CI`=-`Upper CI`)

graph.numnodes.difflsmlt.cond.df.full <- bind_rows(graph.numnodes.difflsmlt.cond.df,copy)

cond.lev <- c("Ctrl","Phr","Col","Siz")

graph.numnodes.difflsmlt.cond.df.full$From <- factor(graph.numnodes.difflsmlt.cond.df.full$From, levels=cond.lev)
graph.numnodes.difflsmlt.cond.df.full$To <- factor(graph.numnodes.difflsmlt.cond.df.full$To, levels=cond.lev)


ggplot(graph.numnodes.difflsmlt.cond.df.full) +
  geom_tile(aes(x=To,y=ordered(From,levels=rev(cond.lev)),fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numnodes.difflsmlt.cond.df.full) +
  geom_count(aes(x=To,y=ordered(From,levels=rev(cond.lev)),size=abs(Estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")
  
```

###### emmeans 

```{r}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numnodes, table(Dataset,Underestimated))
# ref_grid(graph.numnodes.lmer.int.5) @ grid; .wgt. is number of observations

# See also: https://cran.r-project.org/web/packages/emmeans/vignettes/interactions.html

graph.numnodes.emm.cond <- emmeans(graph.numnodes.lmer.int.3, "Condition", nesting = NULL)
#graph.numhd.emm.condition <- emmeans(graph.numhd.lmer.full.int.4, "Condition", lmer.df = "satterthwaite")

graph.numnodes.emm.cond

graph.numnodes.emm.cond.df <- dplyr::as_data_frame(graph.numnodes.emm.cond)

graph.numnodes.emm.cond.df


# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numhd.emm.condition)

full.cld <- cld(graph.numnodes.emm.cond,
           details=TRUE,
           #alpha=0.01,
           #by="Dataset",
           #Letters="|||||||||||||||||||",
           sort=TRUE
           )
graph.numnodes.emm.cond.cld <- full.cld$emmeans

graph.numnodes.emm.cond.cld %>% dplyr::select(Condition,.group)

graph.numnodes.emm.cond.cld

graph.numnodes.emm.cond.cld$Condition <- factor(graph.numnodes.emm.cond.cld$Condition, levels=graph.numnodes.emm.cond.cld %>% arrange(desc(emmean)) %>% dplyr::select(Condition) %>% unlist())

#emmip(graph.numnodes.lmer.int.3, ~Condition, CIs = TRUE)
emmip(graph.numnodes.emm.cond, ~Condition, CIs = TRUE)
plot(graph.numnodes.emm.cond)
#plot(graph.numnodes.emm.cond, comparisons = TRUE)

graph.numnodes.emm.cond.cld %>% arrange(desc(emmean))

ggplot(graph.numnodes.emm.cond.cld) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Condition,ymax=upper.CL,ymin=lower.CL), width=.2) +
  geom_point(aes(x=Condition,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.numnodes.emm.cond.cld) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Condition,ymax=upper.CL,ymin=lower.CL), width=.2) +
  geom_point(aes(x=Condition,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip() +
labs(title="Estimated Marginal Means for Condition for Number of Nodes task,\ngraphics conditions")

#plot(ref_grid(graph.numnodes.lmer.int.3), by="Condition") 
# try to figure this out? maybe only works on the interaction?

```

```{r}

graph.numnodes.emm.cond.pairs <- dplyr::as_data_frame(pairs(graph.numnodes.emm.cond)) 
graph.numnodes.emm.cond.pairs
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

pairs.CI <- confint(pairs(graph.numnodes.emm.cond))

graph.numnodes.emm.cond.pairs <- full_join(graph.numnodes.emm.cond.pairs, pairs.CI)

#graph.numnodes.diffemm.cond <- emmeans(graph.numnodes.lmer.int.3, pairwise ~ Condition)
#graph.numnodes.diffemm.cond$contrasts
#contrast(graph.numnodes.emm.cond)
#confint(graph.numnodes.emm.cond)
#pairs(graph.numnodes.emm.cond, details=TRUE)
#confint(contrast(graph.numnodes.emm.cond))
#confint(pairs(graph.numnodes.emm.cond))
#coef(pairs(graph.numnodes.emm.cond))

plot(pairs(graph.numnodes.emm.cond))
plot(pairs(graph.numnodes.emm.cond), comparisons = TRUE)

graph.numnodes.emm.cond.pairs$sig.levels <- 
  case_when(graph.numnodes.emm.cond.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.numnodes.emm.cond.pairs$p.value < .001 ~ sig.level.names[2],
            graph.numnodes.emm.cond.pairs$p.value < .01 ~ sig.level.names[3],
            graph.numnodes.emm.cond.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.numnodes.emm.cond.pairs$sig.levels <- factor(graph.numnodes.emm.cond.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)


graph.numnodes.emm.cond.pairs$contrast <- factor(graph.numnodes.emm.cond.pairs$contrast, levels=graph.numnodes.emm.cond.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())

graph.numnodes.emm.cond.pairs <- graph.numnodes.emm.cond.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.numnodes.emm.cond.pairs %>% arrange(estimate)

ggplot(graph.numnodes.emm.cond.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.numnodes.emm.cond.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

```


```{r}

copy <- graph.numnodes.emm.cond.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         t.ratio=-t.ratio,
         lower.CL=-lower.CL,
         upper.CL=-upper.CL)

graph.numnodes.emm.cond.pairs.compl <- bind_rows(graph.numnodes.emm.cond.pairs,copy)


cond.lev <- c("Ctrl","Phr","Col","Siz")

graph.numnodes.emm.cond.pairs.compl$From <- factor(graph.numnodes.emm.cond.pairs.compl$From, levels=cond.lev)
graph.numnodes.emm.cond.pairs.compl$To <- factor(graph.numnodes.emm.cond.pairs.compl$To, levels=cond.lev)

#graph.numnodes.emm.cond.pairs.compl %>% arrange(desc(estimate))
graph.numnodes.emm.cond.pairs.compl %>% arrange(estimate)

ggplot(graph.numnodes.emm.cond.pairs.compl) +
  geom_tile(aes(x=To,y=ordered(From,levels=rev(cond.lev)),fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numnodes.emm.cond.pairs.compl) +
  geom_count(aes(x=To,y=ordered(From,levels=rev(cond.lev)),size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numnodes.emm.cond.pairs.compl) +
  geom_tile(aes(x=To,y=ordered(From,levels=rev(cond.lev)),fill=estimate)) +
    scale_fill_distiller(type="div", palette=4)

ggplot(graph.numnodes.emm.cond.pairs.compl) +
  geom_count(aes(x=To,y=ordered(From,levels=rev(cond.lev)),size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black"))


```

###### Networks

```{r, eval=FALSE}

# try a network of the pairwise significance values?  bleh...
# using igraph

graph <- graph_from_data_frame(graph.numnodes.emm.cond.pairs %>% dplyr::select(-contrast), directed=TRUE)

E(graph)$width <- abs(E(graph)$estimate)*50
E(graph)$edge.color <- sig.colors[E(graph)$sig.levels]

graph

plot(graph, 
     edge.arrow.size=.5,
     vertex.frame.color="#555555")

```

```{r}

# using ggraph and tidygraph

graph <- graph_from_data_frame(graph.numnodes.emm.cond.pairs %>% dplyr::select(-contrast), directed=TRUE)

# plot using ggraph
ggraph(graph, layout = 'kk') +
  geom_edge_link(aes(start_cap = label_rect(node1.name),
                       end_cap = label_rect(node2.name),
                     color=factor(sig.level.names[sig.levels]),
                     edge_width=.5/sig.levels
                     ), 
                   arrow = arrow(length = unit(4, 'mm')))+
  geom_node_text(label = vertex_attr(graph,"name")) +
  scale_edge_color_manual("Significance Levels", values=sig.colors) +
  scale_edge_width_continuous(labels=rev(sig.level.names)) +
  theme_graph()

```


##### Dataset

###### emmeans 

```{r}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numnodes, table(Dataset,Underestimated))
# ref_grid(graph.numnodes.lmer.int.5) @ grid; .wgt. is number of observations

# See also: https://cran.r-project.org/web/packages/emmeans/vignettes/interactions.html

graph.numnodes.emm.data <- emmeans(graph.numnodes.lmer.int.3, "Dataset", nesting = NULL)
#graph.numhd.emm.condition <- emmeans(graph.numhd.lmer.full.int.4, "Condition", lmer.df = "satterthwaite")

graph.numnodes.emm.data

graph.numnodes.emm.data.df <- dplyr::as_data_frame(graph.numnodes.emm.data)

graph.numnodes.emm.data.df


# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numnodes.emm.data)

graph.numnodes.emm.data.cld <- cld(graph.numnodes.emm.data,
           details=TRUE,
           #alpha=0.01,
           #by="Dataset",
           #Letters="|||||||||||||||||||",
           sort=TRUE
           )
graph.numnodes.emm.data.cld.df <- graph.numnodes.emm.data.cld$emmeans

graph.numnodes.emm.data.cld.df %>% dplyr::select(Dataset,.group)

graph.numnodes.emm.data.cld.df

graph.numnodes.emm.data.cld.df$Dataset <- factor(graph.numnodes.emm.data.cld.df$Dataset, levels=graph.numnodes.emm.data.cld.df %>% arrange(desc(emmean)) %>% dplyr::select(Dataset) %>% unlist())

#emmip(graph.numnodes.lmer.int.3, ~Dataset, CIs = TRUE)
emmip(graph.numnodes.emm.data, ~Dataset, CIs = TRUE)
plot(graph.numnodes.emm.data)
#plot(graph.numnodes.emm.data, comparisons = TRUE)

graph.numnodes.emm.data.cld.df %>% arrange(desc(emmean))

ggplot(graph.numnodes.emm.data.cld.df) +
  #geom_point(aes(x=Dataset,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Dataset,ymax=upper.CL,ymin=lower.CL), width=.2) +
  geom_point(aes(x=Dataset,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.numnodes.emm.data.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Dataset,ymax=upper.CL,ymin=lower.CL), width=.2) +
  geom_point(aes(x=Dataset,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip() +
labs(title="Estimated Marginal Means for Dataset for Number of Nodes task,\ngraphics conditions")

#plot(ref_grid(graph.numnodes.lmer.int.3), by="Dataset") 
# try to figure this out? maybe only works on the interaction?

```

```{r}

graph.numnodes.emm.data.pairs <- dplyr::as_data_frame(pairs(graph.numnodes.emm.data)) 
graph.numnodes.emm.data.pairs
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

data.pairs.CI <- confint(pairs(graph.numnodes.emm.data))

graph.numnodes.emm.data.pairs <- full_join(graph.numnodes.emm.data.pairs, data.pairs.CI)

#graph.numnodes.diffemm.cond <- emmeans(graph.numnodes.lmer.int.3, pairwise ~ Condition)
#graph.numnodes.diffemm.cond$contrasts
#contrast(graph.numnodes.emm.cond)
#confint(graph.numnodes.emm.cond)
#pairs(graph.numnodes.emm.cond, details=TRUE)
#confint(contrast(graph.numnodes.emm.cond))
#confint(pairs(graph.numnodes.emm.cond))
#coef(pairs(graph.numnodes.emm.cond))

plot(pairs(graph.numnodes.emm.data))
plot(pairs(graph.numnodes.emm.data), comparisons = TRUE)

graph.numnodes.emm.data.pairs$sig.levels <- 
  case_when(graph.numnodes.emm.data.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.numnodes.emm.data.pairs$p.value < .001 ~ sig.level.names[2],
            graph.numnodes.emm.data.pairs$p.value < .01 ~ sig.level.names[3],
            graph.numnodes.emm.data.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.numnodes.emm.data.pairs$sig.levels <- factor(graph.numnodes.emm.data.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)


graph.numnodes.emm.data.pairs$contrast <- factor(graph.numnodes.emm.data.pairs$contrast, levels=graph.numnodes.emm.data.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())

graph.numnodes.emm.data.pairs <- graph.numnodes.emm.data.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.numnodes.emm.data.pairs %>% arrange(estimate)

ggplot(graph.numnodes.emm.data.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.numnodes.emm.data.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

```


```{r}

data.copy <- graph.numnodes.emm.data.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         t.ratio=-t.ratio,
         lower.CL=-lower.CL,
         upper.CL=-upper.CL)

graph.numnodes.emm.data.pairs.compl <- bind_rows(graph.numnodes.emm.data.pairs,data.copy)


#cond.lev <- c("Ctrl","Phr","Col","Siz")

#graph.numnodes.emm.cond.pairs.compl$From <- factor(graph.numnodes.emm.cond.pairs.compl$From, levels=cond.lev)
#graph.numnodes.emm.cond.pairs.compl$To <- factor(graph.numnodes.emm.cond.pairs.compl$To, levels=cond.lev)

graph.numnodes.emm.data.pairs.compl$From <- factor(graph.numnodes.emm.data.pairs.compl$From, levels=c(9,8,7,5,3,1))

#graph.numnodes.emm.data.pairs.compl %>% arrange(desc(estimate))
graph.numnodes.emm.data.pairs.compl %>% arrange(estimate)

ggplot(graph.numnodes.emm.data.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numnodes.emm.data.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numnodes.emm.data.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
    scale_fill_distiller(type="div", palette=4)

ggplot(graph.numnodes.emm.data.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black"))


```

##### QuestionOrderSc

This is continuous; just plot against the estimate?

```{r}

#graph.numnodes.lmer.int.3.f <- fortify(graph.numnodes.lmer.int.3)

graph.numnodes.lmer.int.3.f %>% View()

ggplot(graph.numnodes.lmer.int.3.f, aes(.fitted,QuestionOrder)) + 
  geom_bin2d()

ggplot(temp.numnodes) + geom_point(aes(QuestionOrderSc, LogError))

ggplot(temp.numnodes) + geom_point(aes(QuestionOrderSc, LogError)) + geom_smooth(aes(QuestionOrderSc, LogError),method="lm") + labs(title="Overall Question Order (scaled) vs. LogError for\nNumber of Nodes task, graphics conditions", x="Overall Question Order (scaled)")

```

##### UnderestDummy

###### emmeans 

```{r}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numnodes, table(Dataset,Underestimated))
# ref_grid(graph.numnodes.lmer.int.5) @ grid; .wgt. is number of observations

# See also: https://cran.r-project.org/web/packages/emmeans/vignettes/interactions.html

graph.numnodes.emm.underest <- emmeans(graph.numnodes.lmer.int.3, "UnderestDummy", nesting = NULL)
#graph.numhd.emm.condition <- emmeans(graph.numhd.lmer.full.int.4, "Condition", lmer.df = "satterthwaite")

graph.numnodes.emm.underest

graph.numnodes.emm.underest.df <- dplyr::as_data_frame(graph.numnodes.emm.underest)

graph.numnodes.emm.underest.df


# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numnodes.emm.data)

graph.numnodes.emm.underest.cld <- cld(graph.numnodes.emm.underest,
           details=TRUE,
           #alpha=0.01,
           #by="Dataset",
           #Letters="|||||||||||||||||||",
           sort=TRUE
           )
graph.numnodes.emm.underest.cld.df <- graph.numnodes.emm.underest.cld$emmeans

graph.numnodes.emm.underest.cld.df %>% dplyr::select(UnderestDummy,.group)

graph.numnodes.emm.underest.cld.df

graph.numnodes.emm.underest.cld.df$UnderestDummy <- factor(graph.numnodes.emm.underest.cld.df$UnderestDummy, levels=graph.numnodes.emm.underest.cld.df %>% arrange(desc(emmean)) %>% dplyr::select(UnderestDummy) %>% unlist())

#emmip(graph.numnodes.lmer.int.3, ~UnderestDummy, CIs = TRUE)
emmip(graph.numnodes.emm.underest, ~UnderestDummy, CIs = TRUE)
plot(graph.numnodes.emm.underest)
#plot(graph.numnodes.emm.underest, comparisons = TRUE)

graph.numnodes.emm.underest.cld.df %>% arrange(desc(emmean))

ggplot(graph.numnodes.emm.underest.cld.df) +
  #geom_point(aes(x=UnderestDummy,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=UnderestDummy,ymax=upper.CL,ymin=lower.CL), width=.2) +
  geom_point(aes(x=UnderestDummy,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.numnodes.emm.underest.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=UnderestDummy,ymax=upper.CL,ymin=lower.CL), width=.2) +
  geom_point(aes(x=UnderestDummy,y=emmean), size=7) +
  scale_x_discrete(labels=c("Underestimated","Correct or\nOverestimated")) + 
labs(title="Estimated Marginal Means for Underestimated for Number of Nodes task,\ngraphics conditions",
     x="Underestimated") +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

#plot(ref_grid(graph.numnodes.lmer.int.3), by="Dataset") 
# try to figure this out? maybe only works on the interaction?

```

```{r}

graph.numnodes.emm.underest.pairs <- dplyr::as_data_frame(pairs(graph.numnodes.emm.underest)) 
graph.numnodes.emm.underest.pairs
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

underest.pairs.CI <- confint(pairs(graph.numnodes.emm.underest))

graph.numnodes.emm.underest.pairs <- full_join(graph.numnodes.emm.underest.pairs, underest.pairs.CI)

#graph.numnodes.diffemm.cond <- emmeans(graph.numnodes.lmer.int.3, pairwise ~ Condition)
#graph.numnodes.diffemm.cond$contrasts
#contrast(graph.numnodes.emm.cond)
#confint(graph.numnodes.emm.cond)
#pairs(graph.numnodes.emm.cond, details=TRUE)
#confint(contrast(graph.numnodes.emm.cond))
#confint(pairs(graph.numnodes.emm.cond))
#coef(pairs(graph.numnodes.emm.cond))

plot(pairs(graph.numnodes.emm.underest))
plot(pairs(graph.numnodes.emm.underest), comparisons = TRUE)

graph.numnodes.emm.underest.pairs$sig.levels <- 
  case_when(graph.numnodes.emm.underest.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.numnodes.emm.underest.pairs$p.value < .001 ~ sig.level.names[2],
            graph.numnodes.emm.underest.pairs$p.value < .01 ~ sig.level.names[3],
            graph.numnodes.emm.underest.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.numnodes.emm.underest.pairs$sig.levels <- factor(graph.numnodes.emm.underest.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)


graph.numnodes.emm.underest.pairs$contrast <- factor(graph.numnodes.emm.underest.pairs$contrast, levels=graph.numnodes.emm.underest.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())

graph.numnodes.emm.underest.pairs <- graph.numnodes.emm.underest.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.numnodes.emm.underest.pairs %>% arrange(estimate)

ggplot(graph.numnodes.emm.underest.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.numnodes.emm.underest.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

```


```{r}

underest.copy <- graph.numnodes.emm.underest.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         t.ratio=-t.ratio,
         lower.CL=-lower.CL,
         upper.CL=-upper.CL)

graph.numnodes.emm.underest.pairs.compl <- bind_rows(graph.numnodes.emm.underest.pairs, underest.copy)


#cond.lev <- c("Ctrl","Phr","Col","Siz")

#graph.numnodes.emm.cond.pairs.compl$From <- factor(graph.numnodes.emm.cond.pairs.compl$From, levels=cond.lev)
#graph.numnodes.emm.cond.pairs.compl$To <- factor(graph.numnodes.emm.cond.pairs.compl$To, levels=cond.lev)

#graph.numnodes.emm.data.pairs.compl$From <- factor(graph.numnodes.emm.data.pairs.compl$From, levels=c(9,8,7,5,3,1))

#graph.numnodes.emm.underest.pairs.compl %>% arrange(desc(estimate))
graph.numnodes.emm.underest.pairs.compl %>% arrange(estimate)

ggplot(graph.numnodes.emm.underest.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numnodes.emm.underest.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numnodes.emm.underest.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
    scale_fill_distiller(type="div", palette=4)

ggplot(graph.numnodes.emm.underest.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black"))


```

##### Demo.acfieldGrouped

###### emmeans 

```{r}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numnodes, table(Dataset,Underestimated))
# ref_grid(graph.numnodes.lmer.int.5) @ grid; .wgt. is number of observations

# See also: https://cran.r-project.org/web/packages/emmeans/vignettes/interactions.html

graph.numnodes.emm.acfieldgr <- emmeans(graph.numnodes.lmer.int.3, "Demo.acfieldGrouped", nesting = NULL)
#graph.numhd.emm.condition <- emmeans(graph.numhd.lmer.full.int.4, "Condition", lmer.df = "satterthwaite")

graph.numnodes.emm.acfieldgr

graph.numnodes.emm.acfieldgr.df <- dplyr::as_data_frame(graph.numnodes.emm.acfieldgr)

graph.numnodes.emm.acfieldgr.df


# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numnodes.emm.data)

graph.numnodes.emm.acfieldgr.cld <- cld(graph.numnodes.emm.acfieldgr,
           details=TRUE,
           #alpha=0.01,
           #by="Dataset",
           #Letters="|||||||||||||||||||",
           sort=TRUE
           )
graph.numnodes.emm.acfieldgr.cld.df <- graph.numnodes.emm.acfieldgr.cld$emmeans

graph.numnodes.emm.acfieldgr.cld.df %>% dplyr::select(Demo.acfieldGrouped,.group)

graph.numnodes.emm.acfieldgr.cld.df

graph.numnodes.emm.acfieldgr.cld.df$Demo.acfieldGrouped <- 
  factor(graph.numnodes.emm.acfieldgr.cld.df$Demo.acfieldGrouped, 
         levels=graph.numnodes.emm.acfieldgr.cld.df %>% arrange(desc(emmean)) %>% dplyr::select(Demo.acfieldGrouped) %>% unlist())

#emmip(graph.numnodes.lmer.int.3, ~Demo.acfieldGrouped, CIs = TRUE)
emmip(graph.numnodes.emm.acfieldgr, ~Demo.acfieldGrouped, CIs = TRUE)
plot(graph.numnodes.emm.acfieldgr)
#plot(graph.numnodes.emm.acfieldgr, comparisons = TRUE)

graph.numnodes.emm.acfieldgr.cld.df %>% arrange(desc(emmean))

ggplot(graph.numnodes.emm.acfieldgr.cld.df) +
  #geom_point(aes(x=Demo.acfieldGrouped,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Demo.acfieldGrouped,ymax=upper.CL,ymin=lower.CL), width=.2) +
  geom_point(aes(x=Demo.acfieldGrouped,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.numnodes.emm.acfieldgr.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Demo.acfieldGrouped,ymax=upper.CL,ymin=lower.CL), width=.2) +
  geom_point(aes(x=Demo.acfieldGrouped,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip() +
labs(title="Estimated Marginal Means for Academic Field for Number of Nodes task,\ngraphics conditions",x="Academic Field")

#plot(ref_grid(graph.numnodes.lmer.int.3), by="Dataset") 
# try to figure this out? maybe only works on the interaction?

```

```{r}

graph.numnodes.emm.acfieldgr.pairs <- dplyr::as_data_frame(pairs(graph.numnodes.emm.acfieldgr)) 
graph.numnodes.emm.acfieldgr.pairs
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

underest.pairs.CI <- confint(pairs(graph.numnodes.emm.acfieldgr))

graph.numnodes.emm.acfieldgr.pairs <- full_join(graph.numnodes.emm.acfieldgr.pairs, underest.pairs.CI)

#graph.numnodes.diffemm.cond <- emmeans(graph.numnodes.lmer.int.3, pairwise ~ Condition)
#graph.numnodes.diffemm.cond$contrasts
#contrast(graph.numnodes.emm.cond)
#confint(graph.numnodes.emm.cond)
#pairs(graph.numnodes.emm.cond, details=TRUE)
#confint(contrast(graph.numnodes.emm.cond))
#confint(pairs(graph.numnodes.emm.cond))
#coef(pairs(graph.numnodes.emm.cond))

plot(pairs(graph.numnodes.emm.acfieldgr))
plot(pairs(graph.numnodes.emm.acfieldgr), comparisons = TRUE)

graph.numnodes.emm.acfieldgr.pairs$sig.levels <- 
  case_when(graph.numnodes.emm.acfieldgr.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.numnodes.emm.acfieldgr.pairs$p.value < .001 ~ sig.level.names[2],
            graph.numnodes.emm.acfieldgr.pairs$p.value < .01 ~ sig.level.names[3],
            graph.numnodes.emm.acfieldgr.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.numnodes.emm.acfieldgr.pairs$sig.levels <- factor(graph.numnodes.emm.acfieldgr.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)


graph.numnodes.emm.acfieldgr.pairs$contrast <- 
  factor(graph.numnodes.emm.acfieldgr.pairs$contrast, 
         levels=graph.numnodes.emm.acfieldgr.pairs %>% 
           arrange(desc(estimate)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())

#graph.numnodes.emm.acfieldgr.pairs <- graph.numnodes.emm.acfieldgr.pairs %>% separate(contrast, c("From", "del", "To"), sep="[-]", remove=FALSE) %>% dplyr::select(-del)
graph.numnodes.emm.acfieldgr.pairs <- graph.numnodes.emm.acfieldgr.pairs %>% separate(contrast, c("From", "To"), sep="[-]", remove=FALSE) %>% mutate(From=str_trim(From),To=str_trim(To))

graph.numnodes.emm.acfieldgr.pairs %>% arrange(estimate)

ggplot(graph.numnodes.emm.acfieldgr.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

ggplot(graph.numnodes.emm.acfieldgr.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  coord_flip()

```


```{r}

underest.copy <- graph.numnodes.emm.acfieldgr.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         t.ratio=-t.ratio,
         lower.CL=-lower.CL,
         upper.CL=-upper.CL)

graph.numnodes.emm.acfieldgr.pairs.compl <- bind_rows(graph.numnodes.emm.acfieldgr.pairs,underest.copy)


#cond.lev <- c("Ctrl","Phr","Col","Siz")

#graph.numnodes.emm.cond.pairs.compl$From <- factor(graph.numnodes.emm.cond.pairs.compl$From, levels=cond.lev)
#graph.numnodes.emm.cond.pairs.compl$To <- factor(graph.numnodes.emm.cond.pairs.compl$To, levels=cond.lev)

graph.numnodes.emm.acfieldgr.pairs.compl$From <- factor(graph.numnodes.emm.acfieldgr.pairs.compl$From, levels=rev(unique(graph.numnodes.emm.acfieldgr.pairs.compl$From)))

#graph.numnodes.emm.acfieldgr.pairs.compl %>% arrange(desc(estimate))
graph.numnodes.emm.acfieldgr.pairs.compl %>% arrange(estimate)

ggplot(graph.numnodes.emm.acfieldgr.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numnodes.emm.acfieldgr.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numnodes.emm.acfieldgr.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
    scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")

ggplot(graph.numnodes.emm.acfieldgr.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From")


```

##### Condition:Dataset

###### emmeans 

```{r}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numnodes, table(Dataset,Underestimated))
# ref_grid(graph.numnodes.lmer.int.5) @ grid; .wgt. is number of observations

# See also: https://cran.r-project.org/web/packages/emmeans/vignettes/interactions.html

#graph.numnodes.emm.cond <- emmeans(graph.numnodes.lmer.int.3, "Condition", nesting = NULL)
graph.numnodes.emm.conddata <- emmeans(graph.numnodes.lmer.int.3, ~ Dataset | Condition, nesting = NULL)
graph.numnodes.emm.conddata.2 <- emmeans(graph.numnodes.lmer.int.3, ~ Condition | Dataset, nesting = NULL)

graph.numnodes.emm.conddata

#graph.numnodes.diffemm.conddata <- emmeans(graph.numnodes.lmer.int.3, pairwise ~ Dataset | Condition, nesting = NULL)

#graph.numnodes.diffemm.conddata

graph.numnodes.diffemm.conddata.df <- dplyr::as_data_frame(graph.numnodes.emm.conddata)

graph.numnodes.diffemm.conddata.df %>% View()

# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numhd.emm.condition)

graph.numnodes.emm.conddata.cld <- cld(graph.numnodes.emm.conddata,
           details=TRUE,
           #alpha=0.01,
           #by="Dataset",
           #Letters="|||||||||||||||||||",
           sort=TRUE
           )

graph.numnodes.emm.conddata.cld[["emmeans"]]


graph.numnodes.emm.conddata.cld.df <- graph.numnodes.emm.conddata.cld[["emmeans"]]

graph.numnodes.emm.conddata.cld.df %>% dplyr::select(Dataset,Condition,.group) %>% print()
cld(graph.numnodes.emm.conddata.2, details=TRUE, sort=TRUE)[["emmeans"]] %>% dplyr::select(Dataset,Condition,.group) %>% print()

# TO DO : get this to print as single table

#graph.numnodes.emm.conddata.cld.df$Condition <- factor(graph.numnodes.emm.conddata.cld.df$Condition, levels=graph.numnodes.emm.conddata.cld %>% arrange(desc(emmean)) %>% dplyr::select(Condition) %>% unlist())

#emmip(graph.numnodes.lmer.int.3, ~Condition, CIs = TRUE)
emmip(graph.numnodes.emm.conddata, ~Condition|Dataset, CIs = TRUE)
plot(graph.numnodes.emm.conddata)
#plot(graph.numnodes.emm.conddata, comparisons = TRUE)

graph.numnodes.emm.conddata.cld.df %>% arrange(desc(emmean))

ggplot(graph.numnodes.emm.conddata.cld.df) +
  #geom_point(aes(x=Condition,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Condition,ymax=upper.CL,ymin=lower.CL), width=.2) +
  geom_point(aes(x=Condition,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Dataset) + 
  coord_flip()

ggplot(graph.numnodes.emm.conddata.cld.df) +
  geom_errorbar(aes(x=Dataset,ymax=upper.CL,ymin=lower.CL, color=Condition), width=.2, position=position_dodge(width=0.2)) +
  geom_point(aes(x=Dataset,y=emmean, color=Condition), position=position_dodge(width=0.2)) +
  geom_line(aes(x=Dataset,y=emmean, color=Condition, group=Condition), position=position_dodge(width=0.2)) +
  #scale_color_manual(labels=c("Blue","Black"),values=c("steelblue","black"), name="Node Color") +
  scale_color_discrete(labels=c("Control","Color","Phrasing","Size")) +
  labs(title="Estimated Marginal Means for Condition vs. Dataset for\nNumber of Nodes task, graphics conditions")


```

```{r}

graph.numnodes.emm.conddata.pairs <- dplyr::as_data_frame(pairs(graph.numnodes.emm.conddata)) 
graph.numnodes.emm.conddata.pairs %>% View()
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

conddata.pairs.CI <- confint(pairs(graph.numnodes.emm.conddata))

graph.numnodes.emm.conddata.pairs <- full_join(graph.numnodes.emm.conddata.pairs, conddata.pairs.CI)

#graph.numnodes.diffemm.cond <- emmeans(graph.numnodes.lmer.int.3, pairwise ~ Condition)
#graph.numnodes.diffemm.cond$contrasts
#contrast(graph.numnodes.emm.cond)
#confint(graph.numnodes.emm.cond)
#pairs(graph.numnodes.emm.cond, details=TRUE)
#confint(contrast(graph.numnodes.emm.cond))
#confint(pairs(graph.numnodes.emm.cond))
#coef(pairs(graph.numnodes.emm.cond))

plot(pairs(graph.numnodes.emm.conddata))
plot(pairs(graph.numnodes.emm.conddata), comparisons = TRUE)

graph.numnodes.emm.conddata.pairs$sig.levels <- 
  case_when(graph.numnodes.emm.conddata.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.numnodes.emm.conddata.pairs$p.value < .001 ~ sig.level.names[2],
            graph.numnodes.emm.conddata.pairs$p.value < .01 ~ sig.level.names[3],
            graph.numnodes.emm.conddata.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.numnodes.emm.conddata.pairs$sig.levels <- factor(graph.numnodes.emm.conddata.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)

graph.numnodes.emm.conddata.pairs$contrast.cond <- paste0(graph.numnodes.emm.conddata.pairs$contrast,graph.numnodes.emm.conddata.pairs$Condition)

graph.numnodes.emm.conddata.pairs$contrast.cond <- factor(graph.numnodes.emm.conddata.pairs$contrast.cond, levels=graph.numnodes.emm.conddata.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast.cond) %>% distinct() %>% unlist())

#graph.numnodes.emm.conddata.pairs %>% View()

graph.numnodes.emm.conddata.pairs$contrast <- 
  factor(as.character(graph.numnodes.emm.conddata.pairs$contrast), 
         levels=graph.numnodes.emm.conddata.pairs %>% group_by(contrast) %>% summarise(avgEst = mean(estimate)) %>% arrange(desc(avgEst)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())


graph.numnodes.emm.conddata.pairs <- graph.numnodes.emm.conddata.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.numnodes.emm.conddata.pairs %>% arrange(estimate)
#graph.numnodes.emm.conddata.pairs %>% View()

ggplot(graph.numnodes.emm.conddata.pairs) +
  geom_errorbar(aes(x=contrast.cond,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast.cond,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Condition, scales="free_y") +
  coord_flip()

ggplot(graph.numnodes.emm.conddata.pairs) +
  geom_errorbar(aes(x=contrast.cond,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast.cond,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Condition, scales="free_y") +
  coord_flip()


ggplot(graph.numnodes.emm.conddata.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Condition, scales="free_y") +
  coord_flip()

ggplot(graph.numnodes.emm.conddata.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~Condition, scales="free_y") +
  coord_flip()


```


```{r}

copy <- graph.numnodes.emm.conddata.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         t.ratio=-t.ratio,
         lower.CL=-lower.CL,
         upper.CL=-upper.CL)

graph.numnodes.emm.conddata.pairs.compl <- bind_rows(graph.numnodes.emm.conddata.pairs,copy)


#cond.lev <- c("Ctrl","Phr","Col","Siz")

#graph.numnodes.emm.conddata.pairs.compl$From <- factor(graph.numnodes.emm.conddata.pairs.compl$From, levels=cond.lev)
#graph.numnodes.emm.conddata.pairs.compl$To <- factor(graph.numnodes.emm.conddata.pairs.compl$To, levels=cond.lev)

graph.numnodes.emm.conddata.pairs.compl$From <- factor(graph.numnodes.emm.conddata.pairs.compl$From, levels=c(9,8,7,5,3,1))


#graph.numnodes.emm.conddata.pairs.compl %>% arrange(desc(estimate))
graph.numnodes.emm.conddata.pairs.compl %>% arrange(estimate)

ggplot(graph.numnodes.emm.conddata.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Condition)

ggplot(graph.numnodes.emm.conddata.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Condition)

ggplot(graph.numnodes.emm.conddata.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
    scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Condition)

ggplot(graph.numnodes.emm.conddata.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~Condition)


```



##### Condition:UnderestDummy

###### emmeans 

```{r}
# trying to use emmeans package for lsmeans table

# can use ref_grid to see if emmeans is finding nestings within variables, which can cause problems(?)
# ref_grid(graph.numhd.lmer.full.int.4)
# unfortunately, considers Overestimated nested in Dataset because I didn't include 
# Overestimated as a fixed effect; can use nesting = NULL to ignore this auto-detection of nesting

# also want to check if any combination of two factors has zeroes in the cells
# with(graphics_numnodes, table(Dataset,Underestimated))
# ref_grid(graph.numnodes.lmer.int.5) @ grid; .wgt. is number of observations

# See also: https://cran.r-project.org/web/packages/emmeans/vignettes/interactions.html

#graph.numnodes.emm.cond <- emmeans(graph.numnodes.lmer.int.3, "Condition", nesting = NULL)
graph.numnodes.emm.condunder <- emmeans(graph.numnodes.lmer.int.3, ~ Condition | UnderestDummy, nesting = NULL)

graph.numnodes.emm.condunder

#graph.numnodes.diffemm.dataunder <- emmeans(graph.numnodes.lmer.int.3, pairwise ~ Dataset | Underestimated, nesting = NULL)

#graph.numnodes.diffemm.dataunder

graph.numnodes.emm.condunder.df <- dplyr::as_data_frame(graph.numnodes.emm.condunder)

graph.numnodes.emm.condunder.df

# From: https://cran.r-project.org/web/packages/emmeans/vignettes/comparisons.html
# The blue bars are confidence intervals for the EMMs, and the red arrows are for the comparisons among them. If an arrow from one mean overlaps an arrow from another group, the difference is not significant, based on the adjust setting (which defaults to "tukey"). (Note: Don’t ever use confidence intervals for EMMs to perform comparisons; they can be very misleading.)

# TO DO : can't figure out how to extract data about the arrows in order to reproduce the graph

#xtable::xtable(graph.numhd.emm.condition)

graph.numnodes.emm.condunder.cld <- cld(graph.numnodes.emm.condunder,
           details=TRUE,
           #alpha=0.01,
           #by="Dataset",
           #Letters="|||||||||||||||||||",
           sort=TRUE
           )

graph.numnodes.emm.condunder.cld[["emmeans"]]


graph.numnodes.emm.condunder.cld.df <- graph.numnodes.emm.condunder.cld[["emmeans"]]

graph.numnodes.emm.condunder.cld.df %>% dplyr::select(Condition,UnderestDummy,.group) %>% print()

# TO DO : get this to print as single table

#graph.numnodes.emm.dataunder.cld.df$Underestimated <- factor(graph.numnodes.emm.dataunder.cld.df$Underestimated, levels=graph.numnodes.emm.dataunder.cld.df %>% arrange(desc(emmean)) %>% dplyr::select(Underestimated) %>% unlist())

#graph.numnodes.emm.condunder.cld.df$Condition <- factor(graph.numnodes.emm.condunder.cld.df$Condition, levels=graph.numnodes.emm.condunder.cld.df %>% arrange(desc(emmean)) %>% dplyr::select(Condition) %>% unlist())

#emmip(graph.numnodes.lmer.int.3, ~Dataset, CIs = TRUE)
emmip(graph.numnodes.emm.condunder, ~Condition|UnderestDummy, CIs = TRUE)
plot(graph.numnodes.emm.condunder)
#plot(graph.numnodes.emm.condunder, comparisons = TRUE)

graph.numnodes.emm.condunder.cld.df %>% arrange(desc(emmean))

ggplot(graph.numnodes.emm.condunder.cld.df) +
  #geom_point(aes(x=Underestimated,y=emmean), shape=21, size=7) +
  geom_errorbar(aes(x=Condition,ymax=upper.CL,ymin=lower.CL), width=.2) +
  geom_point(aes(x=Condition,y=emmean), size=7) +
  #scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~UnderestDummy) + 
  coord_flip()

ggplot(graph.numnodes.emm.condunder.cld.df) +
  geom_errorbar(aes(x=Condition,ymax=upper.CL,ymin=lower.CL, color=UnderestDummy), width=.2, position=position_dodge(width=0.2)) +
  geom_point(aes(x=Condition,y=emmean, color=UnderestDummy), position=position_dodge(width=0.2)) +
  #geom_line(aes(x=Condition,y=emmean, color=UnderestDummy, group=UnderestDummy), position=position_dodge(width=0.2)) +
  #scale_color_manual(labels=c("Blue","Black"),values=c("steelblue","black"), name="Node Color") +
  scale_color_discrete(labels=c("Underestimated","Correct or\nOverestimated"), name="Underestimated") +
  labs(title="Estimated Marginal Means for Condition vs. Underestimated for\nNumber of Nodes task, graphics conditions")

```

```{r}

graph.numnodes.emm.condunder.pairs <- dplyr::as_data_frame(pairs(graph.numnodes.emm.condunder)) 
graph.numnodes.emm.condunder.pairs #%>% View()
# for some reason, full.cld$comparisons returns estimates that are all positive; 
# pairs(graph.numhd.emm.condition) has both negative and positive estimates
# and joins better to confint()

condunder.pairs.CI <- confint(pairs(graph.numnodes.emm.condunder))

graph.numnodes.emm.condunder.pairs <- full_join(graph.numnodes.emm.condunder.pairs, condunder.pairs.CI)

#graph.numnodes.diffemm.cond <- emmeans(graph.numnodes.lmer.int.3, pairwise ~ Condition)
#graph.numnodes.diffemm.cond$contrasts
#contrast(graph.numnodes.emm.cond)
#confint(graph.numnodes.emm.cond)
#pairs(graph.numnodes.emm.cond, details=TRUE)
#confint(contrast(graph.numnodes.emm.cond))
#confint(pairs(graph.numnodes.emm.cond))
#coef(pairs(graph.numnodes.emm.cond))

plot(pairs(graph.numnodes.emm.condunder))
plot(pairs(graph.numnodes.emm.condunder), comparisons = TRUE)

graph.numnodes.emm.condunder.pairs$sig.levels <- 
  case_when(graph.numnodes.emm.condunder.pairs$p.value < .0001 ~ sig.level.names[1],
            graph.numnodes.emm.condunder.pairs$p.value < .001 ~ sig.level.names[2],
            graph.numnodes.emm.condunder.pairs$p.value < .01 ~ sig.level.names[3],
            graph.numnodes.emm.condunder.pairs$p.value < .05 ~ sig.level.names[4],
            TRUE ~ sig.level.names[5])

graph.numnodes.emm.condunder.pairs$sig.levels <- factor(graph.numnodes.emm.condunder.pairs$sig.levels, levels=sig.level.names,ordered=TRUE)

graph.numnodes.emm.condunder.pairs$contrast.all <- paste0(graph.numnodes.emm.condunder.pairs$contrast,graph.numnodes.emm.condunder.pairs$UnderestDummy)

graph.numnodes.emm.condunder.pairs$contrast.all <- factor(graph.numnodes.emm.condunder.pairs$contrast.all, levels=graph.numnodes.emm.condunder.pairs %>% arrange(desc(estimate)) %>% dplyr::select(contrast.all) %>% distinct() %>% unlist())

#graph.numnodes.emm.conddata.pairs %>% View()

graph.numnodes.emm.condunder.pairs$contrast <- 
  factor(as.character(graph.numnodes.emm.condunder.pairs$contrast), 
         levels=graph.numnodes.emm.condunder.pairs %>% group_by(contrast) %>% summarise(avgEst = mean(estimate)) %>% arrange(desc(avgEst)) %>% dplyr::select(contrast) %>% distinct() %>% unlist())


graph.numnodes.emm.condunder.pairs <- graph.numnodes.emm.condunder.pairs %>% separate(contrast, c("From", "del", "To"), sep="[ ]", remove=FALSE) %>% dplyr::select(-del)

graph.numnodes.emm.condunder.pairs %>% arrange(estimate)
#graph.numnodes.emm.condunder.pairs %>% View()

ggplot(graph.numnodes.emm.condunder.pairs) +
  geom_errorbar(aes(x=contrast.all,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast.all,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~UnderestDummy, scales="free_y") +
  coord_flip()

ggplot(graph.numnodes.emm.condunder.pairs) +
  geom_errorbar(aes(x=contrast.all,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast.all,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~UnderestDummy, scales="free_y") +
  coord_flip()


ggplot(graph.numnodes.emm.condunder.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~UnderestDummy, scales="free_y") +
  coord_flip()

ggplot(graph.numnodes.emm.condunder.pairs) +
  geom_errorbar(aes(x=contrast,ymax=upper.CL,ymin=lower.CL), width=.5) +
  geom_point(aes(x=contrast,y=estimate, fill=sig.levels), shape=21, size=7) +
  geom_hline(aes(yintercept=0)) +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  facet_wrap(~UnderestDummy, scales="free_y") +
  coord_flip()


```


```{r}

condunder.copy <- graph.numnodes.emm.condunder.pairs %>% rename(From=To,To=From) %>% 
  mutate(estimate=-estimate,
         t.ratio=-t.ratio,
         lower.CL=-lower.CL,
         upper.CL=-upper.CL)

graph.numnodes.emm.condunder.pairs.compl <- bind_rows(graph.numnodes.emm.condunder.pairs,condunder.copy)


#cond.lev <- c("Ctrl","Phr","Col","Siz")

graph.numnodes.emm.condunder.pairs.compl$From <- factor(graph.numnodes.emm.condunder.pairs.compl$From, levels=rev(cond.lev))
graph.numnodes.emm.condunder.pairs.compl$To <- factor(graph.numnodes.emm.condunder.pairs.compl$To, levels=cond.lev)

#graph.numnodes.emm.conddata.pairs.compl$From <- factor(graph.numnodes.emm.conddata.pairs.compl$From, levels=c(9,8,7,5,3,1))


#graph.numnodes.emm.conddata.pairs.compl %>% arrange(desc(estimate))
graph.numnodes.emm.condunder.pairs.compl %>% arrange(estimate)

ggplot(graph.numnodes.emm.condunder.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=sig.levels), color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~UnderestDummy)

ggplot(graph.numnodes.emm.condunder.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=sig.levels), shape=21, color="black") +
  scale_fill_manual("Significance Levels", values=sig.colors) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~UnderestDummy)

ggplot(graph.numnodes.emm.condunder.pairs.compl) +
  geom_tile(aes(x=To,y=From,fill=estimate)) +
    scale_fill_distiller(type="div", palette=4) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~UnderestDummy)

ggplot(graph.numnodes.emm.condunder.pairs.compl) +
  geom_count(aes(x=To,y=From,size=abs(estimate),fill=estimate, color=p.value<.01), shape=21) +
  scale_fill_distiller(type="div", palette=4) +
  scale_color_manual(values=c("grey90","black")) +
  scale_x_discrete(drop=FALSE, position = "top") +
  scale_y_discrete(drop=FALSE, name="From") +
  facet_wrap(~UnderestDummy)


```





